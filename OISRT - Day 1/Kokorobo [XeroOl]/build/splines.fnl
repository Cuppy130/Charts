(do (require-macros "build.macros") (local oldpercent {}) (local final {}) (for [col 0 3] (tset oldpercent col 0) (tset final col 0)) (var which 0) (func [0 8999999488] (fn splinereset [b mods] (set which 0))) (func {1 0 2 8999999488 :defer true} (fn activate [p] (for [col 0 3] (for [pn 1 2] (: (. P pn) "SetXSpline" which col (. final col) 600 -1) (: (. P pn) "SetXSpline" (+ which 1) col -1 -1 -1))))) (fn point [b pos] (local len 1) (func {1 (- b 0.25) 2 len 3 linear :defer true} (fn activate [p] (if (= p 1) (do (for [col 0 3] (tset final col (. pos col)))) (do (for [col 0 3] (for [pn 1 2] (: (. P pn) "SetXSpline" which col (. pos col) (- (* p 800) 200) -1))) (set which (+ which 1))))))) (fn mix [p old new] (+ (* p new) (* (- 1 p) old))) (local splinetimings {}) (local times {}) (var maxbeat 0) (fn except_there_are_splines [self] (table.insert splinetimings self) (for [i 0 1 (/ 1 13)] (tset times (+ (. self 1) (* i (. self 2))) true)) (local end (+ (. self 1) (. self 2))) (if (> end maxbeat) (do (set maxbeat end)))) (fn finalizesplines {} (fn comparator [a b] (< (. a 1) (. b 1))) (stable_sort splinetimings comparator) (var splineindex 1) (local activesplines {}) (local modstate {}) (local modtargets {}) (for [col 0 3] (tset modstate col 0) (tset modtargets col 0)) (local beats {}) (each [v (pairs times)] (table.insert beats v)) (table.sort beats) (each [_ beat (ipairs beats)] (for [col 0 3] (tset modstate col (. modtargets col))) (while (and (<= splineindex (length splinetimings)) (< (. splinetimings splineindex 1) beat)) (local e (. splinetimings splineindex)) (for [col 0 3] (tset e (+ col 4) (- (. e (+ col 4)) (. modtargets col))) (tset modtargets col (+ (. modtargets col) (. e (+ col 4)))) (tset modstate col (+ (. modstate col) (. e (+ col 4))))) (table.insert activesplines e) (set splineindex (+ splineindex 1))) (var touched (not= (length activesplines) 0)) (var i 1) (while (<= i (length activesplines)) (local e (. activesplines i)) (if (< beat (+ (. e 1) (. e 2))) (do (local e3 (- ((. e 3) (/ (- beat (. e 1)) (. e 2))) 1)) (for [col 0 3] (tset modstate col (+ (. modstate col) (* e3 (. e (+ col 4)))))) (set i (+ i 1))) (do (tset activesplines i (table.remove activesplines))))) (if touched (do (local cols (copy modstate)) (point beat cols))))) (local swaps {}) (local cols {:d 1 :l 0 :r 3 :u 2}) (local has string.find) (fn lambda0 [path] (var e true) (if (not (has path "l")) (do (lambda0 (.. path "l")) (set e false))) (if (not (has path "d")) (do (lambda0 (.. path "d")) (set e false))) (if (not (has path "u")) (do (lambda0 (.. path "u")) (set e false))) (if (not (has path "r")) (do (lambda0 (.. path "r")) (set e false))) (if e (do (local list {}) (local list-flipped {}) (for [col 0 3] (local t (. cols (string.sub path (+ col 1) (+ col 1)))) (tset list t (* (- col t) 100)) (tset list-flipped t (* (- t col) 100))) (tset swaps path list) (tset swaps (.. path "-flipped") list-flipped)))) (lambda0 "") (fn swap [t] (assert (= (type (. t 1)) "number") "arg 1") (assert (= (type (. t 2)) "number") "arg 2") (assert (not= (type (. t 3)) "nil") "arg 3") (assert (= (type (. t 4)) "string") "arg 4") (assert (. swaps (. t 4)) (. t 4)) (local which (. t 4)) (for [col 0 3] (tset t (+ col 4) (. swaps which col))) (except_there_are_splines t) swap) (export swap) (export finalizesplines))
