(do (require-macros "build.macros") (: self "fov" 45) (for [pn 1 2] (setupJudgeProxy (. PJ pn) (: (. P pn) "GetChild" "Judgment") pn) (setupJudgeProxy (. PC pn) (: (. P pn) "GetChild" "Combo") pn) (: (. PJ pn) "zoom" 0.8) (: (. PC pn) "zoom" 0.8) (: (. PJ pn) "y" (- scy 20)) (: (. PC pn) "y" (+ scy 50))) (for [pn 1 2] (each [k v (pairs PP)] (if (. v pn) (do (: (. v pn) "SetTarget" (. P pn)) (: (. v pn) "hidden" 1)))) (: (. P pn) "hidden" 1)) (var active "back") (fn ppshow [name] (: (. PP active 1) "hidden" 1) (set active name) (: (. PP active 1) "hidden" 0)) (: (. PP "back" 1) "hidden" 0) (: (. PP "back" 2) "hidden" 0) (: bgquad "diffuse" (color night1)) (: bgquad "xywh" scx scy sw sh) (: cover "diffuse" (color night1)) (: cover "xywh" scx scy sw sh) (func [0] (fn k {} (: cover "hidden" 1))) (local orbpool (: orbcontainer "GetChildren")) (for [i 1 (length orbpool)] (local orb (. orbpool i)) (: orb "hidden" 1) (: orb "blend" "add") (: orb "SetWidth" 256) (: orb "SetHeight" 256)) (fn orb [beat size r g b] (local len 60) (var orb nil) (local x (rand.int 0 sw)) (local y (rand.int 0 sh)) (func {1 beat :defer true} (fn init {} (local index (rand.int 1 (length orbpool))) (set orb (table.remove orbpool)) (: orb "xy" x y) (: orb "hidden" 0))) (func [beat len bell 0 0.4] (fn run [p] (: orb "zoom" p) (: orb "diffuse" r g b p))) (func [(+ beat len)] (fn deinit {} (table.insert orbpool orb) (: orb "hidden" 1)))) (local colors [[(color frost1)]
 [(color frost2)]
 [(color frost3)]
 [(color frost1)]
 [(color frost2)]
 [(color frost3)]
 [(color aurora1)]
 [(color aurora2)]
 [(color aurora3)]
 [(color aurora4)]
 [(color aurora5)]]) (for [b 1 320] (local i (rand.int 1 (length colors))) (orb b (rand.float 0.3 0.5) (unpack (. colors i))) (rand.int 5)) (local height 9) (local width 12) (local gridpool {}) (for [r 1 height] (for [c 1 width] (local tile (: gridcontainer "GetChildAt" (+ (* (- r 1) width) (- c 1)))) (table.insert gridpool tile) (: tile "hidden" 1) (: tile "xy" (+ (- (* (/ (- c 0.5) width) 640) 320) scx) (+ (- (* (/ (- r 0.5) height) 480) 240) scy)) (: tile "SetWidth" (/ sw width)) (: tile "SetHeight" (/ sh height)) (: tile "zbuffer" 1))) (: crosscontainer "SetVanishPoint" scx scy) (local crosspool (: crosscontainer "GetChildren")) (: crosscontainer "fov" 90) (: crosscontainer "xy" scx scy) (for [i 1 (length crosspool)] (local cross (. crosspool i)) (: cross "diffuse" (unpack (. colors (rand.int (length colors))))) (: cross "diffusealpha" 0.5) (local pos (- i (+ (* (length crosspool) 0.5) 0.5))) (local inner (: cross "GetChildAt" 0)) (: inner "z" (* (- scx) 0.2)) (: inner "xywh" 0 0 10 1000) (: cross "rotationx" 90) (: cross "hidden" 1)) (do (aft aft1) (sprite sprite1) (aftsprite aft1 sprite1) (local shader (: sprite1 "GetShader")) (fn flatten [xs] (local result {}) (each [_ x (ipairs xs)] (each [_ e (ipairs x)] (tset result (+ (length result) 1) e))) result) (: shader "uniform4fv" "scheme" (flatten [[(color night1)]
 [(color night2)]
 [(color night3)]
 [(color night4)]
 [(color storm1)]
 [(color storm2)]
 [(color storm3)]
 [(color frost1)]
 [(color frost2)]
 [(color frost3)]
 [(color frost4)]
 [(color aurora1)]
 [(color aurora2)]
 [(color aurora3)]
 [(color aurora4)]
 [(color aurora5)]
 [0 0 0 0]]))) (do (aft aft2) (sprite sprite2) (aftsprite aft2 sprite2) (: sprite2 "zbias" -1) (: sprite2 "zbuffer" 1)) (fn void [t] (if (= t 1) (do (: aft2 "hidden" 1) (: sprite2 "hidden" 1)) (do (: aft2 "hidden" 0) (: sprite2 "hidden" 0) (: sprite2 "cropleft" (* t 0.5)) (: sprite2 "cropright" (* t 0.5)) (: sprite2 "croptop" (* t 0.5)) (: sprite2 "cropbottom" (* t 0.5))))) (export gridpool) (export crosspool) (export ppshow) (export void))
