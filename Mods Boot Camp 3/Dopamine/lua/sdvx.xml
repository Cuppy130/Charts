<ActorFrame><children>

	<Code
		InitCommand="%function(self)
		
			checked = false
		
			groove_bpm = 200
			
			groove_coaster = false
			
			beat_distance = 160
			
			if slumpo then
				beat_distance = 160
			end
		
			function t_linear(t)
				return linear(t,0,1,1)
			end
			function t_inQuad(t)
				return inQuad(t,0,1,1)
			end
			function t_outQuad(t)
				return outQuad(t,0,1,1)
			end
			function t_inOutQuad(t)
				return inOutQuad(t,0,1,1)
			end
			function t_outInQuad(t)
				return outInQuad(t,0,1,1)
			end
			function t_inQuart(t)
				return inQuart(t,0,1,1)
			end
			function t_outQuart(t)
				return outQuart(t,0,1,1)
			end
			function t_inOutQuart(t)
				return inOutQuart(t,0,1,1)
			end
			function t_outInQuart(t)
				return outInQuart(t,0,1,1)
			end
			function t_inSine(t)
				return inSine(t,0,1,1)
			end
			function t_outSine(t)
				return outSine(t,0,1,1)
			end
			function t_inOutSine(t)
				return inOutSine(t,0,1,1)
			end
			function t_outInSine(t)
				return outInSine(t,0,1,1)
			end
			
			groove_dirs = {90,0,180,-90}
			
			local m = mod_insert
			local m2 = mod_message
			local me = mod_ease
			
			
			local l = 'len'
			local e = 'end'
		
			function groove_fakestep(col)
				local beat = GAMESTATE:GetSongBeat()
				if checked and beat and beat > 4 then
					local a = Plr(2)
					if a and groove_coaster then
						a:FakeStep(col) --send a press anim message to player object
					end
				end
			end
			
			function groove_faketaphit(col,w,pn)
				local beat = GAMESTATE:GetSongBeat()
				if checked and beat and beat > 4 then
					local a = Plr(2)
					if a and groove_coaster then
						a:DidTapNote(col,w) --generate noteflash
					end
				end
			end
			
			function groove_fakeholdhit(col)
				local beat = GAMESTATE:GetSongBeat()
				if checked and beat and beat > 4 then
					local a = Plr(2)
					if a and groove_coaster then
						--a:DidHoldNote(col) --generate hold success flash
					end
				end
			end
		
			groove_camfollow = {true,true,true}
			
			function groove_registerpath( num )
				
				_G['groove_splines_'..num..'_x'] = {}
				_G['groove_splines_'..num..'_y'] = {}
				_G['groove_splines_'..num..'_z'] = {}
				_G['groove_splines_'..num..'_stealth1'] = {}
				_G['groove_splines_'..num..'_stealth2'] = {}
				
				for i=1,4 do
					table.insert( _G['groove_splines_'..num..'_x'], {{0,0}} )
					table.insert( _G['groove_splines_'..num..'_y'], {{0,0}} )
					table.insert( _G['groove_splines_'..num..'_z'], {{0,0}} )
					table.insert( _G['groove_splines_'..num..'_stealth1'], {{0,100}} )
					table.insert( _G['groove_splines_'..num..'_stealth2'], {{0,0}} )
				end
			
			end
			
			groove_res = beat_distance/4;
		
			function groove_splineRegion(path,begin,range)
				local backtrace = beat_distance
				local newpath = {}
				local gotone = false
				for i=1,table.getn(path) do
					if path[i][1] > begin-backtrace then
						if i > 1 and not gotone then
							table.insert(newpath,path[i-1])
							gotone = true
						end
						table.insert(newpath,path[i])
						if path[i][1] > begin+range then
							break;
						end
					end
				end
				return newpath
			end
			
			function groove_path( s, l, loc, tween, col, tab )
				
				if not tab then tab = 1 end
				
				local region = tab*2 - 1
				
				for i=1,4 do
				
					if not col or i == col+1 then
			
						local tx = _G['groove_splines_'..tab..'_x'][i]
						local ty = _G['groove_splines_'..tab..'_y'][i]
						local tz = _G['groove_splines_'..tab..'_z'][i]
						
						local cx = tx[table.getn(tx)]
						local cy = ty[table.getn(ty)]
						local cz = tz[table.getn(tz)]
						
						local crx = {cx[1],cx[2]}
						local cry = {cy[1],cy[2]}
						local crz = {cz[1],cz[2]}
						
						if loc[1] then
							if not tween or not tween[1] or tween[1] == linear then
								table.insert(tx,{crx[1]+l*beat_distance,crx[2]+loc[1]/2})
							else
								for i=0,l,groove_res/beat_distance do
									table.insert(tx,{crx[1]+i*beat_distance,tween[1](i,crx[2],loc[1]/2,l)})
								end
							end
						else
							table.insert(tx,{crx[1]+l*beat_distance,crx[2]})
						end
						
						if loc[2] then
							if not tween or not tween[2] or tween[2] == linear then
								table.insert(ty,{cry[1]+l*beat_distance,cry[2]+loc[2]/2})
							else
								for i=0,l,groove_res/beat_distance do
									table.insert(ty,{cry[1]+i*beat_distance,tween[2](i,cry[2],loc[2]/2,l)})
								end
							end
						else
							table.insert(ty,{cry[1]+l*beat_distance,cry[2]})
						end
						
						if loc[3] then
							if not tween or not tween[3] or tween[3] == linear then
								table.insert(tz,{crz[1]+l*beat_distance,crz[2]+loc[3]/2})
							else
								for i=0,l,groove_res/beat_distance do
									table.insert(tz,{crz[1]+i*beat_distance,tween[3](i,crz[2],loc[3]/2,l)})
								end
							end
						else
							table.insert(tz,{crz[1]+l*beat_distance,crz[2]})
						end
					
					end
				
				end
				
			end
			
			function groove_caf( beat, x,y,z )
				m2(beat, function()
					groove_camfollow = {x,y,z}
				end,true)
			end
		
			function groove_opposite(pn)
				if pn == 1 then return 2 end
				if pn == 2 then return 1 end
				return 0
			end
			
			
			groove_curtime = 0
			groove_lasttime = 0
		
			function groove_update(beat)
				
				groove_curtime = GAMESTATE:GetSongTime()
				local delta_time = groove_curtime - groove_lasttime
				
				groove_coaster = false
				
				for j=1,table.getn(groove_sections)-1,2 do
						
					local s = groove_sections[j]
					local e = groove_sections[j+1]
					
					local region = (math.floor((j-1)/2)+1)
					
					if beat > s and beat < e+1 then
					
						--Trace( 'in section '..region )
						
						groove_coaster = true
					
						local centered = 160*(beat-s)
						
						--Trace(groove_splineRegion(_G['groove_splines_'..region..'_x'][1],centered,1200)[1][1])
						
						--Trace(_G['groove_splines_'..region..'_x'][1][1][1])
						--Trace(table.getn(_G['groove_splines_'..1 ..'_x'][1]))
						--Trace(table.getn(_G['groove_splines_'..2 ..'_x'][1]))
						
						if beat < e then
							
							for i=0,3 do
						
								local spx = groove_splineRegion(_G['groove_splines_'..region..'_x'][i+1],centered,1200)
								local spy = groove_splineRegion(_G['groove_splines_'..region..'_y'][i+1],centered,1200)
								local spz = groove_splineRegion(_G['groove_splines_'..region..'_z'][i+1],centered,1200)
								
								local sps1 = groove_splineRegion(_G['groove_splines_'..region..'_stealth1'][i+1],centered,1200)
								local sps2 = groove_splineRegion(_G['groove_splines_'..region..'_stealth2'][i+1],centered,1200)
								
								--[[
								local splines = ''
								splines = splines..doSplineAll(100000,'x',spx)
								splines = splines..doSplineAll(100000,'y',spy)
								splines = splines..doSplineAll(100000,'z',spz)
								]]
								
								applySplineP(10000,'x',i,spx)
								applySplineP(10000,'y',i,spy)
								applySplineP(10000,'z',i,spz)
								
								applySpline(10000,'stealth',i,sps1,1)
								applySpline(10000,'stealth',i,sps2,2)
							
							end
							
							mod_do('*10000 '..(beat_distance/100)..'x, *10000 '..(centered)..' centered2, *10000 '..(-centered*1)..' movey');
							
							mod_do('*10000 '..(centered*16/40 + 100)..' suddenoffset,*10000 '..(centered*16/40 + -100)..' hiddenoffset,',1);
							mod_do('*10000 '..(centered*16/40 + 100)..' suddenoffset,*10000 '..(centered*16/40 + -100)..' hiddenoffset,',2);
							mod_do('*10000 '..(centered*16/40 + 100)..' suddenoffset,*10000 '..(centered*16/40 + -100)..' hiddenoffset,',3);
							
							
							--mod_do('*10000 2x');
						else
							--Trace('end spline')
							mod_do('*10000 no centered2, *10000 no movey,splinexreset,splineyreset,splinezreset, *-1 -100 hiddenoffset, *-1 100 suddenoffset');
						end
						
					
					end
						
					
				end
				
				groove_lasttime = groove_curtime
				
			end
		end"
	/>
	

		
	
	<INPUTGAME
		Type="Aux"
		Debug1MessageCommand="%function(self)
		end"
		
		
		StepP1LeftPressMessageCommand="%function (self)
			groove_fakestep(0)
		end"
		StepP1DownPressMessageCommand="%function (self)
			groove_fakestep(1)
		end"
		StepP1UpPressMessageCommand="%function (self)
			groove_fakestep(2)
		end"
		StepP1RightPressMessageCommand="%function (self)
			groove_fakestep(3)
		end"
		
		StepP2LeftPressMessageCommand="%function (self)
			groove_fakestep(0)
		end"
		StepP2DownPressMessageCommand="%function (self)
			groove_fakestep(1)
		end"
		StepP2UpPressMessageCommand="%function (self)
			groove_fakestep(2)
		end"
		StepP2RightPressMessageCommand="%function (self)
			groove_fakestep(3)
		end"
		
		Fk_P1_0_W1MessageCommand="%function(self) groove_faketaphit(0,1,1) end"
		Fk_P1_0_W2MessageCommand="%function(self) groove_faketaphit(0,2,1) end"
		Fk_P1_0_W3MessageCommand="%function(self) groove_faketaphit(0,3,1) end"
		Fk_P1_0_W4MessageCommand="%function(self) groove_faketaphit(0,4,1) end"
		Fk_P1_0_OKMessageCommand="%function(self) groove_fakeholdhit(0,1) end"
		Fk_P1_1_W1MessageCommand="%function(self) groove_faketaphit(1,1,1) end"
		Fk_P1_1_W2MessageCommand="%function(self) groove_faketaphit(1,2,1) end"
		Fk_P1_1_W3MessageCommand="%function(self) groove_faketaphit(1,3,1) end"
		Fk_P1_1_W4MessageCommand="%function(self) groove_faketaphit(1,4,1) end"
		Fk_P1_1_OKMessageCommand="%function(self) groove_fakeholdhit(1,1) end"
		Fk_P1_2_W1MessageCommand="%function(self) groove_faketaphit(2,1,1) end"
		Fk_P1_2_W2MessageCommand="%function(self) groove_faketaphit(2,2,1) end"
		Fk_P1_2_W3MessageCommand="%function(self) groove_faketaphit(2,3,1) end"
		Fk_P1_2_W4MessageCommand="%function(self) groove_faketaphit(2,4,1) end"
		Fk_P1_2_OKMessageCommand="%function(self) groove_fakeholdhit(2,1) end"
		Fk_P1_3_W1MessageCommand="%function(self) groove_faketaphit(3,1,1) end"
		Fk_P1_3_W2MessageCommand="%function(self) groove_faketaphit(3,2,1) end"
		Fk_P1_3_W3MessageCommand="%function(self) groove_faketaphit(3,3,1) end"
		Fk_P1_3_W4MessageCommand="%function(self) groove_faketaphit(3,4,1) end"
		Fk_P1_3_OKMessageCommand="%function(self) groove_fakeholdhit(3,1) end"
		
		Fk_P2_0_W1MessageCommand="%function(self) groove_faketaphit(0,1,2) end"
		Fk_P2_0_W2MessageCommand="%function(self) groove_faketaphit(0,2,2) end"
		Fk_P2_0_W3MessageCommand="%function(self) groove_faketaphit(0,3,2) end"
		Fk_P2_0_W4MessageCommand="%function(self) groove_faketaphit(0,4,2) end"
		Fk_P2_0_OKMessageCommand="%function(self) groove_fakeholdhit(0,2) end"
		Fk_P2_1_W1MessageCommand="%function(self) groove_faketaphit(1,1,2) end"
		Fk_P2_1_W2MessageCommand="%function(self) groove_faketaphit(1,2,2) end"
		Fk_P2_1_W3MessageCommand="%function(self) groove_faketaphit(1,3,2) end"
		Fk_P2_1_W4MessageCommand="%function(self) groove_faketaphit(1,4,2) end"
		Fk_P2_1_OKMessageCommand="%function(self) groove_fakeholdhit(1,2) end"
		Fk_P2_2_W1MessageCommand="%function(self) groove_faketaphit(2,1,2) end"
		Fk_P2_2_W2MessageCommand="%function(self) groove_faketaphit(2,2,2) end"
		Fk_P2_2_W3MessageCommand="%function(self) groove_faketaphit(2,3,2) end"
		Fk_P2_2_W4MessageCommand="%function(self) groove_faketaphit(2,4,2) end"
		Fk_P2_2_OKMessageCommand="%function(self) groove_fakeholdhit(2,2) end"
		Fk_P2_3_W1MessageCommand="%function(self) groove_faketaphit(3,1,2) end"
		Fk_P2_3_W2MessageCommand="%function(self) groove_faketaphit(3,2,2) end"
		Fk_P2_3_W3MessageCommand="%function(self) groove_faketaphit(3,3,2) end"
		Fk_P2_3_W4MessageCommand="%function(self) groove_faketaphit(3,4,2) end"
		Fk_P2_3_OKMessageCommand="%function(self) groove_fakeholdhit(3,2) end"
		
	/>
	
	

</children></ActorFrame>