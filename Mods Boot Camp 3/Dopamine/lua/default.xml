<ActorFrame
InitCommand="%function(self)

	if FUCK_EXE then

		slumpo = false
		for pn=1,2 do
			if GAMESTATE:IsPlayerEnabled(pn-1) then
				if GAMESTATE:GetCurrentSteps(pn-1):GetDifficulty() == 5 then
					slumpo = true
				end
			end
		end

		songName = GAMESTATE:GetCurrentSong():GetSongDir();
		
		mod_globaloffset = PREFSMAN:GetPreference('GlobalOffsetSeconds');
		
		sw = SCREEN_WIDTH
		sh = SCREEN_HEIGHT --shortcuts
		scx = sw/2
		scy = sh/2
		
		spb = 60/200
		
		function PrxA(pn)
			return _G['Proxy'..pn..'A']
		end
		
		function Plr(pn)
			return _G['P'..pn]
		end
		function GetJud(pn)
			return _G['jud'..pn]
		end
		function GetCom(pn)
			return _G['com'..pn]
		end
		
		function mod_do(str,pn)
			if pn then
				GAMESTATE:ApplyGameCommand('mod,'..str,pn)
			else
				GAMESTATE:ApplyGameCommand('mod,'..str)
			end
		end
		
		function taro_Sound(str)
			local met = GAMESTATE:GetCurrentSong():GetSongDir();
			SOUND:PlayOnce(met..'lua/'..str..'.ogg');
		end
		
	else
		
		SCREENMAN:SystemMessage('Requires NotITG ver. 3.1!')
		
	end
	
end"
><children>

	<Layer Type="ActorFrame" Condition="FUCK_EXE"><children>

		<Layer
			Type="Quad"
			InitCommand="hidden,1"
			OnCommand="sleep,1000"
		/>
		
		<Layer File="modhelpers.xml" />
		<Layer File="easing.xml" />
		<Layer File="sdvx.xml" />
		<Layer File="spellcard.xml" />
		
		<Layer Type="Quad"
			OnCommand="%function(self)
				if tonumber(GAMESTATE:GetVersionDate()) > 20180800 then
					self:tween(9999,'main_loop(%f)')
				end
			end"
		/>
		
		<Layer
			Type="Quad"
			OnCommand="hidden,1"
			InitCommand="%function(self)
			
				if tonumber(GAMESTATE:GetVersionDate()) > 20180800 then
			
					checked = false; P1=nil;P2=nil;P3=nil;P4=nil;jud1=nil;com1=nil;jud2=nil;com2=nil;jud3=nil;com3=nil;jud4=nil;com4=nil;
				
					---------------------------------------------------------
					---------DOCUMENTATION-----------------------------------
					---------------------------------------------------------
					
					--function perframe( beat, endBeat )
						--return true if the current beat is between 'beat' and 'endBeat'
					
					--function mod_shader(beat,key,which)
						--turn on shader key at specified beat (up to 10 keys available, defined by 'which' = 0-9
						
					--function mod_insert(beat,len,mod,len_or_end,pn)
						--insert mod into beat mods table
					--function mod_insert2(time,len,mod,len_or_end,pn)
						--insert mod into time mods table
						
					--function mod_message(beat,msg,persistent)
						--insert something into the actions table.
						--msg can also be a function. If string, a message gets broadcast at that beat
						--if 'persistent' is true, message will run even if editor starts at a beat past it
						
					--function mod_blacklist(t,n)
						--check if number n occurs in table t
						--useful for doing 'every beat EXCEPT the contents of t'
						
					--function simple_m0d(beat,strength,mult,mod)
					--function simple_m0d2(beat,strength,mult,mod,pn)
					--function simple_m0d3(beat,strength,duration,bpm,mod,pn)
						--activate mods at specific beat but also deactivate them
						
					--function mod_wiggle(beat,num,div,amt,speed,mod,pn,first)
						--alternates a mod back and forth before resetting to 0
						
					--function mod_springt(time,strength,dur,mod,pn)
						--time-based per-frame alternating mod that decreases based on how much time is left.
							--think doorstopper
					
					--function mod_springt2(time,strength,dur,mod,pn)
						--time-based per-frame alternating mod
					
					--function mod_onebeat(beat,strength,pn)
						--turns on beat for the beat specified, at the desired strength	
					
					--function switcheroo_add(beat,which,speed,len,pn)
						--adds a column swap at the desired beat
					--[[	switcheroos = {normal = {0,0}, ldur = {0,0}, reset = {0,0},
							flip = {100,0}, rudl = {100,0}, invert = {0,100}, dlru = {0,100},
							ludr = {25,-75}, rdul = {75,75}, drlu = {25,125}, ulrd = {75,-125}, urld = {100,-100}}
					]]
					
					--use a variable called 'switcheroo_width' to change how much space is between each column
					--e.g. switcheroo_width = 2 for ayakashi
					
					--function mod_sugarkiller(beat,duration,speed,minstealth,maxstealth,pn)
						--portable version of the effect from sugarkill X
						
					--function doSpline(spd, axis, path, col)
						--draws spline 'path' in specified axis, for specific col. Offsets are *10000, but positions use *spd
						
					--function doSplineAll(spd, axis, path)
						--same as above, but for all columns
						--(faster performance than using doSpline 4 times due to more efficient concat)
					
					--function mindf_rotateAndCounter(xDegrees, yDegrees, zDegrees, player)
						--counteract euler rotations after rotating player in multiple axes, using a TON of math.
					
					
					---------------------------------------------------------
					--------END DOCUMENTATION--------------------------------
					---------------------------------------------------------
					
					local m = mod_insert
					local m2 = mod_message
					local me = mod_ease
					
					
					local l = 'len'
					local e = 'end'
					
					local function d(pn)
						return (pn*2-3)
					end
					
					
					
					
					
					init_modsp1 = '';
					init_modsp2 = '';
					
					mod_plr = {};
					
					mod_firstSeenBeat = GAMESTATE:GetSongBeat(); --necessary to prevent long freezes
					
					
					
					
					
					
					
					
					
					
					
		---------------------------------------------------------------------------------------
		----------------------Begin tables 'n stuff--------------------------------------------
		---------------------------------------------------------------------------------------

					--beat based mods
					--{beat_start, beat_end, mods, len_or_end, player_number}
					mods = {
						{0,9999,'*1000 1.6x, *1000 no beat, *10000 -99999 cover','end'},
					}
					
					--switcheroos = {{0,0},{100,0},{0,100},{25,-75},{75,75},{25,125},{75,-125},{100,-100}}
					
					
					
					
					
					
					
					--time based mods
					mod_time = 0;
					--{time_start, time_end, mods, len_or_end, player_number}
					mods2 = {
						--{0,200.345,'3x','end',1},
					}
					
					
					
					
					--this is both a message broadcaster and a function runner
					--if you put {beat,'String'}, then 'String' is broadcast as a message on that beat
					--if you put {beat,function() somecode end}, then function() is run at that beat
					--see example on beat 32
					
					curaction = 1;
					--{beat,thing,persists}
					mod_actions = {
					
						{0,'GetProxy',true},
						
						{0.01,function()
						
							GAMESTATE:ForceSmoothLines(1);
						
							--GAMESTATE:UnloadSteps(2)
							
							local be = {}
							--be[35.25] = 7
							--Trace(be[35.25])
							
							local a = Plr(3)
							if a then
								
								local nd = a:GetNoteData()
								
								for i=table.getn(nd),1,-1 do
									if (nd[i][1] > 178 and nd[i][1] < 216) or (nd[i][1] >= 252 and nd[i][1] < 268) or (nd[i][1] >= 276 and nd[i][1] <= 292) or nd[i][1] >= 324 then
										--keep
									else
										table.remove(nd,i)
									end
								end
								
								local tab = {}
								
								for i=table.getn(nd),1,-1 do
									if nd[i][1] >= 324 and nd[i][1] <= 388 then
										
										if not tab[ nd[i][1] ] then
											tab[ nd[i][1] ] = {nd[i][2]}
										else
											table.insert( tab[ nd[i][1] ], nd[i][2] )
										end
										
										table.remove(nd,i)
										
									end
								end
								
								for k,v in pairs(tab) do
								
									for j=0,3 do
										local found = false
										for i=1,table.getn(v) do
											if v[i] == j then found = true end
										end
										if not found then
											if k == 388 then
												table.insert(nd, {k, j, 2, length = 12} )
											else
												table.insert(nd, {k, j, 1} )
											end
										end
									end
									
								end
								
								table.sort(nd,modtable_compare)
								
								a:SetNoteDataFromLua(nd)
								
							end
							
							for pn=1,3 do
								
								local a = Plr(pn)
								if a then
									a:NoClearSplines(true)
									a:GetChild('NoteField'):y(0);
								end
							
								local a = PrxA(pn)
								if a then
									a:hidden(1)
									
									local b = _G['jud'..pn]
									if b then
										b:hidden(1);
										b:basezoomx(1);
										b:basezoomy(1);
									end
									local c = _G['com'..pn]
									if c then
										c:hidden(1);
										c:basezoomx(1);
										c:basezoomy(1);
									end
									
								end
							end
							
							for pn=1,2 do
								local d = 0.2; if pn == 2 then d = 0.8 end
								
								local a = PrxA(pn)
								if a then
									a:hidden(0)
								end
								
								local b = _G['jud'..pn..'p']
								if b then
									b:hidden(0);
									b:basezoomx(.8);
									b:basezoomy(.8);
									b:x(SCREEN_WIDTH*d)
									b:y(SCREEN_HEIGHT*0.5)
									--Trace(tostring(b));
								end
								local c = _G['com'..pn..'p']
								if c then
									c:hidden(0);
									c:basezoomx(.8);
									c:basezoomy(.8);
									c:x(SCREEN_WIDTH*d)
									c:y(SCREEN_HEIGHT*0.5)
								end
								
							end
							
						end,true},
						
					}
					
					
					
					
					
					
					--beat-based ease mods
					--{time_start, time_end, mod_start, mod_end, mod, len_or_end, ease_type, player_number, sustaintime, optional_param1, optional_param2}
					--valid ease types are:
						--linear
						--inQuad    outQuad    inOutQuad    outInQuad
						--inCubic   outCubic   inOutCubic   outInCubic
						--inQuart   outQuart   inOutQuart   outInQuart
						--inQuint   outQuint   inOutQuint   outInQuint
						--inSine    outSine    inOutSine    outInSine
						--inExpo    outExpo    inOutExpo    outInExpo
						--inCirc    outCirc    inOutCirc    outInCirc
						--inElastic outElastic inOutElastic outInElastic    --can take 2 optional parameters - amplitude & period
						--inBack    outBack    inOutBack    outInBack       --can take 1 optional parameter  - spring amount
						--inBounce  outBounce  inOutBounce  outInBounce
						
					mods_ease = {
						-- EXAMPLE TWEEN: from beat 0 to 4, make rotationz go from 360 to 0 with the inOutBack tween
						--{0,4,360,0,'rotationz','end',inOutBack},
					}
					
					mod_perframes = {
						
					}
					
					function mpf(s,e,f)
						table.insert(mod_perframes,{s,e,f})
					end
					
					function vib(b,d,x,y,z,pn)
						if not pn then pn = 1 end
						local e = d
						if d < b then e = b+d end
						m2(b,function()
							local a = Plr(pn)
							if a then
								a:vibrate()
								a:effectmagnitude(x,y,z)
							end
						end)
						m2(e,function()
							local a = Plr(pn)
							if a then
								a:stopeffect()
							end
						end)
					end
					
					
					
					
					me(64,4,0,50,'flip',l,linear)
					
					m(0,999,'zbuffer, *1000 stealthpastreceptors',e)
					
					--
					m(68,132,'*4 50 flip, 100 drawsize, dizzyholds, -100 spiralholds, *1000 stealthpastreceptors, *1000 sudden, *1000 stealthtype, *1000 -100 hiddenoffset, *1000 100 suddenoffset, *1000 hidden','end',1)
					m(68,132,'*4 50 flip, 100 drawsize, dizzyholds, -100 spiralholds, *1000 stealthpastreceptors, *1000 sudden, *1000 stealthtype, *1000 -100 hiddenoffset, *1000 100 suddenoffset, *1000 hidden','end',2)
					--
					m(0,132,'*4 50 flip, *1000 stealth, *1000 dark, *100 100 arrowpathdrawsize, *1000 -100 drawsize, *1000 -100 drawsizeback',e,3)
					
					
					
					--sections that are running groove coaster (format: {start,end,start,end,...})
					groove_sections = {0,132,204,252,260,276}
					
					--create the required tables
					groove_registerpath(1)
					groove_registerpath(2)
					groove_registerpath(3)
					
					--car = cam rotation
					--caz = cam zoom
					--cat = cam transition
					--caf = cam follow
					
					--groove path = let's start travelling( start beat,len (beats),{x,y,z},{tweenx,y,z}, column )
					
					--intro
					--groove_active_player(0,2);
					--groove_path(68,900,{0,0,0},{linear,linear,linear});
					
					groove_path(0,36,{0,0,0},{nil,nil,nil})
					groove_path(36,28,{0,0,0},{nil,nil,nil})
					
					groove_path(64,4,{-120,0,0},{linear,nil,nil},0)
					groove_path(64,4,{-40,0,0},{linear,nil,nil},1)
					groove_path(64,4,{40,0,0},{linear,nil,nil},2)
					groove_path(64,4,{120,0,0},{linear,nil,nil},3)
					
					for i=68,83,2 do
					
						groove_path(0+i,.5,{-200,0,0},{outQuad,nil,nil},0)
						groove_path(0+i,.5,{-200,0,0},{outQuad,nil,nil},1)
						groove_path(.5+i,.5,{200,0,0},{inQuad,nil,nil},0)
						groove_path(.5+i,.5,{200,0,0},{inQuad,nil,nil},1)
					
						groove_path(0+i,1,{0,0,0},{linear,nil,nil},2)
						groove_path(0+i,1,{0,0,0},{linear,nil,nil},3)
						
						groove_path(1+i,1,{0,0,0},{linear,nil,nil},0)
						groove_path(1+i,1,{0,0,0},{linear,nil,nil},1)
						
						groove_path(1+i,.5,{200,0,0},{outQuad,nil,nil},2)
						groove_path(1+i,.5,{200,0,0},{outQuad,nil,nil},3)
						groove_path(1.5+i,.5,{-200,0,0},{inQuad,nil,nil},2)
						groove_path(1.5+i,.5,{-200,0,0},{inQuad,nil,nil},3)
						
					end
					
					local push = 1
					local cpush = 0
					
					for i=84,83+16,2 do
					
						groove_path(0+i,.5,{-200+50*push,0,0},{outQuad,nil,nil},0)
						groove_path(0+i,.5,{-200+50*push,0,0},{outQuad,nil,nil},1)
						groove_path(.5+i,.5,{200+50*push,0,0},{inQuad,nil,nil},0)
						groove_path(.5+i,.5,{200+50*push,0,0},{inQuad,nil,nil},1)
					
						groove_path(0+i,1,{100*push,0,0},{linear,nil,nil},2)
						groove_path(0+i,1,{100*push,0,0},{linear,nil,nil},3)
						
						groove_path(1+i,1,{100*push,0,0},{linear,nil,nil},0)
						groove_path(1+i,1,{100*push,0,0},{linear,nil,nil},1)
						
						groove_path(1+i,.5,{200+50*push,0,0},{outQuad,nil,nil},2)
						groove_path(1+i,.5,{200+50*push,0,0},{outQuad,nil,nil},3)
						groove_path(1.5+i,.5,{-200+50*push,0,0},{inQuad,nil,nil},2)
						groove_path(1.5+i,.5,{-200+50*push,0,0},{inQuad,nil,nil},3)
						
						cpush = cpush+push
						
						if cpush >= 2 and push == 1 then
							push = -1
						end
						if cpush <= -2 and push == -1 then
							push = 1
						end
						
					end
					
					local moving = 0
					
					for i=100,131,2 do
						
						local stopped = false
						local onion = false
						if math.mod(i-100,4) == 2 then
							stopped = true
						end
						if math.mod(i-100,16) == 14 then
							onion = true
						end
					
						groove_path(0+i,.5,{320*push,0,0},{linear,nil,nil},math.mod(moving,4))
						groove_path(0+i,.5,{320*push,0,0},{linear,nil,nil},math.mod(moving+1,4))
						groove_path(.5+i,.5,{0,0,0},{linear,nil,nil},math.mod(moving,4))
						groove_path(.5+i,.5,{0,0,0},{linear,nil,nil},math.mod(moving+1,4))
						
						groove_path(0+i,1,{0,0,0},{linear,nil,nil},math.mod(moving+2,4))
						groove_path(0+i,1,{0,0,0},{linear,nil,nil},math.mod(moving+3,4))
						
						if not stopped then
						
							groove_path(1+i,1,{0,0,0},{linear,nil,nil},math.mod(moving,4))
							groove_path(1+i,1,{0,0,0},{linear,nil,nil},math.mod(moving+1,4))
						
							groove_path(1+i,.5,{320*push,0,0},{linear,nil,nil},math.mod(moving+2,4))
							groove_path(1+i,.5,{320*push,0,0},{linear,nil,nil},math.mod(moving+3,4))
							groove_path(1.5+i,.5,{0,0,0},{linear,nil,nil},math.mod(moving+2,4))
							groove_path(1.5+i,.5,{0,0,0},{linear,nil,nil},math.mod(moving+3,4))
							
						else
							if not onion then
								local fl = 1
								for j=0,3 do
									groove_path(1+i+j*.25,.25,{-160*fl,0,0},{linear,nil,nil},math.mod(moving,4))
									groove_path(1+i+j*.25,.25,{-160*fl,0,0},{linear,nil,nil},math.mod(moving+1,4))
								
									groove_path(1+i+j*.25,.25,{160*fl,0,0},{linear,nil,nil},math.mod(moving+2,4))
									groove_path(1+i+j*.25,.25,{160*fl,0,0},{linear,nil,nil},math.mod(moving+3,4))
									fl = fl*-1
								end
							else
								
								groove_path(1+i,.5,{-200*1,0,0},{outQuad,nil,nil},0)
								groove_path(1+i,.5,{-200*1,0,0},{outQuad,nil,nil},1)
								groove_path(1.5+i,.5,{200*1,0,0},{inQuad,nil,nil},0)
								groove_path(1.5+i,.5,{200*1,0,0},{inQuad,nil,nil},1)
								
								groove_path(1+i,.5,{200*1,0,0},{outQuad,nil,nil},2)
								groove_path(1+i,.5,{200*1,0,0},{outQuad,nil,nil},3)
								groove_path(1.5+i,.5,{-200*1,0,0},{inQuad,nil,nil},2)
								groove_path(1.5+i,.5,{-200*1,0,0},{inQuad,nil,nil},3)
								
							end
						end
						
						if stopped then
							--moving = moving+2
						end
						
						cpush = cpush+push
						
						if cpush >= 2 and push == 1 then
							push = -1
						end
						if cpush <= -2 and push == -1 then
							push = 1
						end
						
					end
					
					
					me(36,64,0,150,'mini',e,linear)
					me(64,4,150,0,'mini',l,linear)
					me(35.5,63.5,100,250,'beat',e,linear)
					
					m(34,64,'wave',e)
					
					me(36,64,0,100,'tornado',e,linear,nil,64)
					me(65,44,100,0,'tornado',e,outQuad)
					
					
					me(64,68,0,100,'arrowpath',e,linear,3,132)
					
					m2(64,function()
						for pn=1,3 do
							local a = Plr(pn)
							if a then
								a:SetAwake(true)
								a:fov(60)
								a:SetFarDist(10000)
								a:linear(4*60/200)
								a:x(sw/2)
								
								a:GetChild('NoteField'):y(0);
								
							end
							
							local a = PrxA(pn)
							if a then
								a:hidden(0)
							end
							
							
							local a = Plr(pn)
							if a and pn == 3 then -- if they exist do a thing
								a:SetArrowPathBlendMode( 'add' );
								
							end
							
							
						end
					end)
					
					m2(68,function()
						for pn=1,3 do
							local a = Plr(pn)
							if a then
								a:SetAwake(true)
								a:fov(60)
								a:SetFarDist(10000)
								
								a:x(sw/2)
								a:GetChild('NoteField'):y(0);
							end
							
							local a = PrxA(pn)
							if a then
								a:hidden(0)
							end
							
							
							local a = Plr(pn)
							if a and pn == 3 then -- if they exist do a thing
								a:SetArrowPathBlendMode( 'add' );
								
							end
							
							
						end
					end,true)
					
					m(132,176,'*10000 reversetype',e)
					
					me(132,4,100,0,'arrowpath',l,linear,3)
					
					me(132,4,20,0,'flip',l,outElastic)
					
					for pn=1,2 do
						me(132,136,0,250*d(pn),'invert',e,outElastic,pn,148)
					end
					
					m2(132,function()
						
						for pn=1,2 do
							
							local a = Plr(pn)
							if a then
								--a:decelerate(spb*4)
								--a:x(scx + 160*d(pn))
							end
							
						end
						
					end)
					
					me(132,4.5,0,4,'xmod',l,outQuad,nil)
					me(136.5,3.5,3.5,1.6,'xmod',l,outExpo,nil)
					
					m(132,136,'*10000 dark',e)
					m2(136,function()
						
						local a = PrxA(3)
						if a then a:hidden(1) end
						
					end,true)
					
					me(136.5,2,0,100,'reverse',l,outExpo)
					m(138.5,148,'*-1 100 reverse',e)
					
					me(140,148,100,300,'reverse',e,linear)
					me(140,148,0,500,'movey',e,linear)
					me(146,2,0,100,'stealth',l,linear)
					me(148,2,100,0,'stealth',l,linear)
					me(140,8,0,100,'drunk',l,linear)
					me(148,2,-50,0,'drunk',l,outQuad)
					
					me(148,2,-50,0,'reverse',l,outQuad)
					me(148,2,0,0,'movey',l,outQuad)
					
					for pn=1,2 do
						m(148,172,'*-1 '..(250*d(pn) + 50)..' invert',e,pn)
						me(172,173,(250*d(pn) + 50),250*d(pn),'invert',e,linear,pn)
						me(173,3,250*d(pn),0,'invert',l,inCubic,pn)
					end
					
					local function vib(b,d,x,y,z,p)
						local e = d
						if d < b then e = b+d end
						m2(b,function()
							for pn=1,2 do
								if (not p or pn == p) and Plr(pn) then
									Plr(pn):vibrate()
									Plr(pn):effectmagnitude(x,y,z)
								end
							end
						end)
						m2(e,function()
							for pn=1,2 do
								if (not p or pn == p) and Plr(pn) then
									Plr(pn):stopeffect()
								end
							end
						end)
					end
					
					dop_dir = 1
					
					local f = 1
					for i=0,2 do
						vib(148+8*i,1.25,10,20,0)
						
						m2(148+8*i,function()
						
							for pn=1,2 do
								local a = Plr(pn)
								if a then
									a:linear(spb*1.25)
									a:skewx(.25*(pn*2-3)*dop_dir)
								end
							end
							
							dop_dir = dop_dir*-1
							
						end)
						
						for pn=1,2 do
							if i==0 then
								me(148+8*i,1.25,0,-25*f*(pn*2-3),'noteskew',l,linear,pn,6.8)
							elseif i==3 then
								me(148+8*i,1.25,25*f*(pn*2-3),0,'noteskew',l,linear,pn)
							else
								me(148+8*i,1.25,25*f*(pn*2-3),-25*f*(pn*2-3),'noteskew',l,linear,pn,6.8)
							end
						end
						
						f = f*-1
						
					end
					
					vib(148+8*3,1.25,10,20,0)
					
					for pn=1,2 do
						me(148+8*3,1.25,-25*(pn*2-3),0,'noteskew',l,linear,pn)
					end
					
					m2(148+8*3,function()
						
						for pn=1,2 do
							local a = Plr(pn)
							if a then
								a:linear(spb*1.25)
								a:skewx(0)
							end
						end
					end)
					
					-------------------------------------
					--hehe
					
					m2(176,function()
						
						for pn=1,3 do
							local a = Plr(pn)
							if a then
								a:x(sw/2)
								a:y(sh/2)
							end
							local a = PrxA(pn)
							if a then
								a:hidden(0)
							end
						end
						
					end,true)
					
					m(0,999,'dizzyholds',e)
					
					me(176,180,0,60,'mini',e,outQuad,nil,210)
					me(210,2,60,0,'mini',l,linear)
					me(176,180,100,60,'suddenoffset',e,outQuad,nil,210)
					m(176,210,'sudden',e)
					
					me(176,180,0,100,'flip',e,outQuad,1,210)
					me(210,2,100,50,'flip',l,linear,1)
					me(176,180,0,100*math.pi,'confusionoffset',e,outQuad,1,210)
					me(210,2,100*math.pi,0,'confusionoffset',l,linear,1)
					
					me(176,180,0,125,'invert',e,outQuad,2,210)
					me(210,2,125,0,'invert',l,linear,2)
					me(176,180,0,25,'flip',e,outQuad,2,210)
					me(210,2,25,50,'flip',l,linear,2)
					me(176,180,0,50*math.pi,'confusionoffset',e,outQuad,2,210)
					me(210,2,50*math.pi,0,'confusionoffset',l,linear,2)
					
					me(210,2,0,50,'flip',l,linear,3)
					
					simple_m0d2(176,50,1,'stealth')
					
					if not slumpo then
						for i=180,210,2 do
							simple_m0d2(i,30,.3,'stealth')
						end
					end
					
					mpf(176.01,212,function(beat)
					
						local rgb = 1
						
						local pos = 0
						
						local imult = 0
						if beat < 180 then
							imult = outQuad(beat-176,0,1,4)
						elseif beat < 210 then
							imult = 1
						else
							imult = 1-linear(beat-210,0,1,2)
						end
						
						if beat > 180 then
							pos = (beat-180)*math.pi*0.125
						end
						
						local xrad = 200*imult
						local yrad = 80*imult
						local yadd = 40*imult
						
						for pn=1,3 do
						
							local ppos = pos + math.mod(pn,3)*(math.pi*2)/3
							
							local a = Plr(pn)
							if a then
								a:x( sw/2 + xrad*math.sin(ppos) )
								a:y( sh/2 + yadd + yrad*math.sin(2*ppos) )
							end
							
							if pn==3 then
								mod_do('*10000 100 stealthgg, *10000 '..(100-100*rgb)..' stealthgr, *10000 '..(100-100*rgb)..' stealthgb',pn)
							else
								mod_do('*10000 100 stealthgr, *10000 '..(100-100*rgb)..' stealthgg, *10000 '..(100-100*rgb)..' stealthgb',pn)
							end
							
						end
						
					end)
					
					m2(212.01,function()
						
						for pn=1,3 do
							local a = Plr(pn)
							if a then
							a:x(sw/2)
							a:y(sh/2)
							a:GetChild('NoteField'):y(0)
							end
							local a = PrxA(pn)
							if a then
							a:x(0)
							a:y(0)
							end
						end
						
					end,true)
					
					m(176,1,'*10000 no centered2, *10000 no movey, *10000 no dark',l,3)
					
					m2(180,'WhiteFlashQ')
					
					me(210,212,0,100,'arrowpath',e,linear,3,252)
					
					m(212,252,'*1000 50 flip',e)
					m(252,1,'*1000 no arrowpath, *1000 no flip',l,1)
					m(252,1,'*1000 no arrowpath, *1000 no flip',l,2)
					m(252,1,'*1000 no arrowpath, *1000 no flip',l,3)
					
					--groove_path(68,900,{0,0,0},{linear,linear,linear});
					
					groove_path(204,6,{0,0,0},{nil,nil,nil},nil,2)
					
					groove_path(210,2,{-120,0,0},{linear,nil,nil},0,2)
					groove_path(210,2,{-40,0,0},{linear,nil,nil},1,2)
					groove_path(210,2,{40,0,0},{linear,nil,nil},2,2)
					groove_path(210,2,{120,0,0},{linear,nil,nil},3,2)
					
					--groove_path(212,8,{0,0,0},{nil,nil,nil},nil,2)
					
					local push = 1
					local p2 = 1
					local pc = 0
					
					if slumpo then
						for i=0,7 do
							groove_path(0+0+220+i,.5,{-200*push,0,0},{linear,nil,nil},0,2)
							groove_path(0+0+220+i,.5,{-200*push,0,0},{linear,nil,nil},1,2)
							groove_path(0+.5+220+i,.5,{200*push,0,0},{linear,nil,nil},0,2)
							groove_path(0+.5+220+i,.5,{200*push,0,0},{linear,nil,nil},1,2)
							
							groove_path(0+0+220+i,.5,{200*push,0,0},{linear,nil,nil},2,2)
							groove_path(0+0+220+i,.5,{200*push,0,0},{linear,nil,nil},3,2)
							groove_path(0+.5+220+i,.5,{-200*push,0,0},{linear,nil,nil},2,2)
							groove_path(0+.5+220+i,.5,{-200*push,0,0},{linear,nil,nil},3,2)
							
							pc = pc+1
							
							if pc == 2 then
								pc = 0
								if push == 1 then
									push = -1.8
								else
									push = 1
								end
							end
						end
					else
						for i=0,7 do
							groove_path(0+0+220+i,.5,{-200+100*push*p2,0,0},{outQuad,nil,nil},0,2)
							groove_path(0+0+220+i,.5,{-200+100*push*p2,0,0},{outQuad,nil,nil},1,2)
							groove_path(0+.5+220+i,.5,{200+100*push*p2,0,0},{linear,nil,nil},0,2)
							groove_path(0+.5+220+i,.5,{200+100*push*p2,0,0},{linear,nil,nil},1,2)
							
							groove_path(0+0+220+i,.5,{200+100*push*p2,0,0},{outQuad,nil,nil},2,2)
							groove_path(0+0+220+i,.5,{200+100*push*p2,0,0},{outQuad,nil,nil},3,2)
							groove_path(0+.5+220+i,.5,{-200+100*push*p2,0,0},{linear,nil,nil},2,2)
							groove_path(0+.5+220+i,.5,{-200+100*push*p2,0,0},{linear,nil,nil},3,2)
							
							pc = pc+1
							
							p2 = p2*-1
							
							if pc == 2 then
								pc = 0
								if push == 1 then
									push = -1
								else
									push = 1
								end
							end
							
						end
					end
					
					
					
					
					groove_path(0+0+220,1,{400,0,0},{linear,nil,nil},0,2)
					groove_path(0+0+220,1,{400,0,0},{linear,nil,nil},1,2)
					groove_path(0+1+220,1,{-400,0,0},{linear,nil,nil},0,2)
					groove_path(0+1+220,1,{-400,0,0},{linear,nil,nil},1,2)
					groove_path(0+2+220,1,{400,0,0},{linear,nil,nil},0,2)
					groove_path(0+2+220,1,{400,0,0},{linear,nil,nil},1,2)
					groove_path(0+3+220,1,{-400,0,0},{linear,nil,nil},0,2)
					groove_path(0+3+220,1,{-400,0,0},{linear,nil,nil},1,2)
					
					groove_path(0+0+220,1,{0,0,0},{linear,nil,nil},2,2)
					groove_path(0+0+220,1,{0,0,0},{linear,nil,nil},3,2)
					groove_path(0+1+220,1,{400,0,0},{linear,nil,nil},2,2)
					groove_path(0+1+220,1,{400,0,0},{linear,nil,nil},3,2)
					groove_path(0+2+220,1,{-400,0,0},{linear,nil,nil},2,2)
					groove_path(0+2+220,1,{-400,0,0},{linear,nil,nil},3,2)
					groove_path(0+3+220,1,{0,0,0},{linear,nil,nil},2,2)
					groove_path(0+3+220,1,{0,0,0},{linear,nil,nil},3,2)
					
					groove_path(0+0+224,1,{-400,0,0},{outQuad,nil,nil},0,2)
					groove_path(0+0+224,1,{-400,0,0},{outQuad,nil,nil},1,2)
					groove_path(0+1+224,1,{400,0,0},{inQuad,nil,nil},0,2)
					groove_path(0+1+224,1,{400,0,0},{inQuad,nil,nil},1,2)
					groove_path(0+2+224,1,{-400,0,0},{outQuad,nil,nil},0,2)
					groove_path(0+2+224,1,{-400,0,0},{outQuad,nil,nil},1,2)
					groove_path(0+3+224,1,{400,0,0},{inQuad,nil,nil},0,2)
					groove_path(0+3+224,1,{400,0,0},{inQuad,nil,nil},1,2)
					
					groove_path(0+0+224,1,{0,0,0},{linear,nil,nil},2,2)
					groove_path(0+0+224,1,{0,0,0},{linear,nil,nil},3,2)
					groove_path(0+1+224,1,{-560,0,0},{outQuad,nil,nil},2,2)
					groove_path(0+1+224,1,{-560,0,0},{outQuad,nil,nil},3,2)
					groove_path(0+2+224,1,{560,0,0},{inQuad,nil,nil},2,2)
					groove_path(0+2+224,1,{560,0,0},{inQuad,nil,nil},3,2)
					groove_path(0+3+224,1,{0,0,0},{linear,nil,nil},2,2)
					groove_path(0+3+224,1,{0,0,0},{linear,nil,nil},3,2)
					
					
					local push = -1
					local p2 = 1
					local pc = 0
					
					if slumpo then
						push = -1.8
						for i=0,3 do
							groove_path(0+0+228+i,.5,{-200*push,0,0},{linear,nil,nil},0,2)
							groove_path(0+0+228+i,.5,{-200*push,0,0},{linear,nil,nil},1,2)
							groove_path(0+.5+228+i,.5,{200*push,0,0},{linear,nil,nil},0,2)
							groove_path(0+.5+228+i,.5,{200*push,0,0},{linear,nil,nil},1,2)
							
							groove_path(0+0+228+i,.5,{200*push,0,0},{linear,nil,nil},2,2)
							groove_path(0+0+228+i,.5,{200*push,0,0},{linear,nil,nil},3,2)
							groove_path(0+.5+228+i,.5,{-200*push,0,0},{linear,nil,nil},2,2)
							groove_path(0+.5+228+i,.5,{-200*push,0,0},{linear,nil,nil},3,2)
							
							pc = pc+1
							
							if pc == 2 then
								pc = 0
								if push == 1 then
									push = -1.8
								else
									push = 1
								end
							end
						end
					else
						for i=0,3 do
							groove_path(0+0+228+i,.5,{-200+100*push*p2,0,0},{linear,nil,nil},0,2)
							groove_path(0+0+228+i,.5,{-200+100*push*p2,0,0},{linear,nil,nil},1,2)
							groove_path(0+.5+228+i,.5,{200+100*push*p2,0,0},{linear,nil,nil},0,2)
							groove_path(0+.5+228+i,.5,{200+100*push*p2,0,0},{linear,nil,nil},1,2)
							
							groove_path(0+0+228+i,.5,{200+100*push*p2,0,0},{linear,nil,nil},2,2)
							groove_path(0+0+228+i,.5,{200+100*push*p2,0,0},{linear,nil,nil},3,2)
							groove_path(0+.5+228+i,.5,{-200+100*push*p2,0,0},{linear,nil,nil},2,2)
							groove_path(0+.5+228+i,.5,{-200+100*push*p2,0,0},{linear,nil,nil},3,2)
							
							pc = pc+1
							
							p2 = p2*-1
							
							if pc == 2 then
								pc = 0
								if push == 1 then
									push = -1
								else
									push = 1
								end
							end
							
						end
					end
					
					local pu = 1
					if slumpo then pu = -1 end
					
					groove_path(232,1,{-400*pu,0,0},{linear,nil,nil},0,2)
					groove_path(232,1,{-400*pu,0,0},{linear,nil,nil},1,2)
					groove_path(232,1,{400*pu,0,0},{linear,nil,nil},2,2)
					groove_path(232,1,{400*pu,0,0},{linear,nil,nil},3,2)
					
					local f = 1
					for i=0,3 do
						groove_path(233+i*.25,.25,{160*f,0,0},{linear,nil,nil},0,2)
						groove_path(233+i*.25,.25,{160*f,0,0},{linear,nil,nil},1,2)
						groove_path(233+i*.25,.25,{-160*f,0,0},{linear,nil,nil},2,2)
						groove_path(233+i*.25,.25,{-160*f,0,0},{linear,nil,nil},3,2)
						f= f*-1
					end
					
					groove_path(234,1,{400*pu,0,0},{linear,nil,nil},0,2)
					groove_path(234,1,{400*pu,0,0},{linear,nil,nil},1,2)
					groove_path(234,1,{-400*pu,0,0},{linear,nil,nil},2,2)
					groove_path(234,1,{-400*pu,0,0},{linear,nil,nil},3,2)
					
					local f = -1
					for i=0,3 do
						groove_path(235+i*.25,.25,{160*f,0,0},{linear,nil,nil},0,2)
						groove_path(235+i*.25,.25,{160*f,0,0},{linear,nil,nil},1,2)
						groove_path(235+i*.25,.25,{-160*f,0,0},{linear,nil,nil},2,2)
						groove_path(235+i*.25,.25,{-160*f,0,0},{linear,nil,nil},3,2)
						f= f*-1
					end
					
					groove_path(236.0,.5,{-200,0,0},{outQuad,nil,nil},nil,2)
					groove_path(236.5,.5,{200,0,0},{inQuad,nil,nil},nil,2)
					groove_path(237.0,.5,{200,0,0},{outQuad,nil,nil},nil,2)
					groove_path(237.5,.5,{-200,0,0},{inQuad,nil,nil},nil,2)
					
					groove_path(238.0,1,{320,0,0},{linear,nil,nil},2,2)
					groove_path(238.0,1,{320,0,0},{linear,nil,nil},3,2)
					groove_path(239.0,1,{0,0,0},{linear,nil,nil},2,2)
					groove_path(239.0,1,{0,0,0},{linear,nil,nil},3,2)
					
					groove_path(238.0,1,{0,0,0},{linear,nil,nil},0,2)
					groove_path(238.0,1,{0,0,0},{linear,nil,nil},1,2)
					groove_path(239.0,1,{320,0,0},{linear,nil,nil},0,2)
					groove_path(239.0,1,{320,0,0},{linear,nil,nil},1,2)
					
					groove_path(240.0,1,{-320,0,0},{linear,nil,nil},2,2)
					groove_path(240.0,1,{-320,0,0},{linear,nil,nil},3,2)
					groove_path(241.0,1,{0,0,0},{linear,nil,nil},2,2)
					groove_path(241.0,1,{0,0,0},{linear,nil,nil},3,2)
					
					groove_path(240.0,1,{0,0,0},{linear,nil,nil},0,2)
					groove_path(240.0,1,{0,0,0},{linear,nil,nil},1,2)
					groove_path(241.0,1,{-320,0,0},{linear,nil,nil},0,2)
					groove_path(241.0,1,{-320,0,0},{linear,nil,nil},1,2)
					
					
					for i=0,1 do
						groove_path(0+0+242+i,.5,{-200+0,0,0},{linear,nil,nil},0,2)
						groove_path(0+0+242+i,.5,{-200+0,0,0},{linear,nil,nil},1,2)
						groove_path(0+.5+242+i,.5,{200+0,0,0},{linear,nil,nil},0,2)
						groove_path(0+.5+242+i,.5,{200+0,0,0},{linear,nil,nil},1,2)
						
						groove_path(0+0+242+i,.5,{200+0,0,0},{linear,nil,nil},2,2)
						groove_path(0+0+242+i,.5,{200+0,0,0},{linear,nil,nil},3,2)
						groove_path(0+.5+242+i,.5,{-200+0,0,0},{linear,nil,nil},2,2)
						groove_path(0+.5+242+i,.5,{-200+0,0,0},{linear,nil,nil},3,2)
						
					end
					
					groove_path(244,2,{-600+0,0,0},{outQuad,nil,nil},nil,2)
					groove_path(246,2,{600+0,0,0},{inQuad,nil,nil},nil,2)
					groove_path(248,2,{600+0,0,0},{outQuad,nil,nil},nil,2)
					groove_path(250,2,{-600+0,0,0},{inQuad,nil,nil},nil,2)
					
					groove_path(252,8,{0,0,0},{inQuad,nil,nil},nil,2)
					
					m2(252,'WhiteFlashQ')
					
					m2(252,function()
						
						for pn=1,3 do
							local a = Plr(pn)
							if a then
							a:x(sw/2)
							a:y(sh/2)
							end
						end
						
					end,true)
					
					simple_m0d(252,50,2,'stealth')
					
					m(252,264,'*10000 60 mini',e)
					me(264,4,60,0,'mini',l,linear)
					
					me(264,268,0,100,'arrowpath',e,linear,3,276)
					
					if not slumpo then
						for i=256,267,4 do
							simple_m0d(i,50,.5,'stealth')
						end
					end
					
					mpf(252.01,268,function(beat)
						
						local rgb = 0
					
						if beat >= 252 and beat < 256 then
							rgb = 1-.5*linear(beat-252,0,1,4)
						elseif beat >= 256 then
							rgb = .5
						end
						
						local pos = 0
						
						local imult = 1
						
						if beat > 264 then
							imult = 1-linear(beat-264,0,1,4)
						end
						
						if beat > 252 then
							pos = (beat-252)*math.pi*0.125
						end
						
						local xrad = 200*imult
						local yrad = 80*imult
						local yadd = 40*imult
						
						for pn=1,5 do
						
							local ppos = pos + math.mod(pn+2,5)*(math.pi*2)/5
							
							local a = PrxA(pn)
							if a then
								a:hidden(0)
								a:x( 0 + xrad*math.sin(ppos) )
								a:y( 0 + yadd + yrad*math.sin(2*ppos) )
							end
							
							if pn < 4 then
								if pn==3 then
									mod_do('*10000 100 stealthgg, *10000 '..(100-100*rgb)..' stealthgr, *10000 '..(100-100*rgb)..' stealthgb',pn)
								else
									mod_do('*10000 100 stealthgr, *10000 '..(100-100*rgb)..' stealthgg, *10000 '..(100-100*rgb)..' stealthgb',pn)
								end
							end
							
						end
						
					end)
					
					me(252,252,100,60,'suddenoffset',e,outQuad,nil,264)
					m(252,264,'*1000 sudden',e)
					
					me(252,252,0,100,'flip',e,outQuad,1,264)
					me(264,4,100,50,'flip',l,linear,1)
					me(252,252,0,100*math.pi,'confusionoffset',e,outQuad,1,264)
					me(264,4,100*math.pi,0,'confusionoffset',l,linear,1)
					
					me(252,252,0,125,'invert',e,outQuad,2,264)
					me(264,4,125,0,'invert',l,linear,2)
					me(252,252,0,25,'flip',e,outQuad,2,264)
					me(264,4,25,50,'flip',l,linear,2)
					me(252,252,0,50*math.pi,'confusionoffset',e,outQuad,2,264)
					me(264,4,50*math.pi,0,'confusionoffset',l,linear,2)
					
					m(264.5-.1,.5,'*20 200 drunk',l)
					m(264.75-.1,.5,'*40 -200 drunk',l)
					m(265-.1,.5,'*40 200 drunk',l)
					m(265.5-.1,.5,'*20 no drunk',l)
					
					mod_wiggle(266.5-.1,4,4,100,3,'tipsy')
					
					me(264,268,0,50,'flip',e,linear,3,276)
					m(268,276,'*1000 50 flip',e,nil)
					m(276,1,'*1000 no flip',l,nil)
					
					m2(268,function()
						
						for pn=1,5 do
							
							local a = PrxA(pn)
							if a then
								a:xy(0,0)
								if pn>3 then a:hidden(1) end
							end
							
						end
						
					end)
					
					m(268,8,'*10000 stealth',l,3)
					m(276,1,'*10000 no stealth',l,3)
					
					m(267.5,8,'*1000 1000 beatz',l,1)
					m(267.5,8,'*1000 1000 beatz',l,2)
					m(276,8,'*1000 no beatz',l)
					
					
					groove_path(260,4,{0,0,0},{nil,nil,nil},nil,3)
					
					groove_path(264,4,{-240,0,0},{linear,nil,nil},0,3)
					groove_path(264,4,{-80,0,0},{linear,nil,nil},1,3)
					groove_path(264,4,{80,0,0},{linear,nil,nil},2,3)
					groove_path(264,4,{240,0,0},{linear,nil,nil},3,3)
					
					for i=0,3 do
						
						groove_path(268+2*i,1,{-160,0,0},{linear,nil,nil},0,3)
						groove_path(268+2*i,1,{-160,0,0},{linear,nil,nil},1,3)
						groove_path(268+2*i,1,{0,0,0},{linear,nil,nil},2,3)
						groove_path(268+2*i,1,{0,0,0},{linear,nil,nil},3,3)
						
						groove_path(269+2*i,1,{0,0,0},{linear,nil,nil},0,3)
						groove_path(269+2*i,1,{0,0,0},{linear,nil,nil},1,3)
						groove_path(269+2*i,1,{160,0,0},{linear,nil,nil},2,3)
						groove_path(269+2*i,1,{160,0,0},{linear,nil,nil},3,3)
						
					end
					
					groove_path(276,16,{0,0,0},{linear,nil,nil},nil,3)
					
					
					
					
					
					m2(276,'WhiteFlashQ')
					
					m2(276,function()
						
						for pn=1,3 do
							local a = Plr(pn)
								if a then
								a:x(sw/2)
								a:y(sh/2)
							end
						end
						
					end,true)
					
					simple_m0d(276,50,2,'stealth')
					
					m(276,290,'*10000 60 mini',e)
					me(290,2,60,0,'mini',l,linear)
					
					m(276,1,'*1000 no arrowpath',l,3)
					me(290,292,0,100,'arrowpath',e,linear,3,276)
					
					mpf(276.01,292,function(beat)
					
						local rgb = 0
						
						if slumpo then
							if beat >= 276 and beat < 284 then
								rgb = 1-linear(beat-276,0,1,8)
							end
						else
							if beat >= 276 and beat < 278 then
								rgb = 1-linear(beat-276,0,1,2)
							end
						end
						
						local pos = 0
						
						local imult = 1
						
						if beat > 290 then
							imult = 1-linear(beat-290,0,1,2)
						end
						
						if beat > 276 then
							pos = (beat-276)*math.pi*0.125
						end
						
						local xrad = 200*imult
						local yrad = 80*imult
						local yadd = 40*imult
						
						for pn=1,5 do
						
							local ppos = pos + math.mod(pn+2,5)*(math.pi*2)/5
							
							local a = PrxA(pn)
							if a then
								a:hidden(0)
								if pn ~= 3 then
									--a:hidden(1)
								end
								a:x( 0 + xrad*math.sin(ppos) )
								a:y( 0 + yadd + yrad*math.sin(2*ppos) )
							end
							
							if pn < 4 then
								if pn==3 then
									mod_do('*10000 100 stealthgg, *10000 '..(100-100*rgb)..' stealthgr, *10000 '..(100-100*rgb)..' stealthgb',pn)
								else
									mod_do('*10000 100 stealthgr, *10000 '..(100-100*rgb)..' stealthgg, *10000 '..(100-100*rgb)..' stealthgb',pn)
								end
							end
							
						end
						
					end)
					
					me(276,276,100,60,'suddenoffset',e,outQuad,nil,290)
					m(276,290,'*1000 sudden',e)
					
					me(276,276,0,100,'flip',e,outQuad,1,290)
					me(290,2,100,0,'flip',l,linear,1)
					me(276,276,0,100*math.pi,'confusionoffset',e,outQuad,1,290)
					me(290,2,100*math.pi,0,'confusionoffset',l,linear,1)
					
					me(276,276,0,125,'invert',e,outQuad,2,290)
					me(290,2,125,0,'invert',l,linear,2)
					me(276,276,0,25,'flip',e,outQuad,2,290)
					me(290,2,25,0,'flip',l,linear,2)
					me(276,276,0,50*math.pi,'confusionoffset',e,outQuad,2,290)
					me(290,2,50*math.pi,0,'confusionoffset',l,linear,2)
					
					me(290,2,0,0,'flip',l,linear,3)
					
					m2(292.01,function()
						
						for pn=1,5 do
							
							local a = PrxA(pn)
							if a then
								a:xy(0,0)
								if pn>3 then a:hidden(1) end
							end
							
						end
						
					end,true)
					
					for pn=1,2 do
						--m(318,396,'*10 hidden',e,pn)
					end
					
					m2(320,function()
						local a = PrxA(3)
						if a then
							a:hidden(1)
						end
					end,true)
					m2(324,function()
						local a = PrxA(3)
						if a then
							a:hidden(0)
						end
					end)
					
					--[[
					m(320,999,'sudden',e,1)
					m(320,999,'sudden',e,2)
					m(320,999,'hidden',e,3)
					]]
					
					m2(323.5,function()
						for pn=1,3 do
							local a = Plr(pn)
							for c=0,3 do
								if a then
									a:SetNumArrowGradientPoints(c,4)
								end
							end
						end
					end,true)
					
					m2(324,function()
						--wenis
						for pn=1,2 do
							local a = Plr(pn)
							for c=0,3 do
								if a then
									a:SetNumArrowGradientPoints(c,4)
									--Player:SetArrowGradientColor(point,column,r,g,b,a)
									a:SetArrowGradientColor(0,c,1,1,1,.5)
									a:SetArrowGradientColor(1,c,1,1,1,.5)
									
									a:SetArrowGradientColor(2,c,1,1,1,0)
									a:SetArrowGradientColor(3,c,1,1,1,.5)
									
									--Player:SetArrowGradientPoint(point,column,where)
									a:SetArrowGradientPoint(0,c,99)
									a:SetArrowGradientPoint(1,c,99)
									a:SetArrowGradientPoint(2,c,99)
									a:SetArrowGradientPoint(3,c,99)
								end
							end
						end
						
						for pn=3,3 do
							local a = Plr(pn)
							for c=0,3 do
								if a then
									a:SetNumArrowGradientPoints(c,4)
									--Player:SetArrowGradientColor(point,column,r,g,b,a)
									a:SetArrowGradientColor(0,c,1,0,0,0)
									a:SetArrowGradientColor(1,c,1,0,0,.5)
									
									a:SetArrowGradientColor(2,c,1,0,0,.5)
									a:SetArrowGradientColor(3,c,1,0,0,0)
									
									--Player:SetArrowGradientPoint(point,column,where)
									a:SetArrowGradientPoint(0,c,99)
									a:SetArrowGradientPoint(1,c,99)
									a:SetArrowGradientPoint(2,c,99)
									a:SetArrowGradientPoint(3,c,99)
								end
							end
						end
						
					end,true)
					
					--m(328,999,'30 stealth',e,3)
					
					mpf(324,999,function(beat)
						
						for pn=1,3 do
							local a = Plr(pn)
							if a then
								for c=0,3 do
									a:SetArrowGradientPoint(0,c,(final_top:GetY())-0.5)
									a:SetArrowGradientPoint(1,c,(final_top:GetY())+0.5)
									a:SetArrowGradientPoint(2,c,(final_bottom:GetY())-0.5)
									a:SetArrowGradientPoint(3,c,(final_bottom:GetY())+0.5)
								end
							end
						end
						
						local p12alp = 0.5
						if beat >=352 and beat < 356 then
							p12alp = .5-.5*linear(beat-352,0,1,4)
						elseif beat >= 352 then
							p12alp = 0
						end
						
						for pn=1,2 do
							local a = Plr(pn)
							if a then
								for c=0,3 do
									a:SetArrowGradientColor(1,c,1,1,1,p12alp)
								end
							end
						end
						
						--local red = 0
						
						local red = 1
						
						if beat >=324 and beat < 356 then
							--red = 1*(beat-math.floor(beat))
							red = .5
						elseif beat >=356 and beat < 360 then
							--red = (1-linear(beat-352,0,1,4))*(beat-math.floor(beat))
							red = (1-linear(beat-356,0,1,4))*.5
						elseif beat >= 360 then
							red = 0
							--red = (.5 - (beat-math.floor(beat)))*2
						end
						
						if slumpo then red = 0 end
						
						local a = Plr(3)
						if a then
							for c=0,3 do
								a:SetArrowGradientColor(0,c,1,1-red,1-red,0)
								a:SetArrowGradientColor(1,c,1,1-red,1-red,.5)
								a:SetArrowGradientColor(2,c,1,1-red,1-red,.5)
								a:SetArrowGradientColor(3,c,1,1-red,1-red,0)
							end
						end
						
						local typos = 6
						local bypos = 8
						
						if not slumpo then
							if beat >= 324 and beat < 352 then
								typos = 6-4*outQuad(beat-328,0,1,28)
							elseif beat >= 352 and beat < 356 then
								typos = 2-6*inOutQuad(beat-352,0,1,4)
								bypos = 8-8*inOutQuad(beat-352,0,1,4)
							elseif beat >= 356 and beat < 388 then
								typos = -4
								bypos = 6.6*linear(beat-356,0,1,32)
							elseif beat >= 388 then
								typos = -4
								bypos = 6.6
							end
						else
							if beat >= 324 and beat < 352 then
								typos = 6-4*outQuad(beat-328,0,1,28)
							elseif beat >= 352 and beat < 356 then
								typos = 2-6*inOutQuad(beat-352,0,1,4)
								--bypos = 8-8*inOutQuad(beat-352,0,1,4)
							elseif beat >= 356 and beat < 388 then
								typos = -4
								--bypos = 6.6*linear(beat-356,0,1,32)
							elseif beat >= 388 then
								typos = -4
								--bypos = 6.6
							end
						end
						
						final_top:y(typos)
						final_bottom:y(bypos)
						
					end)
					
					me(320,324,1.5,1.3,'xmod',e,linear,nil,999)
					
					--me(324,340,0,100,'boost',e,linear,nil,352)
					--me(352,356,100,0,'boost',e,linear)
					
					if slumpo then
						--me(356,388,0,50,'brake',e,linear)
					end
					
					
					--embellishments
					
					m2(4,function()
						dop_bg0:linear( spb*32 )
						dop_bg0:diffuse(.5,.5,.5,1)
					end)
					m2(36,function()
						dop_bg1:linear( spb*28 )
						dop_bg1:diffuse(.5,.5,.5,1)
					end)
					m2(64,function()
						dop_bg0:diffuse(.5,.5,.5,0)
						dop_bg1:linear( spb*4 )
						dop_bg1:diffuse(.5,.5,.5,0)
					end)
					m2(68,function()
						dop_bg0:diffuse(.5,.5,.5,0)
						dop_bg1:diffuse(.5,.5,.5,0)
					end,true)
					
					mpf(0,999,function(beat)
						
						if P3 then
							for i=0,127,2 do
							
								local left = ( GAMESTATE:GetX(2,0,i*4)-96 + GAMESTATE:GetX(2,1,i*4)-32 )/2
								local right = ( GAMESTATE:GetX(2,2,i*4)+32 + GAMESTATE:GetX(2,3,i*4)+96 )/2
								
								laser_blue:SetVertexPosition( i, left-25, i*4, 0 )
								laser_blue:SetVertexPosition( i+1, left+25, i*4, 0 )
								laser_red:SetVertexPosition( i, right-25, i*4, 0 )
								laser_red:SetVertexPosition( i+1, right+25, i*4, 0 )
								
							end
						end
						
					end)
					
					m(-.1+28,1,'*10 -30 drunk',l)
					
					m(-.1+29,.5,'*10 30 drunk',l)
					m(-.1+29.5,.5,'*10 -30 drunk',l)
					m(-.1+30,1,'*10 30 drunk',l)
					
					m(-.1+31,.5,'*10 -30 drunk',l)
					m(-.1+31.5,.5,'*10 30 drunk',l)
					m(-.1+32,.5,'*10 -30 drunk',l)
					m(-.1+32.5,.5,'*10 30 drunk',l)
					m(-.1+33,.5,'*10 -30 drunk',l)
					m(-.1+33.5,.5,'*10 30 drunk',l)
					m(-.1+34,.5,'*10 -30 drunk',l)
					m(-.1+34.5,.5,'*10 30 drunk',l)
					m(-.1+35,.5,'*10 -30 drunk',l)
					m(-.1+35.5,.5,'*10 30 drunk',l)
					m(-.1+36,1,'*10 no drunk',l)
					
					me(0,4,0,200,'tiny',l,inCubic)
					me(4,34,-1000,-100,'tiny',e,linear)
					me(4,34,-2000,-300,'tipsy',e,linear)
					me(4,34,100,50,'dark',e,linear)
					me(34,36,-100,0,'tiny',e,linear)
					me(34,36,-300,0,'tipsy',e,linear)
					me(34,36,50,0,'dark',e,linear)
					
					me(4,36,200*math.pi*8,0,'confusionoffset',e,outQuad)
					
					m2(64,function()
						laser_blue:linear(spb*4)
						laser_blue:diffusealpha(1)
						laser_red:linear(spb*4)
						laser_red:diffusealpha(1)
					end)
					
					m2(132,function()
						laser_blue:linear(spb*4)
						laser_blue:diffusealpha(0)
						laser_red:linear(spb*4)
						laser_red:diffusealpha(0)
						
						dop_bg1:linear(spb*4)
						dop_bg1:diffusealpha(1)
					end)
					
					m2(176,function()
						dop_bg1:linear(spb*4)
						dop_bg1:diffuse(0,0,0,1)
					end)
					
					m(100,132,'100 bumpy',e,1)
					m(100,132,'-100 bumpy',e,2)
					
					m(116,132,'*0.5 -50 drunk',e,1)
					m(116,132,'*0.5 50 drunk',e,2)
					
					m2(132,4,100,0,'bumpy',l,outQuad,1)
					m2(132,4,-100,0,'bumpy',l,outQuad,2)
					
					m2(132,4,-50,0,'drunk',l,outQuad,1)
					m2(132,4,50,0,'drunk',l,outQuad,2)
					
					m2(176,'Eyes');
					
					m2(180,function()
						
						dop_bg2:diffusealpha(1)
						dop_bg1:diffuse(0,0,0,0)
						
					end)
					
					m(176,324,'*100 80 bumpyyoffset, *100 80 bumpyxoffset, *100 100 bumpyxperiod, *100 100 bumpyyperiod',e)
				
					local f = 1
					for i=180,209,4 do
						local amt = 300
						
						if i ~= 188 and i ~= 204 then
							if i > 180 then
							me(i-1,1,0,amt*f,'bumpyx',l,inOutSine)
							end
							me(i,1,amt*f,0,'bumpyx',l,inOutSine)
							
							if i < 206 then
							me(i+2-1,1,0,amt*f,'bumpyy',l,inOutSine)
							me(i+2,1,amt*f,0,'bumpyy',l,inOutSine)
							end
							
							f = f*-1
						end
					end
					
					for i=252,264,4 do
						local amt = 200
						
						if true then
							if i > 252 then
							me(i-1,1,0,amt*f,'bumpyx',l,inOutSine)
							end
							me(i,1,amt*f,0,'bumpyx',l,inOutSine)
							
							if i < 264 then
							me(i+2-1,1,0,amt*f,'bumpyy',l,inOutSine)
							me(i+2,1,amt*f,0,'bumpyy',l,inOutSine)
							end
							
							f = f*-1
						end
					end
					
					for i=276,290,4 do
						local amt = 200
						
						if true then
							if i > 276 then
							me(i-1,1,0,amt*f,'bumpyx',l,inOutSine)
							end
							me(i,1,amt*f,0,'bumpyx',l,inOutSine)
							
							if i < 288 then
							me(i+2-1,1,0,amt*f,'bumpyy',l,inOutSine)
							me(i+2,1,amt*f,0,'bumpyy',l,inOutSine)
							end
							
							f = f*-1
						end
					end
					
					mod_wiggle(187,3,3,250,1.5,'drunk')
					mod_wiggle(188,6,3,250,1.5,'tipsy')
					mod_wiggle(190,6,3,250,1.5,'drunk')
					
					mod_wiggle(203,2,2,250,1.5,'drunk')
					mod_wiggle(204,4,2,250,1.5,'tipsy')
					mod_wiggle(206,4,2,250,1.5,'drunk')
					
					m2(210,function()
						
						dop_bg2:linear(spb*2)
						dop_bg2:diffusealpha(0)
						laser_blue:linear(spb*2)
						laser_blue:diffusealpha(1)
						laser_red:linear(spb*2)
						laser_red:diffusealpha(1)
						
					end)
					
					m2(252,function()
						
						dop_bg2:diffusealpha(1)
						laser_blue:diffusealpha(0)
						laser_red:diffusealpha(0)
						
					end)
					
					m2(264,function()
						
						dop_bg2:linear(spb*4)
						dop_bg2:diffusealpha(0)
						laser_blue:linear(spb*4)
						laser_blue:diffusealpha(1)
						laser_red:linear(spb*4)
						laser_red:diffusealpha(1)
						
					end)
					
					m2(276,function()
						
						dop_bg2:diffusealpha(1)
						laser_blue:diffusealpha(0)
						laser_red:diffusealpha(0)
						
					end)
					
					m2(290,function()
						
						dop_bg2:linear(spb*2)
						dop_bg2:diffusealpha(0)
						laser_blue:linear(spb*2)
						laser_blue:diffusealpha(1)
						laser_red:linear(spb*2)
						laser_red:diffusealpha(1)
						
					end)
					
					m2(320,function()
						
						laser_blue:linear(spb*3.75)
						laser_blue:diffusealpha(0)
						laser_red:linear(spb*3.75)
						laser_red:diffusealpha(0)
						
					end)
					
					m(323.5,387.5,'*1000 150 beat',e)
					
					me(324,352,0,150,'distant',e,linear)
					me(352,356,150,0,'distant',e,linear)
					
					m(388,9999,'*0.7 200 tiny, *0.06 -400 flip, *2 3000 tornado, *2 200000 confusionoffset, *0.5 20000 drunk',e)
					
					--[[
					me(292,320,0,100,'tornado',e,linear,nil,64)
					me(320,324,100,0,'tornado',e,outQuad)
					]]
					
					--me(290,292,0,
					
					for i=0,3 do
						local mu = 1
						if i > 1 then mu = -1 end
						m(290,324,'*10000 400 bumpyxperiod'..i..', *10000 400 bumpyperiod'..i,e)
						me(290,292,400,350,'bumpyxperiod'..i,e,outQuad,nil,324)
						me(290,292,400,350,'bumpyperiod'..i,e,outQuad,nil,324)
						
						me(290,324,0,8*400,'bumpyxoffset'..i,e,linear)
						--me(290,324,100,100+8*400,'bumpyoffset'..i,e,linear)
						
						me(290,292,0,300*mu,'bumpyx'..i,e,linear,nil,320)
						me(320,324,300*mu,0,'bumpyx'..i,e,linear,nil,325)
						me(290,292,0,600*mu,'bumpy'..i,e,linear,nil,320)
						me(320,324,600*mu,0,'bumpy'..i,e,linear,nil,325)
					end
					
					for pn=1,2 do
						me(324,328,0,200,'dizzy',e,inOutQuad,pn,356)
						me(356,4,200,0,'dizzy',l,inOutQuad,pn)
					end
					
					--[[
					me(180,204,0,-30,'flip',e,linear,nil,210)
					me(210,212,-30,0,'flip',e,linear,nil,213)
					]]
					
					--char
					m2(36,function()
						
						dop_reisen:xy(scx,scy)
						dop_reisen:playcommand('Spawn')
						
					end)
					
					m2(63.6,function() taro_Sound('spell') end)
					m2(64,function()
						
						dop_reisen:playcommand('Cast')
						
					end)
					m2(68,function()
						
						dop_reisen:playcommand('Hide')
						
					end)
					
					m2(148,function()
						
						dop_reisen:xy(scx,scy)
						dop_reisen:playcommand('Spawn')
						
					end)
					m2(175.6,function() taro_Sound('spell') end)
					m2(176,function()
						
						dop_reisen:playcommand('Cast')
						
					end)
					m2(180,function()
						
						dop_reisen:playcommand('HideQ')
						
					end)
					
					m2(388,function()
						
						dop_reisen:xy(scx,scy)
						MESSAGEMAN:Broadcast('WhiteFlash')
						dop_reisen:playcommand('SpawnQ')
						dop_reisen:playcommand('Dead')
						
					end)
					
					local function squidge(b)
						
						m2(b-.1,function()
							
							for pn=1,2 do
								
								local a = Plr(pn)
								if a then
									a:decelerate(30/200)
									a:zoomy(1 - .2*(pn*2-3))
									a:zoomx(1 + .2*(pn*2-3))
									a:decelerate(30/200)
									a:zoomy(1 + .2*(pn*2-3))
									a:zoomx(1 - .2*(pn*2-3))
									a:decelerate(30/200)
									a:zoomy(1 - .2*(pn*2-3))
									a:zoomx(1 + .2*(pn*2-3))
									a:decelerate(30/200)
									a:zoomy(1 + .2*(pn*2-3))
									a:zoomx(1 - .2*(pn*2-3))
									a:decelerate(30/200)
									a:zoomx(1)
									a:zoomy(1)
								end
								
							end
							
						end)
						
					end
					
					m(147.5,175.5,'*1000 100 beat',e,1)
					m(147.5,175.5,'*1000 -100 beat',e,2)
					
					m(147.5,175.5,'30 drunk, 30 wave',e)
					
					m(153-.1,8,'*10 reverse',l,1)
					m(153.5-.1,8,'*10 reverse',l,2)
					m(161-.1,3,'*10 no reverse',l,1)
					m(161.5-.1,3,'*10 no reverse',l,2)
					m(162,8,'*3 reverse',l,1)
					m(163,8,'*3 reverse',l,2)
					m(169-.1,3,'*10 no reverse',l,1)
					m(169.5-.1,3,'*10 no reverse',l,2)
					
					squidge(149.5)
					squidge(157.5)
					squidge(165.5)
					squidge(173.5)
					
		---------------------------------------------------------------------------------------
		----------------------Sort the actions table-------------------------------------------
		---------------------------------------------------------------------------------------
					
					function modtable_compare(a,b)
						return a[1] < b[1]
					end
					
					if table.getn(mod_actions) > 1 then
						table.sort(mod_actions, modtable_compare)
					end
					
					function main_loop(val)
						if GAMESTATE:GetSongBeat()>=0 and not checked then
					
							local ThingsToGrab = {'LifeP1','LifeP2','ScoreP1','ScoreP2','BPMDisplay','LifeFrame','ScoreFrame',
													'Lyrics','SongBackground','SongForeground','Overlay','Underlay'}
							local ThingsToHide = {'LifeP1','LifeP2','ScoreP1','ScoreP2','BPMDisplay','LifeFrame','ScoreFrame','Overlay','Underlay'}
							
							for i,v in ipairs(ThingsToGrab) do
								_G[v] = SCREENMAN:GetTopScreen():GetChild(v) or nil
							end
							
							for i,v in ipairs(ThingsToHide) do
								if _G[v] then _G[v]:hidden(1) end
							end
							
							table.insert(mod_plr,SCREENMAN:GetTopScreen():GetChild('PlayerP1'));
							table.insert(mod_plr,SCREENMAN:GetTopScreen():GetChild('PlayerP2'));
							
							--name players, judgment and combo
							for pn=1,3 do
								_G['P'..pn] = SCREENMAN:GetTopScreen():GetChild('PlayerP'..pn) or nil;
								if _G['P'..pn] then
									_G['jud'..pn] = _G['P'..pn]:GetChild('Judgment');
									_G['com'..pn] = _G['P'..pn]:GetChild('Combo');
								end
							end
							
							screen = SCREENMAN:GetTopScreen();
							checked = true; --let this only run once
							
						end

						local beat = GAMESTATE:GetSongBeat()
						
						
			---------------------------------------------------------------------------------------
			----------------------Begin table handlers---------------------------------------------
			---------------------------------------------------------------------------------------
						
						disable = false;
						if disable ~= true and beat > mod_firstSeenBeat+0.1 and checked then
							
							-----------------------
							-- Player mod resets --
							-----------------------
							if beat > mod_firstSeenBeat+0.1 then -- performance coding!! --
								for i=1,3 do
									mod_do('clearall',i)
								end
							end
							
							------------------------------------------------------------------------------
							-- custom mod reader by TaroNuke edited by WinDEU and re-stolen by TaroNuke --
							------------------------------------------------------------------------------
							if beat > mod_firstSeenBeat+0.1 then -- performance coding!! --
								for i,v in pairs(mods) do
									if v and table.getn(v) > 3 and v[1] and v[2] and v[3] and v[4] then
										if beat >=v[1] then
											if (v[4] == 'len' and beat <=v[1]+v[2]) or (v[4] == 'end' and beat <=v[2]) then
												if table.getn(v) == 5 then
													mod_do(v[3],v[5]);
												else
													mod_do(v[3]);
												end
											end
										end
									else
										v[1] = 0;
										v[2] = 0;
										v[3] = '';
										v[4] = 'error';
										SCREENMAN:SystemMessage('Bad mod in beat-based table (line '..i..')');
									end
								end
							end
							
							-----------------------------------------------------------------------------------------------------
							-- WinDEU's time-based len/end version of the #swag custom mod reader #teamproofofconcept (c) 2015 --
							-----------------------------------------------------------------------------------------------------
							if beat > mod_firstSeenBeat+0.1 then -- performance coding!! --
								for i,v in pairs(mods2) do
									if v and table.getn(v) > 3 and v[1] and v[2] and v[3] and v[4] then
										if mod_time >=v[1] then
											if (v[4] == 'len' and mod_time <=v[1]+v[2]) or (v[4] == 'end' and mod_time <=v[2]) then
												if table.getn(v) == 5 then
													mod_do(v[3],v[5]);
												else
													mod_do(v[3]);
												end
											end
										end
									else
										v[1] = 0;
										v[2] = 0;
										v[3] = 'error';
										v[4] = 'error';
										SCREENMAN:SystemMessage('Bad mod in time-based table (line '..i..')');
									end
								end
							end
							
							--------------------------------------------------------------------------------------
							-- i dont know who this reader is but he looks like he is made out of EASE HAHAHAHA --
							-- original code by exschwasion, bastardized by taro for cmod support and less 'if' --
							--------------------------------------------------------------------------------------
							for i,v in pairs(mods_ease) do
								if v and table.getn(v) > 6 and v[1] and v[2] and v[3] and v[4] and v[5] and v[6] and v[7] then
									if beat >=v[1] then
										if (v[6] == 'len' and beat <=v[1]+v[2]) or (v[6] == 'end' and beat <=v[2]) then
											
											local duration = v[2];
											if v[6] == 'end' then duration = v[2] - v[1] end
											local curtime = beat - v[1]
											local diff = v[4] - v[3]
											local startstrength = v[3]
											local curve = v[7]
											local mod = v[5]
											
											local strength = curve(curtime, startstrength, diff, duration, v[10], v[11]) --extra parameters for back and elastic eases :eyes:
											
											local modstr = v[5] == 'xmod' and strength..'x' or (v[5] == 'cmod' and 'C'..strength or strength..' '..v[5])
											mod_do('*10000 '..modstr,v[8]);
											
										elseif (v[9] and ((v[6] == 'len' and beat <=v[1]+v[2]+v[9]) or (v[6] == 'end' and beat <=v[9]))) then
										
											local strength = v[4]
											
											local modstr = v[5] == 'xmod' and strength..'x' or (v[5] == 'cmod' and 'C'..strength or strength..' '..v[5])
											mod_do('*10000 '..modstr,v[8]);
											
										end
									end
								else
									SCREENMAN:SystemMessage('Bad mod in beat-based ease table (line '..i..')');
								end
							end
							
							--------------------
							-- Perframe stuff --
							--------------------
							
							groove_update(beat);

							if table.getn(mod_perframes)>0 then
								for i=1,table.getn(mod_perframes) do
									local a = mod_perframes[i]
									if beat >= a[1] and beat <= a[2] then
										a[3](beat);
									end
								end
							end
							
							---------------------------------------
							-- ACTION RPGS AINT GOT SHIT ON THIS --
							---------------------------------------
							if beat > mod_firstSeenBeat+0.1 then -- performance coding!! --
								while curaction<=table.getn(mod_actions) and GAMESTATE:GetSongBeat()>=mod_actions[curaction][1] do
									if mod_actions[curaction][3] or GAMESTATE:GetSongBeat() < mod_actions[curaction][1]+2 then
										if type(mod_actions[curaction][2]) == 'function' then
											mod_actions[curaction][2]()
										elseif type(mod_actions[curaction][2]) == 'string' then
											MESSAGEMAN:Broadcast(mod_actions[curaction][2]);
										end
									end
									curaction = curaction+1;
								end
							end
							
						end
						
						return 0
					end
					
				else
					
					SCREENMAN:SystemMessage('NotITG version Too Old! Needs v3.1')
					
				end
				
			end"
			
		/>
		
		<LAER File="chara" />
		
		<LAER Type="Polygon" Texture="sdvx_l" Vertices="128" DrawMode="QuadStrip" Var="laser_blue"
			OnCommand="%function(self)
				self:diffusealpha(0)
				self:blend('add')
				self:xy(scx,scy-138)
				for i=0,127,2 do
					self:SetVertexTexCoord(i,0,.5)
					self:SetVertexTexCoord(i+1,1,.5)
				end
			end"
		/>
		<LAER Type="Polygon" Texture="sdvx_r" Vertices="128" DrawMode="QuadStrip" Var="laser_red"
			OnCommand="%function(self)
				self:diffusealpha(0)
				self:blend('add')
				self:xy(scx,scy-138)
				for i=0,127,2 do
					self:SetVertexTexCoord(i,0,.5)
					self:SetVertexTexCoord(i+1,1,.5)
				end
			end"
		/>
		
		<LAER Type="ActorProxy" OnCommand="hidden,0;" Var="Proxy3A" GetProxyMessageCommand="%function(self) if P3 then self:SetTarget(P3) P3:hidden(1) end end" />
		
		<LAER Type="ActorProxy" OnCommand="hidden,0;" Var="Proxy1A" GetProxyMessageCommand="%function(self) if P1 then self:SetTarget(P1) P1:hidden(1) end end" />
		<LAER Type="ActorProxy" OnCommand="hidden,0;" Var="Proxy2A" GetProxyMessageCommand="%function(self) if P2 then self:SetTarget(P2) P2:hidden(1) end end" />
		
		<LAER Type="ActorProxy" OnCommand="hidden,1;" Var="Proxy4A" GetProxyMessageCommand="%function(self) if P1 then self:SetTarget(P1) P1:hidden(1) end end" />
		<LAER Type="ActorProxy" OnCommand="hidden,1;" Var="Proxy5A" GetProxyMessageCommand="%function(self) if P2 then self:SetTarget(P2) P2:hidden(1) end end" />
		
		<!--Handling messages here is still fun and profitable-->
		<Layer Type="ActorFrame" OnCommand="xy,scx,scy-136" ><children>
			<CODE Type="Quad" OnCommand="hidden,1;zoom,20;y,999" InitCommand="%function(self) final_top = self end" />
			<CODE Type="Quad" OnCommand="hidden,1;zoom,20;y,999" InitCommand="%function(self) final_bottom = self end" />
		</children></Layer>
		
		<!--This is for the time based mod reader-->
		<BitmapText
			Font="Common Normal"
			Text="test"
			OnCommand="x,SCREEN_CENTER_X;y,SCREEN_CENTER_Y;effectclock,music;playcommand,SetTime;hidden,1"
			SetTimeCommand="%function(self) self:settext(self:GetSecsIntoEffect()); mod_time = mod_globaloffset+tonumber(self:GetText()); self:sleep(0.02); self:queuecommand('SetTime'); end"
		/>
		
		<!--Debug-->
		<BitmapText
			Font="Common Normal"
			Text=""
			Var="dbg"
			OnCommand="x,SCREEN_CENTER_X;y,SCREEN_CENTER_Y;hidden,0"
		/>
		
		<LAER Type="ActorFrame" InitCommand="%function(self) judc = self end"><children>
		<LAER Type="ActorProxy" InitCommand="%function(self) jud1p = self end"
		GetProxyMessageCommand="%function(self) if P1 then self:SetTarget(P1:GetChild('Judgment')) end end"/>
		<LAER Type="ActorProxy" InitCommand="%function(self) jud2p = self end"
		GetProxyMessageCommand="%function(self) if P2 then self:SetTarget(P2:GetChild('Judgment')) end end"/>
		</children></LAER>
		<LAER Type="ActorFrame" InitCommand="%function(self) comc = self end"><children>
		<LAER Type="ActorProxy" InitCommand="%function(self) com1p = self end"
		GetProxyMessageCommand="%function(self) if P1 then self:SetTarget(P1:GetChild('Combo')) end end"/>
		<LAER Type="ActorProxy" InitCommand="%function(self) com2p = self end"
		GetProxyMessageCommand="%function(self) if P2 then self:SetTarget(P2:GetChild('Combo')) end end"/>
		</children></LAER>
		
	</children></Layer>
	
	<ZLayer Type="Quad" OnCommand="stretchto,0,0,sw,sh;diffuse,1,1,1,0;" WhiteFlashQMessageCommand="diffusealpha,1;linear,.5;diffusealpha,0;" WhiteFlashMessageCommand="diffusealpha,1;linear,2;diffusealpha,0;" />
	
	<ZLayer File="eyes" OnCommand="xy,scx,scy;diffusealpha,0;blend,add;" EyesMessageCommand="zoom,1;diffusealpha,1;decelerate,3;diffusealpha,0.2;sleep,2;linear,2;diffusealpha,0;" />
	<ZLayer File="eyes" OnCommand="xy,scx,scy;diffusealpha,0;blend,add;" EyesMessageCommand="zoom,1;diffusealpha,1;decelerate,1;diffusealpha,0;zoom,1.2;" />
	
</children></ActorFrame>