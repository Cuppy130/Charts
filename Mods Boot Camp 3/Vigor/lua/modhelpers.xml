<ActorFrame><children>
<CODE Type="Quad" OnCommand="hidden,1"
	InitCommand="%function(self)

		function Plr(pn) 
			return _G['P'..pn]
		end

		function normalize(value,min,max,nmin,nmax)
			return nmin + (value-min)*(nmax-nmin)/(max-min)
		end

		function mod_do(str,pn)
			if pn then
				GAMESTATE:ApplyGameCommand('mod,'..str,pn)
			else
				GAMESTATE:ApplyGameCommand('mod,'..str)
			end
		end		
		
		function mod_table_shuffle(t) --shuffles a table
			local n = table.getn(t)
			while n >= 2 do
				-- n is now the last pertinent index
				local k = math.random(n) -- 1 <= k <= n
				-- Quick swap
				t[n], t[k] = t[k], t[n]
				n = n - 1
			end
			return t
		end
		
		function modtable_compare(a,b)
			return a[1] < b[1]
		end
		
		function perframe( beat, endBeat )
			local cur = GAMESTATE:GetSongBeat();
			return cur >= mod_firstSeenBeat+1 and cur >= beat and cur < (endBeat or beat+1);
		end
		
		function mod_insert(beat,len,mod,t,pn)
			if not t then t = 'len' end
			table.insert(mods,{beat,len,mod,t,pn});
		end
		
		function mod2_insert(beat,len,mod,t,pn)
			if not t then t = 'len' end
			table.insert(mods2,{beat,len,mod,t,pn});
		end
		
		function mod_ease(beat,len,str1,str2,mod,t,ease,pn,sus,a,p)
			table.insert(mods_ease,{beat,len,str1,str2,mod,t,ease,pn,sus,a,p})
		end
		
		function mod_message(beat,msg,p)
			table.insert(mod_actions,{beat,msg,p});
		end
		
		function mod_blacklist(t,n)
			for i=1,table.getn(t) do
				if t[i] == n then
					return true
				end
			end
			return false
		end

		-- world's ugliest function
		-- ease_wiggle now supports absolute values
		function ease_wiggle(beat,len,amt,step,str,ease,t,pn,abs)
		    local s,count,pStart,pEnd,cur,prev,e = 0,1,0,0,-amt,amt,0
		    abs = abs or false
		    if t == 'end' then e = len elseif t == 'len' then e = (beat+len) end
		    if abs == true then prev,cur,s = 0,-cur,step end
		    for i = beat,(e-s),step do
		        if abs == false then
		            if i == beat then pStart = 0 else pStart = prev end
		            if i == e then pEnd = 0  else pEnd = cur end
		        elseif abs == true then
		            if count == -1 then cur,prev = 0,amt elseif count == 1 then cur,prev = amt,0 end
		            pStart,pEnd = prev,cur
		        end
		        mod_ease(i,step,pStart,pEnd,str,'len',ease,pn)
		        if abs == false then cur,prev = -cur,-prev
		        elseif abs == true then count = -count
		        end
		    end
		end
		
		-- hey alright
		function modulo(a, b)
			return a - math.floor(a/b)*b;
		end

		function mod_bounce(beat,length,start,apex,mod,ease,inverse,pn)
			local i,o = 'in','out'
			if inverse == true then i,o = 'out','in' end
			mod_ease(beat, (length/2), start, apex, mod, 'len', _G[o..''..tostring(ease)],pn)
			mod_ease(beat+(length/2), (length/2), apex, start, mod, 'len', _G[i..''..tostring(ease)],pn,0.2)
		end

		function randomXD(t)
			if t == 0 then return 0.5 else
			return modulo(math.sin(t * 3229.3) * 43758.5453, 1) end
		end

		function switcheroo_reset()
			switcheroo_flip = {0,0,0};
			switcheroo_invert = {0,0,0};
		end
		
		local switcheroo_flip = {0,0,0};
		local switcheroo_invert = {0,0,0};
		function switcheroo_add(beat,which,speed,len,pn,width)
			if not width then width = 1 end
			local switcheroo_width = width
			local switcheroos = {normal = {0,0}, ldur = {0,0}, reset = {0,0},
			flip = {100,0}, rudl = {100,0}, invert = {0,100}, dlru = {0,100},
			ludr = {25,-75}, rdul = {75,75}, drlu = {25,125}, ulrd = {75,-125}, urld = {100,-100}}
			if not speed then speed = 1000000 end
			local mpn = 3
			if pn then mpn = pn end
			local w = {0,0}
			if type(which) == 'string' then w = switcheroos[which] end
			if type(which) == 'table' then w = which end
			if w then
				local targf = (switcheroos[which][1]*switcheroo_width) + ( 50 - switcheroo_width*50 )
				local targi = (switcheroos[which][2]*switcheroo_width)
				local sw_modlist = ''
				if switcheroo_flip[mpn] ~= targf then
					sw_modlist = sw_modlist..'*'..(0.01*speed*math.abs(targf-switcheroo_flip[mpn]))..' '..(targf)..' flip,'
				else
					sw_modlist = sw_modlist..'*1 '..(targf)..' flip,'
				end
				if switcheroo_invert[mpn] ~= targi then
					sw_modlist = sw_modlist..'*'..(0.01*speed*math.abs(targi-switcheroo_invert[mpn]))..' '..(targi)..' invert'
				else
					sw_modlist = sw_modlist..'*1 '..(targi)..' invert'
				end
				table.insert(mods,{beat,len,sw_modlist,'len',pn});
				if mpn == 3 then
					for apn=1,3 do
						switcheroo_flip[apn] = targf;
						switcheroo_invert[apn] = targi;
					end
				else
					switcheroo_flip[mpn] = targf;
					switcheroo_invert[mpn] = targi;
				end
			end
		end

		function mod_quickswaps(beat,len,which,speed,step,pn)
			for i = beat,(beat+len)-(step*2),(step*2) do
				switcheroo_add(i,tostring(which),speed,step,nil)
				switcheroo_add(i+step,'normal',speed,step,nil)
			end
		end

		function bouncy_wiggle(beat,len,step,start,apex,mod,t,ease,abs,pn,inc)
			if not inc then inc = 0 end
			local f = 1 if t == 'end' then shit = len else shit = (beat+len) end
			local ass = 0
			for i = beat,(shit-step),step do
				if abs == true then fuck = (apex+ass) else fuck = (apex+ass)*f end
				mod_bounce(i,step,start,fuck,mod,tostring(ease),false,pn)
				f=-f
				ass = ass + inc
			end
		end

		function mod_drivendrop(beat,length,step,speedmod,isCentered2,pn)
			local str = ''
			if not isCentered2 then isCentered2 = false end
			if isCentered2 == false then str = 'centered' else str = 'centered2' end
			mod_insert(beat, length, '*-1 1 approachtype','len',pn)
			for i = beat,(beat+length)-step,step do
				local cutoff = (step-0.05)
				mod_insert(i, cutoff, '*'..speedmod..' 10000 '..str,'len',pn)
				mod_insert(i+cutoff, 0.05, '*-1 no '..str,'len',pn)
			end
		end

		function mod_wiggle(beat,num,div,amt,speed,mod,pn,first)
			if not speed then speed = 1 end
			local fluct = 1
			for i=0,(num-1) do
				b = beat+(i/div)
				local m = 1
				if i==0 and not first then m = 0.5 end
					table.insert(mods,{b,1,'*'..math.abs(m*speed*amt/10)..' '..(amt*fluct)..' '..mod..'','len',pn});
					fluct = fluct*-1;
				end
				table.insert(mods,{beat+(num/div),1,'*'..math.abs(amt*speed/20)..' no '..mod..'','len',pn});
		end

	end"
/>
</children></ActorFrame>