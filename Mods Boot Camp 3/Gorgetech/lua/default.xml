<ActorFrame
InitCommand="%function(self)

	songName = GAMESTATE:GetCurrentSong():GetSongDir();
	
	mod_globaloffset = PREFSMAN:GetPreference('GlobalOffsetSeconds');
	
	sw = SCREEN_WIDTH
	sh = SCREEN_HEIGHT --shortcuts
	
	function Plr(pn)
		return _G['P'..pn]
	end
	function GetJud(pn)
		return _G['jud'..pn]
	end
	function GetCom(pn)
		return _G['com'..pn]
	end
	
	function mod_do(str,pn)
		if pn then
			GAMESTATE:ApplyGameCommand('mod,'..str,pn)
		else
			GAMESTATE:ApplyGameCommand('mod,'..str)
		end
	end
	
	function taro_Sound(str)
		local met = GAMESTATE:GetCurrentSong():GetSongDir();
		SOUND:PlayOnce(met..'lua/'..str..'.ogg');
	end
	
	math.clamp = function(val,min,max)
		if val > max then return max end
		if val < min then return min end
		return val
	end
	
end"
><children>

	<Layer
		Type="Quad"
		InitCommand="hidden,1"
		OnCommand="sleep,1000"
	/>
	
	<Layer File="modhelpers.xml" />
	<Layer File="easing.xml" />
	<Layer File="spellcard.xml" />
	<Layer File="../columns.xml" />
	<Layer File="../alcohol.xml" />
	<Layer File="../alcohol2.xml" />
	
	<Layer
		Type="Quad"
		OnCommand="hidden,1"
		InitCommand="%function(self)
		
			checked = false; P1=nil;P2=nil;P3=nil;P4=nil;jud1=nil;com1=nil;jud2=nil;com2=nil;jud3=nil;com3=nil;
			
			slumpo = false
			for pn=1,2 do
				if GAMESTATE:IsPlayerEnabled(pn-1) then
					if GAMESTATE:GetCurrentSteps(pn-1):GetDifficulty() == 5 then
						slumpo = true
					end
				end
			end
		
			---------------------------------------------------------
			---------DOCUMENTATION-----------------------------------
			---------------------------------------------------------
			
			--function perframe( beat, endBeat )
				--return true if the current beat is between 'beat' and 'endBeat'
			
			--function mod_shader(beat,key,which)
				--turn on shader key at specified beat (up to 10 keys available, defined by 'which' = 0-9
				
			--function mod_insert(beat,len,mod,len_or_end,pn)
				--insert mod into beat mods table
			--function mod_insert2(time,len,mod,len_or_end,pn)
				--insert mod into time mods table
				
			--function mod_message(beat,msg,persistent)
				--insert something into the actions table.
				--msg can also be a function. If string, a message gets broadcast at that beat
				--if 'persistent' is true, message will run even if editor starts at a beat past it
				
			--function mod_blacklist(t,n)
				--check if number n occurs in table t
				--useful for doing 'every beat EXCEPT the contents of t'
				
			--function simple_m0d(beat,strength,mult,mod)
			--function simple_m0d2(beat,strength,mult,mod,pn)
			--function simple_m0d3(beat,strength,duration,bpm,mod,pn)
				--activate mods at specific beat but also deactivate them
				
			--function mod_wiggle(beat,num,div,amt,speed,mod,pn,first)
				--alternates a mod back and forth before resetting to 0
				
			--function mod_springt(time,strength,dur,mod,pn)
				--time-based per-frame alternating mod that decreases based on how much time is left.
					--think doorstopper
			
			--function mod_springt2(time,strength,dur,mod,pn)
				--time-based per-frame alternating mod
			
			--function mod_onebeat(beat,strength,pn)
				--turns on beat for the beat specified, at the desired strength	
			
			--function switcheroo_add(beat,which,speed,len,pn)
				--adds a column swap at the desired beat
			--[[	switcheroos = {normal = {0,0}, ldur = {0,0}, reset = {0,0},
					flip = {100,0}, rudl = {100,0}, invert = {0,100}, dlru = {0,100},
					ludr = {25,-75}, rdul = {75,75}, drlu = {25,125}, ulrd = {75,-125}, urld = {100,-100}}
			]]
			
			--use a variable called 'switcheroo_width' to change how much space is between each column
			--e.g. switcheroo_width = 2 for ayakashi
			
			--function mod_sugarkiller(beat,duration,speed,minstealth,maxstealth,pn)
				--portable version of the effect from sugarkill X
				
			--function doSpline(spd, axis, path, col)
				--draws spline 'path' in specified axis, for specific col. Offsets are *10000, but positions use *spd
				
			--function doSplineAll(spd, axis, path)
				--same as above, but for all columns
				--(faster performance than using doSpline 4 times due to more efficient concat)
			
			--function mindf_rotateAndCounter(xDegrees, yDegrees, zDegrees, player)
				--counteract euler rotations after rotating player in multiple axes, using a TON of math.
			
			
			---------------------------------------------------------
			--------END DOCUMENTATION--------------------------------
			---------------------------------------------------------
			
			local m = mod_insert
			local m2 = mod_message
			local me = mod_ease
			
			
			local l = 'len'
			local e = 'end'
			
			
			
			
			
			
			
			init_modsp1 = '';
			init_modsp2 = '';
			
			mod_plr = {};
			
			mod_firstSeenBeat = GAMESTATE:GetSongBeat(); --necessary to prevent long freezes
			
			
			
			
			
			
			
			
			
			
			
---------------------------------------------------------------------------------------
----------------------Begin tables 'n stuff--------------------------------------------
---------------------------------------------------------------------------------------

			--beat based mods
			--{beat_start, beat_end, mods, len_or_end, player_number}
			mods = {
				{0,9999,'*2 2x, *1000 no beat, *10000 -99999 cover','end'},
			}
			
			--switcheroos = {{0,0},{100,0},{0,100},{25,-75},{75,75},{25,125},{75,-125},{100,-100}}
			
			
			
			
			
			
			
			--time based mods
			mod_time = 0;
			--{time_start, time_end, mods, len_or_end, player_number}
			mods2 = {
				--{0,200.345,'3x','end',1},
			}
			
			
			
			
			--this is both a message broadcaster and a function runner
			--if you put {beat,'String'}, then 'String' is broadcast as a message on that beat
			--if you put {beat,function() somecode end}, then function() is run at that beat
			--see example on beat 32
			
			curaction = 1;
			--{beat,thing,persists}
			mod_actions = {
			
			
				
			}
			
			
			
			
			
			
			--beat-based ease mods
			--{time_start, time_end, mod_start, mod_end, mod, len_or_end, ease_type, player_number, sustaintime, optional_param1, optional_param2}
			--valid ease types are:
				--linear
				--inQuad    outQuad    inOutQuad    outInQuad
				--inCubic   outCubic   inOutCubic   outInCubic
				--inQuart   outQuart   inOutQuart   outInQuart
				--inQuint   outQuint   inOutQuint   outInQuint
				--inSine    outSine    inOutSine    outInSine
				--inExpo    outExpo    inOutExpo    outInExpo
				--inCirc    outCirc    inOutCirc    outInCirc
				--inElastic outElastic inOutElastic outInElastic    --can take 2 optional parameters - amplitude & period
				--inBack    outBack    inOutBack    outInBack       --can take 1 optional parameter  - spring amount
				--inBounce  outBounce  inOutBounce  outInBounce
				
			mods_ease = {
				-- EXAMPLE TWEEN: from beat 0 to 4, make rotationz go from 360 to 0 with the inOutBack tween
				--{0,4,360,0,'rotationz','end',inOutBack},
			}
			
			m2(0,function()
				for pn=1,2 do
					local a = Plr(pn)
					if a then
						a:accelerate(60/161)
						a:x(sw/2 + (sw/2 + 160)*(pn*2-3) )
						a:sleep(0)
						a:zoom(0)
					end
				end
			end)
			
			m2(4,function()
				for pn=1,2 do
					local a = Plr(pn)
					if a then
						a:x(sw/2)
						a:rotationy(0)
						a:rotationz(0)
						a:zoom(1)
					end
				end
			end,true)
			
			m2(0,function()
				for pn=1,2 do
					local a = GetJud(pn)
					if a then
						a:bob()
						a:effectoffset(250000)
						a:effectperiod(1000000)
						a:x(160*(pn*2-3))
					end
					local a = GetCom(pn)
					if a then
						a:bob()
						a:effectoffset(250000)
						a:effectperiod(1000000)
						a:x(160*(pn*2-3))
					end
				end
			end,true)
			
			m2(96,function()
				for pn=1,2 do
					local a = GetJud(pn)
					if a then
						a:linear(.1)
						a:x(128*(pn*2-3))
					end
					local a = GetCom(pn)
					if a then
						a:linear(.1)
						a:x(128*(pn*2-3))
					end
				end
			end,true)
			
			m2(34,function()
				for pn=1,2 do
					local a = GetJud(pn)
					if a then
						a:x(0)
					end
					local a = GetCom(pn)
					if a then
						a:x(0)
					end
				end
				gorge_judy:y(-175)
			end,true)
			
			m2(4,function()
				gorge_bg1:rotationy(0)
				gorge_bg1:zoom(1)
				gorge_bg1:linear(8*60/160)
				gorge_bg1:diffusealpha(0)
			end)
			
			m2(4,function()
				gorge_bg2:hidden(0)
			end,true)
			
			m2(12,function()
				gorge_bg1:rotationy(0)
				gorge_bg1:zoom(1)
				gorge_bg1:diffusealpha(0)
			end,true)
			
			m2(258,function()
				gorge_bg1:linear(120/160)
				gorge_bg1:diffusealpha(0)
			end,true)
			
			m2(32,function()
			
				gorge_sky1:accelerate(120/160)
				gorge_sky1:y(0)
				gorge_clouds:accelerate(120/160)
				gorge_clouds:y(sh*-0.5)
				
				gorge_pyra:accelerate(120/160)
				gorge_pyra:y(sh*-0.1)
				
				gorge_desert:accelerate(120/160)
				gorge_desert:y(0)
				gorge_desert:zoomy(0)
				gorge_desert2:accelerate(120/160)
				gorge_desert2:y(sh*0.1)
				gorge_desert2:zoomy(1)
				gorge_desert2:rotationx(0)
				--gorge_desert2:zoomtoheight(SCREEN_HEIGHT*0.5)
				
				gorge_quad:accelerate(120/160)
				gorge_quad:y(sh/2)
				
				gorge_walltop:y(sh)
				gorge_walltop:accelerate(120/160)
				gorge_walltop:y(0)
				gorge_walltop:decelerate(120/160)
				gorge_walltop:y(-sh)
				gorge_walltop:sleep(0)
				gorge_walltop:diffusealpha(0)
				
			end)
			
			m2(34,function()
				gorge_bg2:hidden(1)
			end,true)
			
			m2(34,function()
				char_imho:x(sw/2)
				char_imho:y(sh/2)
				char_imho:basezoomx(.9)
				char_imho:basezoomy(.9)
				char_imho:playcommand('Spawn');
			end)
			
			m2(34,'LetterBoxOn');
			m2(99,'LetterBoxOff');
			m2(195,'LetterBoxOn');
			m2(258,'LetterBoxOff');
			
			m2(35.5,function()
				char_imho:x(sw/2)
				char_imho:y(sh/2)
				char_imho:basezoomx(.9)
				char_imho:basezoomy(.9)
				char_imho:playcommand('SpawnQ');
			end,true)
			
			m2(36,function()
				char_imho:playcommand('Attack');
			end)
			
			m2(66,function()
				gorge_castbg:linear(120/160)
				gorge_castbg:diffuse(.7,.2,.2,1);
			end)
			m2(68,function()
				gorge_castbg:diffuse(.7,.2,.2,1);
			end,true)
			
			m2(68,function()
				char_imho:playcommand('Attack');
			end)
			
			m2(95.75,function()
				char_imho:playcommand('Hide');
			end)
			
			m2(99,function()
				char_imho:playcommand('HideQ');
			end,true)
			
			m2(158,function()
				gorge_walltop:diffusealpha(1)
				gorge_walltop:y(-sh)
				gorge_walltop:accelerate(120/160)
				gorge_walltop:y(0)
			end)
			
			m2(160,function()
			
				gorge_bg2:hidden(0)
			
				gorge_sky1:y(0)
				gorge_clouds:y(sh*-0.5)
				gorge_pyra:y(sh*-0.1)
				gorge_desert:y(0)
				gorge_desert:zoomy(0)
				
				gorge_desert2:y(0)
				gorge_desert2:rotationx(0)
				gorge_desert2:zoomy(0)
				gorge_quad:y(sh/2)
				
				if not slumpo then
					gorge_shaku:decelerate(120/160)
					gorge_shaku:y(sh*0.5 - 180 )
				else
					gorge_angrysun:decelerate(120/160)
					gorge_angrysun:y(sh*0.5 - 180 )
				end
			
				--gorge_sky1:accelerate(120/160)
				--gorge_sky1:y(sh*0.25)
				gorge_sky1:decelerate(120/160)
				gorge_sky1:y(sh*0.5)
				--gorge_clouds:decelerate(120/160)
				--gorge_clouds:y(sh*-0.125)
				gorge_clouds:decelerate(120/160)
				gorge_clouds:y(sh*0.25)
				
				--gorge_pyra:accelerate(120/160)
				--gorge_pyra:y(sh*0.2)
				gorge_pyra:decelerate(120/160)
				gorge_pyra:y(sh*0.5)
				
				--gorge_desert:accelerate(120/160)
				--gorge_desert:y(sh*0.25)
				--gorge_desert:zoomy(0.5)
				gorge_desert:decelerate(120/160)
				gorge_desert:y(sh*0.5)
				gorge_desert:zoomy(1)
				
				gorge_desert2:decelerate(120/160)
				gorge_desert2:y(sh*0.75)
				gorge_desert2:rotationx(-80)
				gorge_desert2:zoomz(4*(SCREEN_WIDTH/640))
				gorge_desert2:zoomtoheight(SCREEN_HEIGHT*0.5)
				
				--gorge_quad:accelerate(120/160)
				--gorge_quad:y(sh)
				gorge_quad:decelerate(120/160)
				gorge_quad:y(sh*1.5)
				
				gorge_walltop:y(0)
				gorge_walltop:decelerate(120/160)
				gorge_walltop:y(sh)
				gorge_walltop:sleep(0)
				gorge_walltop:diffusealpha(0)
				
			end)
			
			m2(192,function()
			
				gorge_sky1:accelerate(180/160)
				gorge_sky1:y(0)
				gorge_clouds:accelerate(180/160)
				gorge_clouds:y(sh*-0.5)
				
				gorge_pyra:accelerate(180/160)
				gorge_pyra:y(sh*-0.1)
				
				gorge_desert:accelerate(180/160)
				gorge_desert:y(0)
				gorge_desert:zoomy(0)
				
				gorge_desert2:accelerate(180/160)
				gorge_desert2:y(sh*0.1)
				gorge_desert2:zoomy(1)
				gorge_desert2:rotationx(0)
				
				gorge_quad:accelerate(180/160)
				gorge_quad:y(sh/2)
				
				if not slumpo then
					gorge_shaku:accelerate(180/160)
					gorge_shaku:y(sh*0.5 - 180 - sh)
				else
					gorge_angrysun:accelerate(180/160)
					gorge_angrysun:y(sh*0.5 - 180 - sh)
				end
				
				gorge_walltop:y(sh)
				gorge_walltop:accelerate(180/160)
				gorge_walltop:y(0)
				gorge_walltop:decelerate(180/160)
				gorge_walltop:y(-sh)
				gorge_walltop:sleep(0)
				gorge_walltop:diffusealpha(0)
				
			end)
			
			m2(196,function()
				char_imho:playcommand('Attack');
				char_imho:playcommand('Spawn');
			end)
			
			m2(196,function()
				gorge_castbg:texcoordvelocity(0,.05*(640/SCREEN_WIDTH))
				gorge_castbg:linear(240/160)
				gorge_castbg:diffuse(.7,.2,.2,1);
			end)
			
			m2(200,function()
				gorge_castbg:texcoordvelocity(0,.05*(640/SCREEN_WIDTH))
				gorge_castbg:diffuse(.7,.2,.2,1);
			end,true)
			
			m2(156,function()
				gorge_castbg:linear(240/160)
				gorge_castbg:diffuse(.7,.2,.2,0);
			end)
			
			m2(256,function()
				char_imho:playcommand('HideQ');
			end)
			
			m2(258,function()
				gorge_castbg:linear(120/160)
				gorge_castbg:diffuse(.7,.2,.2,0);
			end)
			
			m2(195,function()
				gorge_bg2:hidden(1)
			end,true)
			
			m2(257.9,'Static');
			
			me(1,20,80,80,'dark',l,linear)
			m(1,4,'*1000 60 flip, *1000 -200 mini, *1000 tipsy, *1000 drunk',l)
			
			m(1,34,'*1000 100.01 reverse',l,1)
			
			m(1,34,'*1000 150 wave, *1000 100 sudden, *1000 200 suddenoffset, *1000 50 hidden, *1000 -10 hiddenoffset',l)
			m(34,1,'*1000 no wave, *1000 no hallway, *1000 no reverse, *1000 no flip, *1000 no tornado, *1000 no centered, *1000 no sudden, *1000 no hidden, *1000 no mini',l)
			
			--[[
			{159.600,178.800,'*10000 No Drunk,*10000 250% Hallway,*10000 100% Flip,*10000 -100% Tornado,*10000 No Invert,*10000 75% Mini,*10000 -100% Centered,*10000 200% Wave,*10000 Sudden,*10000 200% SuddenOffset,*10000 Hidden,*10000 10% HiddenOffset,*3.3334 No Stealth,*3.3334 No Dark','end',1},
				{159.600,178.800,'*10000 100.001% Reverse,*10000 No Drunk,*10000 250% Hallway,*10000 100% Flip,*10000 -100% Tornado,*10000 No Invert,*10000 75% Mini,*10000 -100% Centered,*10000 200% Wave,*10000 Sudden,*10000 200% SuddenOffset,*10000 Hidden,*10000 10% HiddenOffset,*3.3334 No Stealth,*3.3334 No Dark','end',2},
			]]
			
			
			me(4,20,-40,0,'flip',e,inOutQuad,nil)
			me(4,16,-200,75,'mini',e,outQuad,nil,34)
			me(4,20,100,0,'drunk',e,inOutQuad)
			me(4,20,100,0,'tipsy',e,inOutQuad)
			me(20,32,50,0,'hidden',e,inOutQuad)
			me(4,16,0,-100,'centered',e,outQuad,nil,34)
			
			me(20,32,0,200,'flip',e,inQuad,nil,34)
			me(20,32,0,-200,'tornado',e,inQuad,nil,34)
			
			me(4,16,0,250,'hallway',e,outQuad,nil,34)
			
			me(28,32,0,100,'stealth',e,inOutQuad,nil,34)
			me(28,32,50,100,'dark',e,inOutQuad,nil,34)
			
			me(34,2.5,0,2,'xmod',l,outSine);
			me(34,2,50,0,'stealth',l,outQuad);
			me(34,2,100,50,'dark',l,outQuad);
			
			
			
			--[[
			m(64,2,'*10 30 split, *10 no reverse',l)
			m(64.5,2,'*10 no split, *10 30 reverse',l)
			m(65,2,'*10 -30 split, *10 30 reverse',l)
			m(65.25,2,'*10 no split, *10 no reverse',l)
			m(65.75-.1,2,'*10 30 reverse',l)
			m(66-.1,2,'*10 no reverse',l)
			]]
			
			m2(92,function()
				gorge_aux:x(.6);
				gorge_aux:decelerate(45/160)
				gorge_aux:x(0);
				gorge_aux:sleep(0);
				gorge_aux:x(-.6);
				gorge_aux:decelerate(45/160)
				gorge_aux:x(0);
				gorge_aux:sleep(0);
				gorge_aux:x(.6);
				gorge_aux:decelerate(45/160)
				gorge_aux:x(0);
				gorge_aux:sleep(0);
				gorge_aux:x(-.6);
				gorge_aux:decelerate(45/160)
				gorge_aux:x(0);
				gorge_aux:sleep(0);
				gorge_aux:x(.6);
				gorge_aux:decelerate(30/160)
				gorge_aux:x(0);
				gorge_aux:sleep(0);
				gorge_aux:x(-.6);
				gorge_aux:decelerate(30/160)
				gorge_aux:x(0);
				gorge_aux:sleep(0);
			end)
			
			simple_m0d(92,50,.2,'stealth');
			simple_m0d(92.75,50,.2,'stealth');
			simple_m0d(93.5,50,.2,'stealth');
			simple_m0d(94.25,50,.2,'stealth');
			simple_m0d(95,50,.1,'stealth');
			simple_m0d(95.5,50,.1,'stealth');
			
			for i=68,95,4 do
				
				if i~=64 and i ~= 80 then
					
					if i~=84 then
						me(i-.5,.5,0,100,'invert',l,inOutSine,nil,.5)
					end
					me(i-.5+1,.5,100,200,'invert',l,inOutSine,nil,.5)
					me(i-.5+2,.5,200,300,'invert',l,inOutSine,nil,.5)
					me(i-.5+3,.5,300,400,'invert',l,inOutSine,nil,1)
					me(i-.5+4,0,400,0,'invert',l,inOutSine,nil,.5)
				
				end
				
			end
			
			for i=0,6 do
				m(83+i*0.1666,.1666,'*10000 '..(100*(i+1))..' invert',l)
			end
			
			for i=232,243,4 do
				
				if i~=64 and i ~= 80 then
					
					if i~= 232 then
						me(i-.5,.5,0,100,'invert',l,inOutSine,nil,.5)
					end
					me(i-.5+1,.5,100,200,'invert',l,inOutSine,nil,.5)
					me(i-.5+2,.5,200,300,'invert',l,inOutSine,nil,.5)
					me(i-.5+3,.5,300,400,'invert',l,inOutSine,nil,1)
					me(i-.5+4,0,400,0,'invert',l,inOutSine,nil,.5)
				
				end
				
			end
			
			for i=244,255,4 do
				
				if i~=64 and i ~= 80 then
					
					me(i-.5,.5,0,-100,'invert',l,inOutSine,nil,.5)
					me(i-.5+1,.5,-100,-200,'invert',l,inOutSine,nil,.5)
					me(i-.5+2,.5,-200,-300,'invert',l,inOutSine,nil,.5)
					me(i-.5+3,.5,-300,-400,'invert',l,inOutSine,nil,1)
					me(i-.5+4,0,-400,0,'invert',l,inOutSine,nil,.5)
				
				end
				
			end
			
			
			
			m(84,.5,'*10000 100 invert',l)
			
			m(80,1,'*10 alternate, *10 no reverse',l)
			m(80.5,1,'*10 no alternate, *10 no reverse',l)
			m(80.75,1,'*10 -100 alternate, *10 99.9 reverse',l)
			m(81.25,1,'*10 no alternate, *10 no reverse',l)
			m(81.5,1,'*10 100 alternate, *10 no reverse',l)
			m(82,1,'*10 no alternate, *10 99.9 reverse',l)
			m(82.25,1,'*10 -100 alternate, *10 99.9 reverse',l)
			m(82.75,1,'*10 no alternate, *10 no reverse',l)
			--m(83,1,'*10 no alternate, *10 no reverse',l)
			
			for i=52,60,4 do
				me(i+0-.5,1,0,99.9,'reverse',l,inOutQuad,1,1.5)
				me(i+1-.5,1,0,99.9,'reverse',l,inOutQuad,2,1.5)
				me(i+2-.5,1,99.9,0,'reverse',l,inOutQuad,1)
				me(i+3-.5,1,99.9,0,'reverse',l,inOutQuad,2)
			end
			
			for pn=1,2 do
				for i=36,60,4 do
					m(i+0,.75,'*10 '..(25+25)..' stealth',l,pn)
					m(i+.75,.75,'*10 '..(25-25)..' stealth',l,pn)
					m(i+1.5,.75,'*10 '..(25+25)..' stealth',l,pn)
					m(i+2.25,.75,'*10 '..(25-25)..' stealth',l,pn)
					m(i+3,.5,'*10 '..(25+25)..' stealth',l,pn)
					m(i+3.5,.5,'*10 '..(25-25)..' stealth',l,pn)
					
					if i <= 48 then
						m(i+0,.75,'*3 '..(15+15*(pn*2-3))..' brake',l,pn)
						m(i+.75,.75,'*3 '..(15-15*(pn*2-3))..' brake',l,pn)
						m(i+1.5,.75,'*3 '..(15+15*(pn*2-3))..' brake',l,pn)
						m(i+2.15,.75,'*3 '..(15-15*(pn*2-3))..' brake',l,pn)
						m(i+3,.5,'*3 '..(15+15*(pn*2-3))..' brake',l,pn)
						m(i+3.5,.5,'*3 '..(15-15*(pn*2-3))..' brake',l,pn)
					else
						m(i+0,.75,'*3 '..(10+10*(pn*2-3))..' brake',l,pn)
						m(i+.75,.75,'*3 '..(10-10*(pn*2-3))..' brake',l,pn)
						m(i+1.5,.75,'*3 '..(10+10*(pn*2-3))..' brake',l,pn)
						m(i+2.10,.75,'*3 '..(10-10*(pn*2-3))..' brake',l,pn)
						m(i+3,.5,'*3 '..(10+10*(pn*2-3))..' brake',l,pn)
						m(i+3.5,.5,'*3 '..(10-10*(pn*2-3))..' brake',l,pn)
					end
					
				end
			end
			
			m2(64,function()
				for pn=1,2 do
					local a = Plr(pn)
					if a then
						a:z(0)
					end
				end
			end,true)
			
			m2(96,function()
				for pn=1,2 do
					local a = Plr(pn)
					if a then
						a:skewx(0)
					end
				end
			end,true)
			
			m(64-.1,1,'*5 -15 split, *5 -15 cross, *5 -15 alternate, *10 30 reverse',l)
			m(64.5-.1,1,'*5 -30 split, *5 0 cross, *5 0 alternate, *10 30 reverse',l)
			m(65-.1,1,'*5 -15 split, *5 15 cross, *5 -15 alternate, *10 30 reverse',l)
			m(65.25-.1,1,'*5 0 split, *5 0 cross, *5 0 alternate, *10 30 reverse',l)
			m(65.75-.1,1,'*5 0 split, *5 0 cross, *5 0 alternate, *10 0 reverse',l)
			
			m(66-.05,.5,'*20 150 invert',l)
			m(66.333-.05,.5,'*20 100 invert',l)
			m(66.666-.05,.5,'*20 50 invert',l)
			m(67-.05,.5,'*20 0 invert',l)
			
			
			m2(96,function()
				for pn=1,2 do
					local a = Plr(pn)
					if a then
						a:stoptweening()
						a:x(sw/2 + 128*(pn*2-3))
						a:linear(.1)
						a:x(sw/2 + 32*(pn*2-3))
					end
				end
			end)
			
			m2(99,function()
				for pn=1,2 do
					local a = Plr(pn)
					if a then
						a:x(sw/2 + 32*(pn*2-3))
						a:z(-300*(pn*2-3))
						a:zoomz(3)
						a:sleep(30/160)
						a:accelerate(30/160)
						a:zoomz(1)
						a:z(0)
						a:sleep(0)
						a:x(sw/2 + 32*(pn*2-3))
					end
				end
			end)
			
			m2(100,function()
				for pn=1,2 do
					local a = Plr(pn)
					if a then
						a:zoomz(1)
						a:z(0)
						a:sleep(0)
						a:x(sw/2 + 32*(pn*2-3))
					end
				end
			end,true)
			
			for i=0,3 do
				switcheroo_add(96.5+i*0.5-.08,'ludr',15,.25)
				switcheroo_add(96.75+i*0.5-.08,'ldur',15,.25)
			end
			
			switcheroo_add(98.5-.08,'ludr',15,.5)
			
			m(96,3,'*15 150 mini',l)
			m(99,1,'*10000 no mini',l)
			
			me(96,2,0,100,'stealth',l,linear,nil,1)
			me(96,2,50,100,'dark',l,linear,nil,1)
			
			simple_m0d(99,50,.1,'stealth')
			simple_m0d(99,50,.1,'dark')
			
			me(99,1,100,0,'incoming',l,inQuad,1)
			me(99,1,100,0,'space',l,inQuad,2)
			
			switcheroo_width = 2
			switcheroo_add(99,'ldur',10000,2,1)
			switcheroo_add(99,'ldur',10000,2,2)
			
			
			
			--column swaps from columns.xml
				--1 - LDUR
				--2 - DLRU
				--3 - URLD
				--4 - RUDL
				--5 - LLDDUURR
				--6 - DULRRLUD (dlru + urld + ayakashi)
				--7 - UDRLLRDU (urld + dlru + ayakashi)
				--8 - RRUUDDLL
			
			local lastc = -1
			
			for i=1,table.getn(columns) do
				local b = columns[i][1]
				local c = columns[i][2]
				local d = columns[i][3]
				
				switcheroo_width = 2
				
				if b >= 131 and b < 132 then
					while rng == lastc do
						rng = math.random(0,7)
					end
					lastc = rng
					c = rng
				end
				
				if d == 1 then
					if c == 0 then
						switcheroo_add(b,'ldur',10000,2,1)
						switcheroo_add(b,'ldur',10000,2,2)
					elseif c == 1 then
						switcheroo_add(b,'dlru',10000,2,1)
						switcheroo_add(b,'dlru',10000,2,2)
					elseif c == 2 then
						switcheroo_add(b,'ldur',10000,2,1)
						switcheroo_add(b,'dlru',10000,2,2)
					elseif c == 3 then
						switcheroo_add(b,'rudl',10000,2,1)
						switcheroo_add(b,'urld',10000,2,2)
					elseif c == 4 then
						switcheroo_add(b,'ldur',10000,2,1)
						switcheroo_add(b,'rudl',10000,2,2)
					elseif c == 5 then
						switcheroo_add(b,'dlru',10000,2,1)
						switcheroo_add(b,'urld',10000,2,2)
					elseif c == 6 then
						switcheroo_add(b,'urld',10000,2,1)
						switcheroo_add(b,'dlur',10000,2,2)
					elseif c == 7 then
						switcheroo_add(b,'rudl',10000,2,1)
						switcheroo_add(b,'rudl',10000,2,2)
					end
				else
					if c == 0 then
						switcheroo_add(b-.1,'ldur',10,2,1)
						switcheroo_add(b-.1,'ldur',10,2,2)
						m(b-.1,2,'*5 no stealth',l,1)
						m(b-.1,2,'*5 no stealth',l,2)
					elseif c == 1 then
						switcheroo_add(b-.1,'ldur',10,2,1)
						switcheroo_add(b-.1,'dlru',10,2,2)
						m(b-.1,2,'*5 no stealth',l,1)
						m(b-.1,2,'*5 50 stealth',l,2)
					elseif c == 2 then
						switcheroo_add(b-.1,'rudl',10,2,1)
						switcheroo_add(b-.1,'ldur',10,2,2)
						m(b-.1,2,'*5 50 stealth',l,1)
						m(b-.1,2,'*5 no stealth',l,2)
					elseif c == 3 then
						switcheroo_add(b-.1,'ldur',10,2,1)
						switcheroo_add(b-.1,'urld',10,2,2)
						m(b-.1,2,'*5 no stealth',l,1)
						m(b-.1,2,'*5 50 stealth',l,2)
					elseif c == 4 then
						switcheroo_add(b-.1,'urld',10,2,1)
						switcheroo_add(b-.1,'ldur',10,2,2)
						m(b-.1,2,'*5 50 stealth',l,1)
						m(b-.1,2,'*5 no stealth',l,2)
					elseif c == 5 then
						switcheroo_add(b,'dlru',10000,2,1)
						switcheroo_add(b,'dlru',10000,2,2)
					end
				end
				
			end
			
			for i=0,3 do
				me(100+i*8,7,0,100,'brake',l,inQuad)
				me(100+i*8+7,1,100,0,'brake',l,inQuad)
			end
			for i=4,7 do
				me(100+i*8,7,0,50,'brake',l,inQuad)
				me(100+i*8+7,1,50,0,'brake',l,inQuad)
			end
			
			for i=0,7 do
				m2(100+8*i,function()
					gorge_vib:x(30)
					gorge_vib:y(30)
					gorge_vib:linear(60/160)
					gorge_vib:x(0)
					gorge_vib:y(0)
				end)
			end
			
			me(107+8*0,1,0,99.9,'reverse',l,inExpo,nil,8)
			me(107+8*1,1,99.9,0,'reverse',l,inExpo,nil,8)
			me(107+8*2,1,0,99.9,'reverse',l,inExpo,nil,8)
			me(107+8*3,1,99.9,0,'reverse',l,inExpo,nil,8)
			me(107+8*4,1,0,99.9,'reverse',l,inExpo,nil,8)
			me(107+8*5,1,99.9,0,'reverse',l,inExpo,nil,8)
			me(107+8*6,1,0,99.9,'reverse',l,inExpo,nil,8)
			
			for i=0,5 do
				if i~= 3 then
					for j=0,12 do
						local amt = 100-200*j/12
						if i > 3 then
							amt = amt*1.5
						end
						m(68+4*i+j*0.25,1,'*10000 '..amt..' incoming',l)
					end
					if i <= 3 then
						m(71.5+4*i,1,'*10 no incoming',l)
					else
						m(71.5+4*i,1,'*15 no incoming',l)
					end
				end
			end
			
			--don't mix your drinks kids
			for i=1,table.getn(alcohol2) do
				table.insert(alcohol,alcohol2[i])
			end
			
			for i=1,table.getn(alcohol)-1 do
				
				local b = alcohol[i][1]
				local c = alcohol[i][2]
				local d = alcohol[i][3]
				local dur = alcohol[i+1][1]-b
				
				local md = 'drunk'
				
				if math.mod(c,2) == 0 then
					amt = -200
				else
					amt = 200
				end
				
				if c > 1 then
					md = 'tipsy'
					amt = amt*1.5;
				end
				
				local xamt = amt
				if d == 'M' then
					amt = 0
				end
				
				for pn=1,2 do
					m(b-.1,dur,'*'..(math.abs(amt)/10)..' '..(amt*(pn*2-3))..' '..md,l,pn)
				end
				if amt == 0 then
					simple_m0d2(b-.1,xamt*0.6,.3,md)
				end
				
			end
			
			
			m2(160,function()
				gorge_judaux:x( 128 )
				gorge_judaux:z( 1 )
				gorge_judaux:decelerate( 240/160 )
				gorge_judaux:x( 40 )
				gorge_judaux:z( 0.33 )
			end)
			m2(164,function()
				gorge_judaux:x( 40 )
				gorge_judaux:z( 0.33 )
			end,true)
			
			
			
			m2(160,function()
				gorge_judy:y( -175 )
				gorge_judy:accelerate(90/160)
				gorge_judy:y( -87.5 + sh*0.0 )
				gorge_judy:z( sh*0.1 )
				gorge_judy:decelerate(90/160)
				gorge_judy:y( 0 + sh*0.0 )
				gorge_judy:z( sh*0.2 )
			end,true)
			
			m2(195,function()
				gorge_judaux:x( 0 )
				gorge_judaux:z( 1 )
				gorge_judy:y( -175 )
				gorge_judy:z( 0 )
			end,true)
			
			m2(256,function()
				gorge_judaux:x( 160 )
			end)
			
			m2(288,function()
				gorge_judaux:decelerate(180/160)
				gorge_judaux:x(200)
				
				gorge_judy:accelerate(120/160)
				gorge_judy:y( -87.5 )
				gorge_judy:decelerate(120/160)
				gorge_judy:y( 0 )
			end,true)
			
			me(160,161.5,99.9,99.9,'reverse',e,inQuad,1,164)
			me(160,164,0,65,'centered',e,inOutQuad,1)
			me(160,161.5,99.9,99.9,'reverse',e,inQuad,2,164)
			me(160,164,0,100,'centered',e,inOutQuad,2)
			
			me(160,164,0,100,'incoming',e,inOutQuad,1)
			me(160,164,0,100,'space',e,inOutQuad,2)
			
			me(160,164,0,180,'mini',e,inOutQuad,1,164)
			me(160,164,0,180,'mini',e,inOutQuad,2,164)
			
			m(162,195,'*2 100 sudden, *10000 -50 suddenoffset',e,1)
			m(162,195,'*2 100 sudden, *10000 -40 suddenoffset',e,2)
			
			m(164,195,'*10000 99.9 reverse, *10000 180 mini, *10000 100 incoming',e,1)
			
			m(164,195,'*10000 180 mini, *10000 100 space',e,2)
			
			m(164,195,'*10000 65 centered',e,1)
			m(164,195,'*10000 99.9 reverse, *10000 100 centered',e,2)
			
			
			
			m2(160,function()
				local pn = 1
				local a = Plr(pn)
				if a then
					a:accelerate(90/160)
					a:x(sw/2)
					a:z(250)
					a:y(sh*0.55)
					a:zoomx(2)
					a:zoomy(1.25)
					a:zoomz(1.25)
					a:decelerate(150/160)
					a:y(sh*0.6)
					a:z(500)
					a:zoomx(4)
					a:zoomy(1.5)
					a:zoomz(1.5)
				end
			end,195)
			
			m2(160,function()
				local pn = 2
				local a = Plr(pn)
				if a then
					a:accelerate(90/160)
					a:x(sw/2)
					a:z(-200)
					a:y(sh*0.45)
					a:zoomx(2)
					a:zoomy(1.25)
					a:zoomz(1.25)
					a:decelerate(150/160)
					a:y(sh*0.3)
					a:z(-400)
					a:zoomx(4)
					a:zoomy(1.5)
					a:zoomz(1.5)
				end
			end,195)
			
			--me(195,1,100,0,'incoming',l,outQuad,1)
			--me(195,1,100,0,'space',l,outQuad,2)
			
			--me(195,196,0,-50,'flip',e,outQuad,nil,256)
			--me(195,1,180,0,'mini',l,outQuad)
			
			me(195,196,-50,40,'suddenoffset',e,outQuad,1,256)
			me(195,196,-40,40,'suddenoffset',e,outQuad,2,256)
			
			--me(195,196,2,1.25,'xmod',e,outQuad,nil,256)
			
			--me(195,2,100,0,'reverse',l,outQuad,1)
			
			
			
			local function fastzoom(b,len)
				local d = len
				m2(b,function()
					for pn=1,2 do
						local a = Plr(pn)
						if a then
							a:stoptweening()
							a:zoomx(0)
							a:zoomy(0)
							a:zoomz(0)
							a:linear(len*60/160)
							a:zoomx(4)
							a:zoomy(1.5)
							a:zoomz(1.5)
						end
					end
				end)
			end
			local function fastzoom2(b,len)
				local d = len
				m2(b,function()
					--for pn=1,2 do
						local a = gorge_aux3
						if a then
							a:stoptweening()
							a:x(0)
							a:linear(len*60/160)
							a:x(1)
						end
					--end
				end)
			end
			
			fastzoom(192,.166)
			fastzoom(192.166,.166)
			fastzoom(192.333,.166)
			fastzoom(192.5,.5)
			fastzoom(193,.5)
			fastzoom(193.5,.5)
			
			m2(194,function()
				for pn=1,2 do
					local a = Plr(pn)
					if a then
						a:accelerate(1*60/160)
						a:zoomx(0)
						a:zoomy(0)
						a:zoomz(0)
					end
				end
			end)
			
			m2(195,function()
				for pn=1,2 do
					local a = Plr(pn)
					if a then
						a:sleep(0)
						a:x(sw/2)
						a:y(sh/2)
						a:z(0)
						a:zoomx(1)
						a:zoomy(1)
						a:zoomz(2)
						--a:rotationx(40*(pn*2-3))
					end
				end
			end)
			
			--b195 b196
			--me(195,1,0,30,'hallway',l,outQuad,pn)
			
			m(164,3.9,'*0.253 300 centered',l,1)
			m(164,7.9,'*0.253 300 centered',l,2)
			
			for i=168,192,8 do
				
				if i == 192 then
					m(i-0,3.9,'*0.253 350 centered',l,1)
					
					m(i-2,2,'*1.5 stealth, *1.5 dark',l,1)
					m(i-0,1,'*3 no stealth, *3 no dark',l,1)
					--[[
					m(i+4-2,2,'*1.5 stealth, *1.5 dark',l,2)
					m(i+4,1,'*3 no stealth, *3 no dark',l,2)
					
					m(i-6,2,'*1.5 stealth, *1.5 dark',l,1)
					m(i-6,1,'*3 no stealth, *3 no dark',l,1)
					]]
				else
					m(i,7.9,'*0.253 300 centered',l,1)
					m(i+4,7.9,'*0.253 300 centered',l,2)
					
					m(i-2,4,'*1.5 stealth, *1.5 dark',l,1)
					m(i+1,1,'*3 no stealth, *3 no dark',l,1)
					m(i+4-2,4,'*1.5 stealth, *1.5 dark',l,2)
					m(i+5,1,'*3 no stealth, *3 no dark',l,2)
				end
				
			end
			
			--m(192,195,'stealth,dark',e)
			
			--m(196,256,'*10000 -100 centered',e,1)
			--m(196,256,'*10000 reverse, *10000 -100 centered',e,2)
			
			me(195,1.5,0,2,'xmod',l,outSine);
			me(195,1.5,50,0,'stealth',l,outQuad);
			me(195,1.5,100,50,'dark',l,outQuad);
			
			m(195,4,'*1000 no centered, *1000 no reverse, *1000 no flip, *1000 overhead, *1000 no mini',l)
			
			local fl = 1
			for i=196,210 do
				simple_m0d2(i-.05,60,.24,'brake')
				simple_m0d2(i-.05,20*(0+(i-196)/14)*fl,.24,'dizzy')
				fl = fl*-1;
			end
			for i=212,220 do
				simple_m0d2(i-.05,60,.24,'brake')
				simple_m0d2(i-.05,20*(0.5+(i-196)/14)*fl,.24,'dizzy')
				fl = fl*-1;
			end
			
			me(211,.5,0,150,'brake',l,outCubic)
			me(211.5,.5,150,0,'brake',l,inCubic)
			
			--me(211,.5,0,800,'bumpy',l,outCubic)
			--me(211.5,.5,800,0,'bumpy',l,inCubic)
			
			for i=232,242 do
				simple_m0d2(i-.1,60,.24,'brake')
			end
			
			me(243,.5,0,150,'brake',l,outCubic)
			me(243.5,.5,150,0,'brake',l,inCubic)
			
			--me(243,.5,0,800,'bumpy',l,outCubic)
			--me(243.5,.5,800,0,'bumpy',l,inCubic)
			
			local function toms(b,d,t)
				--simple_m0d(b,d,.4,'drunk')
				--simple_m0d(b,t,.4,'tipsy')
				simple_m0d(b,d,.4,'bumpy')
			end
			
			toms(212.75,100,100)
			toms(213.5,-100,100)
			toms(214.5,100,-100)
			toms(215.5,-100,-100)
			
			toms(4+212.75,100,100)
			toms(4+213.5,-100,100)
			toms(4+214.5,100,-100)
			toms(4+215.5,-100,-100)
			
			for pn=1,2 do
				me(161.5,2.5,0,628*(pn*2-3),'dizzy',l,inQuad,pn)
				me(164,8,628*(pn*2-3),0,'dizzy',l,outQuad,pn)
			end
			
			--m(195,64,'*10000 stealth',l,2)
			
			if FUCK_EXE then
				m(160,195,'*1000 -100 drawsizeback',e);
				m(160,256,'stealthpastreceptors',e);
			end
			
			m(256,4,'*1000 no reverse, *10000 no flip, *10000 no centered',l)
			
			m(256,320,'*1000 1 bumpy',e)
			
			me(256,258,200,300,'invert',e,linear,1)
			me(256,258,-200,-300,'invert',e,linear,2)	
			
			me(258,260,300,350,'invert',e,linear,1)
			me(258,260,-300,-250,'invert',e,linear,2)
			
			m2(256,'RedFlash');
			
			m2(256,function()
				for pn=1,2 do
					local a = Plr(pn)
					if a then
						a:x(sw/2)
						--a:skewx(0)
						a:z(0)
						a:rotationz((pn*2-3)*10)
					end
				end
			end)
			
			m2(256.5,function()
				for pn=1,2 do
					local a = Plr(pn)
					if a then
						a:rotationz((pn*2-3)*-10)
					end
				end
			end)
			
			m2(257,function()
				for pn=1,2 do
					local a = Plr(pn)
					if a then
						a:rotationz((pn*2-3)*5)
						a:sleep(15/160)
						a:rotationz((pn*2-3)*-5)
						a:sleep(15/160)
						a:rotationz((pn*2-3)*5)
						a:sleep(15/160)
						a:rotationz((pn*2-3)*-5)
						a:sleep(15/160)
						a:rotationz((pn*2-3)*0)
					end
				end
			end)
			
			m2(258,function()
				for pn=1,2 do
					local a = Plr(pn)
					if a then
						a:sleep(0)
						a:addx(-sw/2)
						a:addy(-sh/2)
						a:linear(120/160)
						a:skewx(-0.24*(pn*2-3))
					end
				end
				if SongBackground then
					SongBackground:addx(-sw/2)
					SongBackground:addy(-sh/2)
				end
				if SongForeground then
					SongForeground:addx(-sw/2)
					SongForeground:addy(-sh/2)
				end
				if screen then
					screen:addx(sw/2)
					screen:addy(sh/2)
					
					screen:decelerate(.16)
					screen:skewx(.4*2)
					screen:rotationz(-10*-1)
					screen:accelerate(.08)
					screen:skewx(-.2*2)
					screen:rotationz(10*-1)
					screen:decelerate(.15)
					screen:skewx(-.8*2)
					screen:rotationz(30*-1)
					screen:accelerate(.08)
					screen:skewx(-.1*2)
					screen:rotationz(5*-1)
					screen:decelerate(.15)
					screen:skewx(.6*2)
					screen:rotationz(-20*-1)
					screen:accelerate(.08)
					screen:skewx(0)
					screen:rotationz(0)
					
				end
			end)
			
			m2(260,function()
				if SongBackground then
					SongBackground:addx(sw/2)
					SongBackground:addy(sh/2)
				end
				if SongForeground then
					SongForeground:addx(sw/2)
					SongForeground:addy(sh/2)
				end
				if screen then
					screen:sleep(0)
					screen:addx(-sw/2)
					screen:addy(-sh/2)
				end
			end)
			
			m2(260,function()
				gorge_aux:x(-1)
				gorge_aux:accelerate(120/160)
				gorge_aux:x(0)
				gorge_aux:decelerate(120/160)
				gorge_aux:x(1)
				gorge_aux:sleep(240/160)
				gorge_aux:accelerate(120/160)
				gorge_aux:x(0)
				gorge_aux:decelerate(120/160)
				gorge_aux:x(-1)
				gorge_aux:sleep(240/160)
				gorge_aux:accelerate(120/160)
				gorge_aux:x(0)
				gorge_aux:decelerate(120/160)
				gorge_aux:x(1)
				gorge_aux:sleep(240/160)
				gorge_aux:accelerate(120/160)
				gorge_aux:x(0)
				gorge_aux:decelerate(120/160)
				gorge_aux:x(-1)
				gorge_aux:accelerate(120/160)
				gorge_aux:x(-0.5)
				gorge_aux:decelerate(120/160)
				gorge_aux:x(0)
			end)
			
			--[[
			mod_wiggle(288-.1,7,4,200,1.5,'drunk')
			
			simple_m0d2(290-.1,200,.3,'tipsy')
			
			mod_wiggle(290.5-.1,2,4,-200,1.5,'tipsy')
			mod_wiggle(291.5-.1,3,4,200,1.5,'drunk')
			]]
			
			m2(272-.1,function()
				gorge_aux2:linear(.1)
				gorge_aux2:x(60)
				gorge_aux2:linear(120/160-.1)
				gorge_aux2:x(1)
				gorge_aux2:sleep(0)
				gorge_aux2:y(360)
				gorge_aux2:decelerate(120/160)
				gorge_aux2:y(0)
			end)
			
			me(292,294,0,-100,'flip',e,outQuad,nil,320)
			me(292,294,0,500,'drunk',e,outQuad,nil,320)
			me(292,296,0,100,'stealth',e,linear,nil,320)
			me(292,296,50,100,'dark',e,linear,nil,320)
			
			m2(292,function()
				for pn=1,2 do
					local a = Plr(pn)
					if a then
						a:decelerate(240/160)
						a:skewx(0)
					end
				end
			end)
			
			--[[
			m(256,267,'*1000 100 alternate, *1000 no reverse',e,1)
			m(256,267,'*1000 -100 alternate, *1000 99.9 reverse',e,2)
			]]
			
			me(258,260,0,30,'mini',e,linear,nil,999);
			--me(252,256,0,50,'reverse',e,linear)
			m(258,999,'sudden, *1000 100 suddenoffset',e)
			
			me(256+2,258+2,0,84,'alternate',e,linear,1,267)
			me(256+2,258+2,0,8,'reverse',e,linear,1,267)
			
			me(256+2,258+2,0,-84,'alternate',e,linear,2,267)
			me(256+2,258+2,0,92,'reverse',e,linear,2,267)
			
			m(267-.1,267.5,'*10 0 alternate, *10 92 reverse',e,1)
			m(267-.1,267.5,'*10 0 alternate, *10 8 reverse',e,2)
			m(267.5-.1,275,'*10 -84 alternate, *10 92 reverse',e,1)
			m(267.5-.1,275,'*10 84 alternate, *10 8 reverse',e,2)
			
			m(275-.1,275.5,'*10 0 alternate, *10 8 reverse',e,1)
			m(275-.1,275.5,'*10 0 alternate, *10 92 reverse',e,2)
			m(275.5,283,'*10 84 alternate, *10 8 reverse',e,1)
			m(275.5,283,'*10 -84 alternate, *10 92 reverse',e,2)
			
			me(283,284,92,-84,'alternate',e,outQuad,1,320)
			me(283,284,8,92,'reverse',e,outQuad,1,320)
			me(283,284,-84,84,'alternate',e,outQuad,2,320)
			me(283,284,92,8,'reverse',e,outQuad,2,320)
			
			simple_m0d(224,50,.15,'brake')
			simple_m0d(224.5,50,.15,'brake')
			simple_m0d(225,50,.15,'brake')
			simple_m0d(225.5,50,.15,'brake')
			
			mod_wiggle(226,2,4,300,3,'drunk');
			
			mod_wiggle(220.5,7,4,200,2,'drunk');
			
			--[[
			m(195.5,219.5,'*1000 300 beat',e,1);
			m(195.5,219.5,'*1000 -300 beat',e,2);
			]]
			
			
			
			m2(224,function()
				for pn=1,2 do
					local a = Plr(pn)
					if a then
						a:z(0)
					end
				end
			end)
			
			m2(225,function()
				screen:accelerate(30/160)
				screen:skewx(-2)
				screen:addx(sw/1.414)
				screen:decelerate(60/160)
				screen:skewx(0)
				screen:addx(-sw/1.414)
			end)
			
			for i=0,1 do
				m2(244+4*i,function()
					gorge_aux:x(.6)
					gorge_aux:decelerate(90/160)
					gorge_aux:x(0)
					gorge_aux:sleep(30/160)
					gorge_aux:x(-.6)
					gorge_aux:decelerate(90/160)
					gorge_aux:x(0)
				end)
			end
			
			m2(232,function()
				gorge_pos:accelerate(240/160)
				gorge_pos:addx(1024*0.275)
				gorge_pos:linear(240/160)
				gorge_pos:addx(1024*0.45)
				gorge_pos:decelerate(240/160)
				gorge_pos:addx(1024*0.275)
			end)
			m2(244,function()
				gorge_pos:accelerate(3*240/160)
				gorge_pos:addx(-3072) --hi colgate
			end)
			
			for i=0,3 do
				simple_m0d(244+2*i,50,.4,'stealth');
			end
			
			local tab = {0,.75,1.5,2,2.75,3.5,4}
			
			local fl2 = 1
			
			for i=1,table.getn(tab)-1 do
				local b = tab[i]
				local b2 = tab[i+1]
				local d = b2-b
				if math.mod(i,2) == 0 then
					m2(b+252,function()
						gorge_aux:sleep(0)
						--gorge_aux:x(.6)
						gorge_aux:decelerate(d*50/160)
						gorge_aux:x(0)
					end)
					simple_m0d(b+252,50,.3*d,'stealth',1)
				else
					m2(b+252,function()
						gorge_aux:sleep(0)
						--gorge_aux:x(-.6)
						gorge_aux:decelerate(d*50/160)
						gorge_aux:x(0)
					end)
					simple_m0d(b+252,50,.3*d,'stealth',2)
				end
				
			end
			
			--[[
			me(227,1.5,0,2,'xmod',l,outSine);
			me(227,1.5,50,0,'stealth',l,outQuad);
			me(227,1.5,100,50,'dark',l,outQuad);
			]]
			me(227,1,200,0,'invert',l,outQuart,nil,nil);
			me(227,1.5,50,0,'stealth',l,linear);
			me(227,2,0.5,2,'xmod',l,outQuad);
			me(227,4,300,0,'drunk',l,outElastic,nil,nil,1,.5);
			
			fastzoom2(228,.5)
			fastzoom2(228.5,.25)
			fastzoom2(228.75,.25)
			fastzoom2(229,.5)
			
			fastzoom2(229.5,.25)
			fastzoom2(229.75,.5)
			fastzoom2(230.25,.25)
			fastzoom2(230.5,.5)
			fastzoom2(231,.5)
			
			
			
			m(265-.1,1,'*40 300 bumpy',l)
			m(265.5-.1,1,'*80 -300 bumpy',l)
			m(266-.1,1.1,'*80 300 bumpy',l)
			
			me(266,1,300,0,'bumpy',l,linear)
			
			m(280-.1,.5,'*40 300 bumpy',l)
			m(280.5-.1,.5,'*40 no bumpy',l)
			mod_wiggle(281,4,2,200,1,'drunk');
			
			local fl = 1
			for i=260,287,2 do
				mod_onebeat(i,500*fl)
				fl = fl*-1
			end
			
			simple_m0d(288,400,.2,'bumpy');
			simple_m0d(288.75,400,.2,'bumpy');
			simple_m0d(289.5,400,.1,'bumpy');
			simple_m0d(290,400,.1,'bumpy');
			
			mod_wiggle(290.5,2,4,600,2,'bumpy')
			mod_wiggle(291.5,2,4,600,2,'bumpy')
			
			me(292,294,50,0,'invert',e,outQuad)
			me(292,294,600,0,'bumpy',e,outQuad)
			
			gorge_flicker = 1;
			
			if slumpo then
				m(164,180,'50 bumpy, drunk',e)
			else
				m(172,180,'30 bumpy, 40 drunk',e)
			end
			
			
---------------------------------------------------------------------------------------
----------------------Sort the actions table-------------------------------------------
---------------------------------------------------------------------------------------
			
			function modtable_compare(a,b)
				return a[1] < b[1]
			end
			
			if table.getn(mod_actions) > 1 then
				table.sort(mod_actions, modtable_compare)
			end
			
			self:queuecommand('Update');
			
		end"
		
		UpdateCommand="%function(self)

			if GAMESTATE:GetSongBeat()>=0 and not checked then
			
				local ThingsToGrab = {'LifeP1','LifeP2','ScoreP1','ScoreP2','BPMDisplay','LifeFrame','ScoreFrame',
										'Lyrics','SongBackground','SongForeground','Overlay','Underlay'}
				local ThingsToHide = {'LifeP1','LifeP2','ScoreP1','ScoreP2','BPMDisplay','LifeFrame','ScoreFrame','Overlay','Underlay'}
				
				for i,v in ipairs(ThingsToGrab) do
					_G[v] = SCREENMAN:GetTopScreen():GetChild(v) or nil
				end
				
				for i,v in ipairs(ThingsToHide) do
					if _G[v] then _G[v]:hidden(1) end
				end
				
				table.insert(mod_plr,SCREENMAN:GetTopScreen():GetChild('PlayerP1'));
				table.insert(mod_plr,SCREENMAN:GetTopScreen():GetChild('PlayerP2'));
				
				--name players, judgment and combo
				for pn=1,2 do
					_G['P'..pn] = SCREENMAN:GetTopScreen():GetChild('PlayerP'..pn) or nil;
					if _G['P'..pn] then
						_G['jud'..pn] = _G['P'..pn]:GetChild('Judgment');
						_G['com'..pn] = _G['P'..pn]:GetChild('Combo');
					end
				end
				
				screen = SCREENMAN:GetTopScreen();
				checked = true; --let this only run once
				
				screen:vibrate()
				screen:effectmagnitude(0,0,0)
				
			end

			local beat = GAMESTATE:GetSongBeat()
			
			
---------------------------------------------------------------------------------------
----------------------Begin table handlers---------------------------------------------
---------------------------------------------------------------------------------------
			
			disable = false;
			if disable ~= true and beat > mod_firstSeenBeat+0.1 and checked then
			
				gorge_flicker = gorge_flicker*-1
				
				-----------------------
				-- Player mod resets --
				-----------------------
				if beat > mod_firstSeenBeat+0.1 then -- performance coding!! --
					for i=1,2 do
						mod_do('clearall',i)
					end
				end
				
				------------------------------------------------------------------------------
				-- custom mod reader by TaroNuke edited by WinDEU and re-stolen by TaroNuke --
				------------------------------------------------------------------------------
				if beat > mod_firstSeenBeat+0.1 then -- performance coding!! --
					for i,v in pairs(mods) do
						if v and table.getn(v) > 3 and v[1] and v[2] and v[3] and v[4] then
							if beat >=v[1] then
								if (v[4] == 'len' and beat <=v[1]+v[2]) or (v[4] == 'end' and beat <=v[2]) then
									if table.getn(v) == 5 then
										mod_do(v[3],v[5]);
									else
										mod_do(v[3]);
									end
								end
							end
						else
							v[1] = 0;
							v[2] = 0;
							v[3] = '';
							v[4] = 'error';
							SCREENMAN:SystemMessage('Bad mod in beat-based table (line '..i..')');
						end
					end
				end
				
				-----------------------------------------------------------------------------------------------------
				-- WinDEU's time-based len/end version of the #swag custom mod reader #teamproofofconcept (c) 2015 --
				-----------------------------------------------------------------------------------------------------
				if beat > mod_firstSeenBeat+0.1 then -- performance coding!! --
					for i,v in pairs(mods2) do
						if v and table.getn(v) > 3 and v[1] and v[2] and v[3] and v[4] then
							if mod_time >=v[1] then
								if (v[4] == 'len' and mod_time <=v[1]+v[2]) or (v[4] == 'end' and mod_time <=v[2]) then
									if table.getn(v) == 5 then
										mod_do(v[3],v[5]);
									else
										mod_do(v[3]);
									end
								end
							end
						else
							v[1] = 0;
							v[2] = 0;
							v[3] = 'error';
							v[4] = 'error';
							SCREENMAN:SystemMessage('Bad mod in time-based table (line '..i..')');
						end
					end
				end
				
				--------------------------------------------------------------------------------------
				-- i dont know who this reader is but he looks like he is made out of EASE HAHAHAHA --
				-- original code by exschwasion, bastardized by taro for cmod support and less 'if' --
				--------------------------------------------------------------------------------------
				for i,v in pairs(mods_ease) do
					if v and table.getn(v) > 6 and v[1] and v[2] and v[3] and v[4] and v[5] and v[6] and v[7] then
						if beat >=v[1] then
							if (v[6] == 'len' and beat <=v[1]+v[2]) or (v[6] == 'end' and beat <=v[2]) then
								
								local duration = v[2];
								if v[6] == 'end' then duration = v[2] - v[1] end
								local curtime = beat - v[1]
								local diff = v[4] - v[3]
								local startstrength = v[3]
								local curve = v[7]
								local mod = v[5]
								
								local strength = curve(curtime, startstrength, diff, duration, v[10], v[11]) --extra parameters for back and elastic eases :eyes:
								
								local modstr = v[5] == 'xmod' and strength..'x' or (v[5] == 'cmod' and 'C'..strength or strength..' '..v[5])
								mod_do('*10000 '..modstr,v[8]);
								
							elseif (v[9] and ((v[6] == 'len' and beat <=v[1]+v[2]+v[9]) or (v[6] == 'end' and beat <=v[9]))) then
							
								local strength = v[4]
								
								local modstr = v[5] == 'xmod' and strength..'x' or (v[5] == 'cmod' and 'C'..strength or strength..' '..v[5])
								mod_do('*10000 '..modstr,v[8]);
								
							end
						end
					else
						SCREENMAN:SystemMessage('Bad mod in beat-based ease table (line '..i..')');
					end
				end
				
				--------------------
				-- Perframe stuff --
				--------------------
				
				if beat > 2 and beat < 4 then
					local amt = inQuint(((beat-2)/2),0,1,1)
					gorge_bg1:rotationy(180-180*amt)
					gorge_bg1:zoom(amt)
					
					for pn=1,2 do
						local a = Plr(pn)
						if a then
							a:rotationy((180-180*amt)*(pn*2-3))
							a:zoom(amt)
						end
					end
				end
				
				if beat > 20 and beat < 31 then
					--mod_do('*10000 '..(100*math.sin(beat*math.pi*2))..' tipsy')
				end
				
				if beat > 34 and beat < 96 then
					for pn=1,2 do
						local a = Plr(pn)
						if a then
							a:x(sw/2 - 128*(pn*2-3) + 256*(gorge_flicker) + gorge_pos:GetX() )
							
							if beat > 36 and beat < 64 then
								a:z( 200*(pn*2-3)*math.sin(beat*math.pi) )
							end
							
							while a:GetX() > sw/2 + 512 do
								a:addx(-1024)
							end
							while a:GetX() < sw/2 - 512 do
								a:addx(1024)
							end
							
							a:skewx( gorge_aux:GetX() );
							
						end
					end
					
					if beat > 34 and beat < 36 then
						mod_do('*10000 '..(200)..' invert')
					end
					
					if beat > 36 and beat < 64 then
						mod_do('*10000 '..(250 - 50*math.cos(beat*math.pi))..' invert')
					end
					
					if beat > 64 and beat < 66 then
						mod_do('*10000 '..(200)..' invert')
					end
					
					if beat > 67.5 and beat < 95.5 and (beat < 79.5 or beat > 84.5) then
						local pos = math.min(((beat+0.5)-math.floor(beat+0.5))*2,1)*math.pi
						mod_do('*10000 '..-20*math.abs(math.sin(pos))..' alternate')
						mod_do('*10000 '..10*math.abs(math.sin(pos))..' reverse')
					end
					
				end
				
				if beat > 160 then
					for pn=1,2 do
						local a,b = GetJud(pn), GetCom(pn)
						if a then
							a:x(gorge_judaux:GetX()*(pn*2-3))
							a:basezoomx(gorge_judaux:GetZ())
						end
						if b then
							b:x(gorge_judaux:GetX()*(pn*2-3))
							b:basezoomx(gorge_judaux:GetZ())
						end
					end
				end
				
				if beat > 0 then
					for pn=1,2 do
						local a,b = GetJud(pn), GetCom(pn)
						local yad = gorge_judy:GetY()
						if pn == 2 then 
							yad = yad+gorge_judy:GetZ()
						end
						if a then
							a:effectmagnitude(0,yad,0)
						end
						if b then
							b:effectmagnitude(0,yad-30,0)
						end
					end
				end
				--[[
				if beat > 164 and beat < 192 then
					for pn=1,2 do
						local a = Plr(pn)
						local mult = gorge_aux:GetY()
						if pn == 2 then
							mult = gorge_aux:GetZ()
						end
						if a then
							a:x(sw/2 + gorge_aux:GetX()*gorge_flicker*mult )
						end
					end
					gorge_flicker = gorge_flicker*-1
				end
				]]
				if beat > 180 and beat < 195 then
					
					local mult = 0.3
					if slumpo then
						mult = 1
					end
				
					for pn=1,2 do
						local a = Plr(pn)
						if a then
							--a:z( 100*(pn*2-3)*math.sin(beat*math.pi) )
							local m = math.min((beat-180)/4,1)
							if beat > 192 and beat < 194 then
								m = (194-beat)/2
							elseif beat >= 194 then
								m = 0
							end
							a:x( sw/2 + mult*m*32*(pn*2-3)*math.cos(beat*math.pi) )
							--a:rotationx( 40*(pn*2-3)*math.cos(beat*math.pi) )
							a:skewx( mult*m*.25*(pn*2-3)*math.sin(beat*math.pi) )
							
						end
					end
				end
				
				if beat > 132 and beat < 160 then
					gorge_castbg:texcoordvelocity( -0.05*(1-outCubic((beat-132)/28,0,1,1))*(640/sw), -1*linear((beat-132)/28,0,1,1)*(480/sh) )
				end
				
				if beat > 195 and beat < 256 then
					gorge_castbg:customtexturerect( 0-gorge_pos:GetX()/1280, 0+(0.05*beat*(60/161)), 1-gorge_pos:GetX()/1280, 0.5+(0.05*beat*(60/161)) )
				end
				
				if beat > 195 and beat < 256.5 then
					for pn=1,2 do
						local a = Plr(pn)
						
						local adds = 0
						
						if a then
							if beat < 256 then
								a:x(sw/2 - 128*(pn*2-3) + 256*(gorge_flicker) + gorge_pos:GetX() )
								
								if beat > 196 and beat < 224 then
									a:z( 200*(pn*2-3)*math.sin(beat*math.pi) )
								end
								
								if beat > 196 and beat < 220 and slumpo then
									adds = (.4*math.sin(beat*math.pi)*(pn*2-3))
								end
								
								while a:GetX() > sw/2 + 512 do
									a:addx(-1024)
								end
								while a:GetX() < sw/2 - 512 do
									a:addx(1024)
								end
							end
							
							a:skewx( gorge_aux:GetX() + adds );
							
							a:zoom( gorge_aux3:GetX() );
							
						end
						
					end
					
					if beat < 256 then
					
						if beat > 195 and beat < 196 then
							mod_do('*10000 '..(200)..' invert')
						end
						
						if beat > 196 and beat < 224 then
							mod_do('*10000 '..(250 - 50*math.cos(beat*math.pi))..' invert')
						end
						
						if beat > 196 and beat < 224 then
							for pn=1,2 do
								if beat < 211 or beat > 212 then
									--mod_do('*10000 '..(20*(pn*2-3)*math.sin(beat*math.pi))..' brake',pn)
								end
								mod_do('*10000 '..(25+25*(pn*2-3)*math.sin(beat*math.pi))..' stealth',pn)
							end
						end
						if beat > 232 and beat < 252 then
							for pn=1,2 do
								--mod_do('*10000 '..(10*(pn*2-3)*math.sin(beat*math.pi))..' brake',pn)
							end
						end
						
						if beat > 224 and beat < 227 then
							mod_do('*10000 '..(200)..' invert')
						end
						if beat > 231 and beat < 232.5 then
							mod_do('*10000 '..(100)..' invert')
						end
						
						local radd = 0
						
						if beat > 248 and beat < 256 then
							--radd = 50*inQuad((beat-248)/8,0,1,1)
						end
							
						if beat > 231.5 and beat < 255.5 then
							
							local pos = math.min(((beat+0.5)-math.floor(beat+0.5))*2,1)*math.pi
							mod_do('*10000 '..-20*math.abs(math.sin(pos))..' alternate')
							mod_do('*10000 '..10*math.abs(math.sin(pos))+(radd)..' reverse')
						end
						
						if beat > 255.5 then
							mod_do('*10000 '..(radd)..' reverse')
						end
					end
					
				end
				
				if beat > 260 and beat < 292 then
					--[[
					m(256,320,'*1000 300 invert',e,1)
					m(256,320,'*1000 -200 invert',e,2)
					
					m2(256,function()
						for pn=1,2 do
							local a = Plr(pn)
							if a then
								a:x(sw/2)
								a:skewx(-0.24*(pn*2-3))
								a:z(0)
							end
						end
					end)
					]]
					
					local wangle = math.clamp( outQuart(((beat-274)/2),0,1,1), 0, 1 )
					
					local pos = gorge_aux:GetX()
					--local pos = 0.125
					
					local mf = 1
					
					if beat > 260 and beat < 267 or beat > 276 and beat < 283 then
						mf = -1
					end
					
					for pn=1,2 do
						local amt = 50+300*(pn*2-3)*pos
						mod_do('*10000 '..amt..' invert',pn)
						local a = Plr(pn)
						if a then
							a:x(sw/2)
							a:y( sh/2 + 24*math.sin(pos*4*math.pi)*(pn*2-3)*mf )
							a:skewx( -0.24*math.cos(pos*4*math.pi)*(pn*2-3) )
							a:zoomz(gorge_aux2:GetX())
							if beat > 274 and beat < 276 then
								a:rotationx(-360*wangle*(pn*2-3))
							else
								a:rotationx(0)
							end
						end
						
					end
					
				end
				
				screen:effectmagnitude(gorge_vib:GetX(),gorge_vib:GetY(),gorge_vib:GetZ())
				
				---------------------------------------
				-- ACTION RPGS AINT GOT SHIT ON THIS --
				---------------------------------------
				if beat > mod_firstSeenBeat+0.1 then -- performance coding!! --
					while curaction<=table.getn(mod_actions) and GAMESTATE:GetSongBeat()>=mod_actions[curaction][1] do
						if mod_actions[curaction][3] and type(mod_actions[curaction][3]) == 'number' and GAMESTATE:GetSongBeat() < mod_actions[curaction][3]
						or mod_actions[curaction][3] and type(mod_actions[curaction][3]) == 'boolean' or GAMESTATE:GetSongBeat() < mod_actions[curaction][1]+2 then
							if type(mod_actions[curaction][2]) == 'function' then
								mod_actions[curaction][2]()
							elseif type(mod_actions[curaction][2]) == 'string' then
								MESSAGEMAN:Broadcast(mod_actions[curaction][2]);
							end
						end
						curaction = curaction+1;
					end
				end
				
			end
			
			self:sleep(1/60);
			self:queuecommand('Update');

---------------------------------------------------------------------------------------
----------------------END DON'T TOUCH IT KIDDO-----------------------------------------
---------------------------------------------------------------------------------------
			
		end"
		
	/>
	
	<!--Handling messages here is still fun and profitable-->
	<CODE Type="Quad" OnCommand="hidden,1"
	InitCommand="%function(self) gorge_aux = self end"
	/>
	
	<CODE Type="Quad" OnCommand="hidden,1"
	InitCommand="%function(self) gorge_pos = self end"
	/>
	
	<CODE Type="Quad" OnCommand="hidden,1"
	InitCommand="%function(self) gorge_judaux = self end"
	/>
	
	<CODE Type="Quad" OnCommand="hidden,1"
	InitCommand="%function(self) gorge_judy = self end"
	/>
	
	<CODE Type="Quad" OnCommand="hidden,1"
	InitCommand="%function(self) gorge_vib = self end"
	/>
	
	<CODE Type="Quad" OnCommand="hidden,1;x,1"
	InitCommand="%function(self) gorge_aux2 = self end"
	/>
	
	<CODE Type="Quad" OnCommand="hidden,1;x,1"
	InitCommand="%function(self) gorge_aux3 = self end"
	/>
	
	<Layer Type="Quad" OnCommand="stretchto,sw/2-320,-100,sw/2-256,sh+100;diffuse,0,0,0,0;faderight,1;diffusealpha,0;"
	LetterBoxOnMessageCommand="linear,.5;diffusealpha,1;" LetterBoxOffMessageCommand="linear,.5;diffusealpha,0;" />
	<Layer Type="Quad" OnCommand="stretchto,sw/2+256,-100,sw/2+320,sh+100;diffuse,0,0,0,0;fadeleft,1;diffusealpha,0;"
	LetterBoxOnMessageCommand="linear,.5;diffusealpha,1;" LetterBoxOffMessageCommand="linear,.5;diffusealpha,0;" />
	<Layer Type="Quad" OnCommand="stretchto,sw/2-320-sw,-100,sw/2-320,sh+100;diffuse,0,0,0,0;diffusealpha,0;"
	LetterBoxOnMessageCommand="linear,.5;diffusealpha,1;" LetterBoxOffMessageCommand="linear,.5;diffusealpha,0;" />
	<Layer Type="Quad" OnCommand="stretchto,sw/2+320,-100,sw/2+320+sw,sh+100;diffuse,0,0,0,0;diffusealpha,0;"
	LetterBoxOnMessageCommand="linear,.5;diffusealpha,1;" LetterBoxOffMessageCommand="linear,.5;diffusealpha,0;" />
	
	<Layer File="static.sprite" OnCommand="diffusealpha,0;x,SCREEN_CENTER_X;y,SCREEN_CENTER_Y;zoomto,SCREEN_WIDTH,SCREEN_HEIGHT"
	StaticMessageCommand="linear,.08;diffusealpha,.75;linear,.16;diffusealpha,.2;linear,.08;diffusealpha,.75;linear,.16;diffusealpha,.2;linear,.08;diffusealpha,.75;linear,.16;diffusealpha,0" />
	
	<Layer Type="Quad" OnCommand="stretchto,0,0,sw,sh;diffuse,1,0,0,0;" RedFlashMessageCommand="diffusealpha,.6;linear,.4;diffusealpha,0;" />
	
	<!--This is for the time based mod reader-->
	<BitmapText
		Font="Common Normal"
		Text="test"
		OnCommand="x,SCREEN_CENTER_X;y,SCREEN_CENTER_Y;effectclock,music;playcommand,SetTime;hidden,1"
		SetTimeCommand="%function(self) self:settext(self:GetSecsIntoEffect()); mod_time = mod_globaloffset+tonumber(self:GetText()); self:sleep(0.02); self:queuecommand('SetTime'); end"
	/>
	
</children></ActorFrame>