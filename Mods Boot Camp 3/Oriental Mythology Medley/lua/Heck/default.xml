<Layer Type="ActorFrame" Var="h_environment" InitCommand="%function(self) 

	h_afts = {}
	h_lumiarray = {}
	h_flicker = 1
	h_playerproxies = {}

	function h_init()
		for i = 1, table.getn(h_afts) do h_afts[i]:hidden(0) end
		for i = 1, table.getn(h_bgafts) do h_bgafts[i]:hidden(0) end
		local f = 1
		for i = 1,table.getn(h_playerproxies) do
			local proxy = h_playerproxies[i]
			local a = Plr(normalize(f,-1,1,1,2))
			if a then
				proxy:SetTarget(a:GetChild('NoteField'))
				proxy:hidden(1)
			end
			f=-f
		end
	end

	-- heyaaaaaaa this code sucks

end"><children>

	<Layer File="h_helpers.xml"/>
	<Layer File="h_c2l.xml"/>

	<Layer Type="Quad" InitCommand="hidden,1;sleep,9E9" OnCommand="%function(self)
		local m,mm,me,l,e,str,mpf = mod_insert,mod_message,mod_ease,'len','end','',mpf_insert
		local function r(float) return ((math.rad(float)*100)*-1) end


		m(296, 584, '*-1 approachtype',e,nil)
		mm(284,function()
			for pn = 1,2 do
				local a = Plr(pn)
				if a then
					a:x(scx)
				end
			end
		end)

		m(284, 12, '*-1 50 flip,*-1 50 reverse',l,nil)
		me(284, 12, 360*6, 0, 'rotationz', l, outQuart, 1)
		me(284, 12, -360*6, 0, 'rotationz', l, outQuart, 2)
		me(284, 8, -2000, 0, 'tiny', l, outQuad, nil)

		me(294, 6, 3000, 0, 'drunkz', l, inSine, nil,0.2)
		me(294, 6, 50, 0, 'reverse', l, inSine, nil,0.2)
		me(294, 6, 50, 0, 'flip', l, inSine, nil,0.2)
		me(294, 6, 360*3, 0, 'rotationy', l, inSine, 1,0.2)
		me(294, 6, -360*3, 0, 'rotationy', l, inSine, 2,0.2)
		me(294, 6, r(360*3), 0, 'confusionyoffset', l, inSine, 1,0.2)
		me(294, 6, r(-360*3), 0, 'confusionyoffset', l, inSine, 2,0.2)
		
		me(299, 1, 0, 100, 'zoom', l, linear, nil)

		mm(299,function()
			for pn = 1,2 do
				local a = Plr(pn)
				if a then
					a:linear(spb())
					a:x(scx*(pn-0.5))
				end
			end
		end)

		m(300, 6, '*-1 400 zoomz',l,nil)
		mod_bounce(300, 1, 100, 150, 'zoomy', 'Circ', false, nil)
		mod_bounce(300, 1, 0, -10, 'rotationz', 'Circ', false, nil)
		mod_bounce(300, 1, 0, 200, 'tipsy', 'Circ', false, nil)
		mod_bounce(300, 1, 0, 100, 'mini', 'Circ', false, nil)
		mod_bounce(301, 1, 0, 200, 'drunk', 'Circ', false, nil)
		mod_bounce(301, 1, 0, -200, 'tipsy', 'Circ', false, nil)
		mod_bounce(301, 1, 0, -50, 'skewx', 'Circ', false, nil)
		mod_bounce(301, 1, 0, 50, 'mini', 'Circ', false, nil)
		bouncy_wiggle(302,1,0.5,0,100,'tipsy',l,'Circ',false,false,nil,100)
		bouncy_wiggle(302,1,0.5,0,20,'rotationy',l,'Circ',false,false,nil,10)
		m(302, 1, '*-1 400 zigzagperiod',l,nil)
		bouncy_wiggle(302,1,0.5,0,300,'zigzag',l,'Circ',false,false,nil)
		mod_bounce(303, 1, 0, 50, 'mini', 'Expo', false, nil)
		mod_bounce(303, 2, 0, 20, 'rotationz', 'Quad', false, nil)
		for col = 0,3 do
			me(303.5, 1, 0, 100, 'reverse'..col, l, inOutExpo, nil, 4)
		end
		mod_bounce(305, 2, 0, -20, 'rotationz', 'Quad', false, nil)
		me(303, 1, 2, 0, function(t)
			local pos = t
			local string = '*-1 '.. -math.cos(pos*math.pi)*50+50 ..' invert,'..
			'*-1 '.. math.sin((pos*math.pi)+math.pi)*(10) ..' reverse,'..
			'*-1 '.. math.sin(pos*math.pi)*(20) ..' alternate'
			mod_do(string,nil)
		end, l, outCirc, nil)
		--mod_bounce(304, 2, 2, 3, 'xmod', 'Quad', false, nil)
		mod_bounce(304, 0.75, 0, -50, 'rotationx', 'Circ', false, nil)
		mod_bounce(304, 0.75, 0, -100, 'cubicx', 'Circ', false, nil)
		mod_bounce(304.75, 1.25, 0, 50, 'rotationx', 'Circ', false, nil)
		mod_bounce(304.75, 1.25, 0, 100, 'cubicx', 'Circ', false, nil)
		m(306, 2, '*-1 1000 zigzagzperiod',l,nil)
		bouncy_wiggle(306,1,0.5,0,-1500,'zigzagz',l,'Circ',false,false,nil)
		bouncy_wiggle(306,1,0.5,0,200,'tipsy',l,'Circ',false,false,nil,200)

		local fuck = {
			{304.000,3,1},
			{304.250,1,1},
			{304.750,3,1},
			{305.250,2,1},
			{305.500,1,1},
			{305.750,0,1},
			{306.000,3,1},
		}
		local f = 1
		for i = 2,table.getn(fuck) do
			local beat = fuck[i-1][1]
			local diff = (fuck[i][1] - beat)
			mod_bounce(beat, diff, 0, diff*400*f, 'drunk', 'Circ', false, nil)
			f=-f
		end

		me(306-0.4, 0.5, 0, 15, 'reverse', l, outBack, nil)
		me(306.5-0.4, 0.5, 15, 35, 'reverse', l, outBack, nil)
		me(307-0.4, 0.5, 35, 50, 'reverse', l, outBack, nil)

		mm(307,function()
			for pn = 1,2 do
				local a = Plr(pn)
				if a then
					a:x(scx)
				end
			end
		end)

		me(307, 1, 0, 100, 'flip', l, outBack, nil)
		me(307, 2, -1000, 0, 'tiny', l, outExpo, nil)
		me(307, 2, -100, 0, 'mini', l, outExpo, nil)
		me(307, 4, 1, 2, 'xmod', l, outSine, nil)
		me(307, 2, r(360), 0, 'confusionoffset', l, outExpo, nil)
		me(307, 2, 100, 200, 'flip', l, inCirc, nil)
		me(308, 2, 360*2, 0, 'rotationz', l, inOutCirc, nil)
		me(308, 2, r(360*2), 0, 'confusionoffset', l, inOutCirc, nil)

		me(309, 1, 0, 0, 'flip', l, linear, nil)
		mod_bounce(308, 2, 100, 0, 'zoom', 'Sine', true, nil)
		mod_bounce(308, 2, 0, 50, 'reverse', 'Sine', false, nil)
		local f = 1
		for i = 0,10,2 do
			mm(310+i,function() f=-f end) 
			mpf(310+i,310+(i+2),function(beat)
				local pos = (beat - (310+i))
				local string = '*-1 '.. -math.cos(pos*math.pi)*50+50 ..' invert,'..
				'*-1 '.. math.sin((pos*math.pi)+math.pi)*(10*f) ..' reverse,'..
				'*-1 '.. math.sin(pos*math.pi)*(20*f) ..' alternate'
				mod_do(string,nil)
			end)
		end


		m(309, 12, '*-1 60 beat,*-1 400 beatperiod,*-1 150 wave,*-1 400 cubicz,*20 50 mini',l,nil)
		local f = 1
		for i = 0,8,4 do
			bouncy_wiggle(310+i,2,1,0,-50,'movey',l,'Sine',true,false,normalize(f,-1,1,1,2),0)
			mod_bounce(310+i, 2, 0, -100, 'x', 'Expo', false, normalize(f,-1,1,1,2))
			mod_bounce(310+i, 2, 0, -360, 'dizzy', 'Expo', false, normalize(f,-1,1,1,2))
			mod_bounce(310+i, 2, 0, 400, 'sudden', 'Expo', false, normalize(f,-1,1,1,2))
			mod_bounce(310+i, 2, 0, 400, 'hidden', 'Expo', false, normalize(-f,-1,1,1,2))
			mod_bounce(310+i, 2, 0, 400, 'dark', 'Expo', false, normalize(-f,-1,1,1,2))

			bouncy_wiggle(312+i,2,1,0,-50,'movey',l,'Sine',true,false,normalize(-f,-1,1,1,2),0)
			mod_bounce(312+i, 2, 0, 100, 'x', 'Expo', false, normalize(-f,-1,1,1,2))
			mod_bounce(312+i, 2, 0, 360, 'dizzy', 'Expo', false, normalize(-f,-1,1,1,2))
			mod_bounce(312+i, 2, 0, 400, 'sudden', 'Expo', false, normalize(-f,-1,1,1,2))
			mod_bounce(312+i, 2, 0, 400, 'hidden', 'Expo', false, normalize(f,-1,1,1,2))
			mod_bounce(312+i, 2, 0, 400, 'dark', 'Expo', false, normalize(f,-1,1,1,2))
			f=-f
		end
		me(316, 1, r(360), 0, 'confusionoffset', l, outQuad, nil)
		me(316, 1, -200, 0, 'tiny', l, outQuad, nil)
		me(317, 1, r(360), 0, 'confusionoffset', l, outQuad, nil)
		me(317, 1, -200, 0, 'tiny', l, outQuad, nil)
		me(318, 1, 50, 0, 'stealth', l, outQuad, nil)
		me(318, 1, -200, 0, 'tiny', l, outQuad, nil)

		mpf(322.5,323.833,function(beat)
			local pos = (beat - 322.5)/0.333
			local string = '*-1 '.. -50*math.sin(pos*math.pi+math.rad(90))+50 ..' flip,'..
			'*-1 '.. -36*math.cos((pos*math.pi+math.rad(90))+math.pi) ..' reverse,'..
			'*-1 '.. -48*math.cos(pos*math.pi+math.rad(90)) ..' split,'..
			'*-1 '.. -24*math.cos(pos*math.pi+math.rad(90)) ..' alternate'
			mod_do(string,nil)
		end)

		--me(322.5, 1.167, -360, 0, 'rotationz', l, linear, nil)
		me(322.5, 1.5, 0, 100, 'zoom', l, outBack, nil,0.1)

		me(324.5, 0.5, 300, 100, 'zoom', l, outExpo, nil)
		me(324.5, 0.5, -500, 0, 'tiny', l, outExpo, nil)
		mod_bounce(324.5, 0.75, 2, 1, 'xmod', 'Expo', false, nil)
		mod_bounce(324.5, 0.75, 0, 10, 'rotationz', 'Expo', false, nil)
		mod_bounce(324.5, 0.75, 0, -150, 'mini', 'Expo', false, nil)

		me(325.25, 0.5, 400, 100, 'zoom', l, outExpo, nil)
		me(325.25, 0.5, -800, 0, 'tiny', l, outExpo, nil)
		mod_bounce(325.25, 0.75, 0, 100, 'reverse', 'Expo', false, nil)
		mod_bounce(325.25, 0.75, 2, 0.6, 'xmod', 'Expo', false, nil)
		mod_bounce(325.25, 0.75, 0, -20, 'rotationz', 'Expo', false, nil)
		mod_bounce(325.25, 0.75, 0, -300, 'mini', 'Expo', false, nil)

		m(326, 380, '*-1 -100 spiralholds,*-1 10 gayholds,*-1 400 beatperiod,*-1 400 beatzperiod,*-1 400 bumpyperiod,*-1 400 zoomz,*-1 -400 drunkzspeed',e,nil)
		m(326, 24, '*-1 0 beat,*-1 50 wave,*-1 -100 bumpy,*-1 25 drunkz,',l,nil)
		m(358, 20, '*-1 0 beatz,*-1 100 wave,*-1 50 bumpy,*-1 55 drunkz,*-1 50 mini',l,nil)
		me(358, 4, 1, 2, 'xmod', l, inOutSine, nil)

		bouncy_wiggle(326-.5,22,1,100,120,'zoomx',l,'Circ',true,true,nil,0)
		bouncy_wiggle(326,22,1,100,110,'zoomy',l,'Circ',true,false,nil,0)

		--mod_bounce(344.5, 1.5, 0, 300, 'tipsy', 'Circ', false, nil)
		bouncy_wiggle(344.5,1.5,0.5,0,200,'tipsy',l,'Circ',false,false,nil,0)
		bouncy_wiggle(344.5,1.5,0.5,100,50,'zoomx',l,'Circ',true,false,nil,80)
		bouncy_wiggle(344.5,1.5,0.5,100,80,'zoomy',l,'Circ',true,false,nil,40)
		bouncy_wiggle(344.5,1.5,0.5,0,20,'skewx',l,'Circ',false,false,nil,0)

		bouncy_wiggle(358-.5,24,1,100,140,'zoomx',l,'Circ',true,true,nil,0)
		bouncy_wiggle(358,22,1,100,120,'zoomy',l,'Circ',true,false,nil,0)
		bouncy_wiggle(358,22,1,0,-5,'rotationz',l,'Sine',false,false,nil,0)
		--bouncy_wiggle(358,22,1,0,5,'rotationz',l,'Circ',false,false,2,0)

		mm(326,function()
			omm_overlayquad:hidden(0)
			omm_overlayquad:diffusealpha(1)
			omm_overlayquad:linear(1)
			omm_overlayquad:diffusealpha(0)
			for pn = 1,2 do
				local a = Plr(pn)
				if a then
					a:tween(spb()*0.75,'inQuad(%f,0,1,1)')
					a:x(scx+(32*4)*(pn*2-3))
				end
			end
		end)
		me(342, 2, r(360*4), 0, 'confusionoffset', l, outSine, nil)
		me(340, 4, 0, 100, 'reverse', l, inOutExpo, nil,6)
		me(340, 4, 360, 0, 'rotationz', l, inOutExpo, nil)
		mod_bounce(340, 4, 0, -1000, 'mini', 'Expo', true, nil)
		mod_bounce(340, 4, 0, -500, 'skewx', 'Expo', true, 1)
		mod_bounce(340, 4, 0, 500, 'skewx', 'Expo', true, 2)
		local h_funny = {
			{346.000},
			{346.250},
			{346.750},
			{347.250},
			{347.750},
			{348.500},
			{349.000},
			{349.500},
			{350.000},
		}
		local f = 1
		local swaps = {{0,0},{100,0},{0,100},{75,-125},{25,125},}
		local last = {0,0}
		local shit = 2
		for i = 2,table.getn(h_funny) do
			local beat = h_funny[i-1][1]
			local diff = (h_funny[i][1] - beat)
			if shit > table.getn(swaps) or i >= table.getn(h_funny) then shit = 1 end
			me(beat, diff, last[1], swaps[shit][1], 'flip', l, outBack, nil, 0.5)
			me(beat, diff, last[2], swaps[shit][2], 'invert', l, outBack, nil, 0.5)
			mod_bounce(beat, diff, 0, (100*diff)*f, 'tipsy', 'Circ', false, nil)
			mod_bounce(beat, diff, 0, (30*diff)*f, 'confusionoffset', 'Circ', false, 1)
			mod_bounce(beat, diff, 0, (30*diff)*-f, 'confusionoffset', 'Circ', false, 2)
			for j = 1,2 do last[j] = swaps[shit][j] end
			shit = shit + 1
			f=-f
		end

		me(341, 1, 2, 0.5, 'xmod', l, inSine, nil)
		me(342, 2, 0.5, 2, 'xmod', l, outSine, nil)
		me(342, 2, -1000, 0, 'tipsy', l, outExpo, nil)
		me(342, 2, 50, 0, 'stealth', l, outSine, nil)
		me(342, 2, -200, 0, 'tiny', l, outSine, nil)

		me(348.5, 1, 0, 75, 'mini', l, inBack, nil)
		me(349.5, 1, 75, -300, 'mini', l, inCirc, nil)
		me(349.5, 1, 360*2, 0, 'rotationz', l, inCirc, nil)




		mm(346,function()
			for pn = 1,2 do
				local a = Plr(pn)
				if a then
					a:tween(spb()*4,'inOutQuad(%f,0,1,1)')
					a:x(scx)
				end
			end
		end,false)
		mm(358,function()
            for pn = 1,2 do
                local a = Plr(pn)
                if a then
                    a:tween(spb()*1,'outBack(%f,0,1,1)')
                    a:x(scx+(32*4)*(pn*2-3))
                end
            end
        end)
        mm(359,function()
            for pn = 1,2 do
                local a = Plr(pn)
                if a then
                    a:x(scx+(32*4)*(pn*2-3))
                end
            end
        end,true)

		mpf(326,350,function(beat)
			local pos = (beat - (326))
			local string = '*-1 '.. 4*math.sin(pos/4*math.pi) ..' rotationx,'..
			'*-1 '.. 4*math.cos(pos/4*math.pi) ..' rotationy,'
			mod_do(string,nil)
		end)
		mpf(358,380.5,function(beat)
			local pos = (beat - (358))
			local string = '*-1 '.. 8*math.sin(pos/4*math.pi) ..' rotationx,'..
			'*-1 '.. 8*math.cos(pos/4*math.pi) ..' rotationy,'
			mod_do(string,nil)
		end)

		for i = 0,17,2 do
			me(359+i, 1, -200, 0, 'tiny', l, outExpo, nil)
			me(359+i, 1, 40, 0, 'brake', l, outExpo, nil)
		end

		local pn,col = 1,0
		local speed = 1.5
		for i = 0,1.75,0.25 do
			if col == 4 then col = 0 pn = 2 end
			me(364+i,speed,0,100,'reverse'..col,l,outExpo,pn,7-i)
			me(364+i+speed,speed,100,0,'reverse'..col,l,outExpo,pn,7-i)
			col = col + 1
		end

		local h_swaps = {
		{358,1,{2,0},4,'Quad','y'},
		{359,1,{0,2},4,'Quad','y'},
		{360,1,{3,1},4,'Quad','y'},
		{361,1,{1,3},4,'Quad','y'},

		{366,1,{0,2},4,'Quad','z'},
		{367,1,{2,0},4,'Quad','z'},
		{368,1,{1,3},4,'Quad','z'},
		{369,1,{3,1},4,'Quad','z'},

		{374,1,{0,3},2,'Quad','y'},
		{375,1,{1,2},2,'Quad','y'},
		{376,1,{2,1},2,'Quad','y'},
		{377,1,{3,0},2,'Quad','y'},
		}

		for i = 0,12,4 do
			table.insert(h_swaps,{(327+i),1,{0,2},2,'Quad','y'})
			table.insert(h_swaps,{(327+i+0.05),1,{2,0},2,'Quad','y'})
			table.insert(h_swaps,{(327+i+0.1),1,{1,3},2,'Quad','y'})
			table.insert(h_swaps,{(327+i+0.15),1,{3,1},2,'Quad','y'})
		end

		local zdist = 100
		for i = 1,table.getn(h_swaps) do -- TODO: REWRITE THIS GARBAGE
			local beat,len,sus,ease,dir = h_swaps[i][1],h_swaps[i][2],h_swaps[i][4],h_swaps[i][5],h_swaps[i][6]
			local p1col,p2col = h_swaps[i][3][1],h_swaps[i][3][2]
			me(beat, len, 0, (700-(p1col*100)-(normalize(p2col,0,3,3,0)*100)), 'movex'..p1col, l, _G['inOut'..ease], 1, sus)
			me(beat, len, 0, -(700-(p1col*100)-(normalize(p2col,0,3,3,0)*100)), 'movex'..p2col, l, _G['inOut'..ease], 2, sus)
			mod_bounce(beat, len, 0, 50, 'stealth'..p1col, ease, false, 1)
			mod_bounce(beat, len, 0, 50, 'stealth'..p2col, ease, false, 2)
			mod_bounce(beat, len, 0, -zdist, 'move'..dir..''..p1col, ease, false, 1)
			mod_bounce(beat, len, 0, zdist, 'move'..dir..''..p2col, ease, false, 2)
			me(beat, len, r(360*len)*f, 0, 'confusionoffset'..p1col, l, _G['inOut'..ease], 1)
			me(beat, len, r(360*len)*f, 0, 'confusionoffset'..p2col, l, _G['inOut'..ease], 2)

			me(beat+sus, len, (700-(p1col*100)-(normalize(p2col,0,3,3,0)*100)), 0, 'movex'..p1col, l, _G['inOut'..ease], 1, sus)
			me(beat+sus, len, -(700-(p1col*100)-(normalize(p2col,0,3,3,0)*100)), 0, 'movex'..p2col, l, _G['inOut'..ease], 2, sus)
			mod_bounce(beat+sus, len, 0, 50, 'stealth'..p1col, ease, false, 1)
			mod_bounce(beat+sus, len, 0, 50, 'stealth'..p2col, ease, false, 2)
			mod_bounce(beat+sus, len, 0, zdist, 'move'..dir..''..p1col, ease, false, 1)
			mod_bounce(beat+sus, len, 0, -zdist, 'move'..dir..''..p2col, ease, false, 2)
			me(beat+sus, len, r(360*len), 0, 'confusionoffset'..p1col, l, _G['inOut'..ease], 1)
			me(beat+sus, len, r(360*len), 0, 'confusionoffset'..p2col, l, _G['inOut'..ease], 2)
		end


		m(350, 4, '*-1 200 bumpyperiod,*0.2 1x',l,nil)
		local f,c = 1,1
		for i = 0,4,2 do
			mod_bounce(350+i, 2, 200, -50*(c*2), 'mini', 'Expo', false, nil)
			mod_bounce(350+i, 2, 0, normalize(f,1,-1,10*c,100), 'reverse', 'Expo', false, nil)
			me(350+i, 2, -800*f, 800*f, 'y', l, outInExpo, nil)
			me(350+i, 2, c*70*f, c*-70*f, 'rotationz', l, outInExpo, nil)
			me(350+i, 2, r(c*70*f), r(c*-70*f), 'confusionoffset', l, outInExpo, nil)
			f,c=-f,c+1
		end
		me(352, 1, 0, 100, 'invert', l, outBack, nil, 1)
		me(354, 1, 100, 0, 'invert', l, outBack, nil, 1)
		me(354, 1, 0, 100, 'flip', l, outBack, nil, 1)

		m(356, 0.3, '*-1 no rotationz,*-1 no y,*-1 no confusionoffset,*-1 100 zoomx,*-1 no reverse,*-1 no flip,*-1 100 zoom,*-1 no mini',l,nil)
		local f = 1
		for i = 0,2,0.5 do
			me(356+i, 1, -200, 0, 'tiny', l, outExpo, nil)
			--me(356+i, 1, -400*f, 0, 'tipsy', l, outExpo, nil)
			--me(356+i, 1, -1000*f, 0, 'drunk', l, outExpo, nil)
			f=-f
		end
		me(356, 2, 0, -80, 'rotationx', l, inExpo, nil, 0.2)
		mod_bounce(356, 2, 1000, -300, 'movez', 'Circ', false, nil)
		mod_bounce(356, 2, 2, 1.5, 'xmod', 'Circ', false, nil)
		bouncy_wiggle(356,2,0.5,0,50,'movex',l,'Expo',false,false,1,50)
		bouncy_wiggle(356,2,0.5,0,-50,'movex',l,'Expo',false,false,2,-50)
		me(358, 2, 0, 100, 'zoom', l, outExpo, nil)
		m(358, 1, '*-1 no movez',l,nil)
		mm(358,function()
			omm_overlayquad:hidden(0)
			omm_overlayquad:diffusealpha(1)
			omm_overlayquad:linear(1)
			omm_overlayquad:diffusealpha(0)
		end)

		me(378, 2, 360*4, 0,function(t) for pn = 1,2 do local a = Plr(pn) if a then a:rotationy(t) end end end, l, inSine, nil, 1)
		me(378, 2, r(360*4), 0,'confusionyoffset', l, inSine, nil, 1)
		me(380.5, 1, -4000, 0, 'tiny', l, outExpo, nil)

		mod_intox(380.5,1,'drunk',100,7000,-20,inExpo,nil)
		me(380.5, 1, -4000, -400, 'tiny', l, outExpo, nil)
		me(381.5, 1, -400, 0, 'tiny', l, inOutBack, nil,0.2)
		-- wooshy woosh
		
		m(382, 14, '*-1 50 wave,*1 150 zoomx,*2 150 tipsy,*2 50 orient',l,nil)
		m(382, 15, '*-1 400 tipsyspeed,*-1 -0.04 drunkperiod',l,nil)
		m(381, 15.5, '*-1 reverse,*-1 0 confusionoffset',l,2)
		m(398, 1, '*-1 no gayholds',l,nil)

		mm(382,function()
			for pn = 1,2 do
				local a = Plr(pn)
				if a then
					for col = 0,3 do
						a:SetNumArrowGradientPoints(col,2)

						a:SetArrowGradientPoint(0,col,4)
						a:SetArrowGradientPoint(1,col,6)

						a:SetArrowGradientColor(0,col,1,1,1,1)
						a:SetArrowGradientColor(1,col,1,0,0,0)
					end
				end
			end
		end)

		me(397, 2, 0, 4, function(t)
			for pn = 1,2 do
				local a = Plr(pn)
				if a then
					for col = 0,3 do
						a:SetArrowGradientPoint(0,col,4+t)
						a:SetArrowGradientPoint(1,col,6+t)
					end
				end
			end
		end, l, linear, nil)

		mm(400,function()
			for pn = 1,2 do
				local a = Plr(pn)
				if a then
					for col = 0,3 do
						a:SetNumArrowGradientPoints(col,0)
					end
				end
			end
		end)



		local f = 1
		local fuck = 1
		for i = 2,table.getn(h_flute) do
			local beat = h_flute[i-1][1]
			local diff = (h_flute[i][1] - beat)
			for pn = 1,2 do
				mod_bounce(beat, diff, 0, (pn*2-3)*(100*( diff )*f), 'drunk', 'Quad', false, pn)
				mod_bounce(beat, diff, 0, (pn*2-3)*(35*( diff )*f), 'skewx', 'Quad', false, pn)
				mod_bounce(beat, diff, 0, (pn*2-3)*(15*( diff )*f), 'rotationz', 'Quad', false, pn)
			end
			f = -f
		end

		mm(380.5,function()
			local a = Plr(1)
			if a then
				a:x(scx)
				a:tween(spb()*1.5,'inBack(%f,0,1,1)')
				a:zoom(0)
			end
			a = Plr(2)
			if a then
				a:x(scx)
				a:zoom(0)
			end
		end)


		local j = 0
		local f = 1
		for i = 0,14,2 do
			mm(381+i,function()
				j = j + 1
				if j >= table.getn(h_playerproxies) then j = 1 end
				local proxy = h_playerproxies[j]
				if proxy then
					local r = 50
					proxy:zoomz(2)
					proxy:zoom(0.8)
					proxy:rotationz(r)
					proxy:rotationy(-140)
					proxy:y(scy+(sh/8)*math.sin(i*math.pi+j/2*math.pi))
					proxy:rotationx(-60*math.sin(i*math.pi+j/2*math.pi))
					proxy:x((scx-sw/2)-(64*2))
					proxy:hidden(0)
					proxy:linear(spb()*5)
					proxy:x(sw+(64*4))
					proxy:rotationz(-r)
					proxy:rotationy(140)
				end
				f=-f
			end)
		end



		mm(384,function()
			for pn = 1,2 do
				local a = Plr(pn)
				if a then
					a:hidden(1)
				end
			end
		end)

		mm(397,function()
			for pn = 1,2 do
				local a = Plr(pn)
				if a then
					a:hidden(0)
					a:x(scx)
					a:tween(spb()*1,'outBack(%f,0,1,1)')
					a:zoom(1)
				end
			end
		end)

		mm(397,function()
			for i = 1,table.getn(h_playerproxies) do
				local proxy = h_playerproxies[i]
				if proxy then
					proxy:tween(spb(),'inCirc(%f,0,1,1)')
					proxy:zoom(0)
				end
			end
		end)

		mm(399,function()
			for i = 1,table.getn(h_playerproxies) do
				local proxy = h_playerproxies[i]
				if proxy then
					proxy:hidden(1)
				end
			end
		end,true)
		

		me(397, 0.5, 0, 100, 'invert', l, outBack, nil)
		me(397.5, 0.5, 100, 0, 'invert', l, outBack, nil)

		m(399, 4, '*-1 800 bumpyxperiod,*-1 no tipsyspeed',l,nil)
		mod_intox(400,0.25,'drunk',150,4000,-40,inExpo,nil)
		bouncy_wiggle(398,2,1,0,-100,'mini',l,'Circ',false,false,nil)
		bouncy_wiggle(399,1,0.5,0,200,'tipsy',l,'Circ',false,false,nil)
		bouncy_wiggle(398,2,1,0,10,'rotationz',l,'Circ',false,false,nil)
		mod_bounce(398, 1, 0, 110, 'flip', 'Circ', false, nil)
		mod_bounce(398, 1, 0, -200, 'drunk', 'Circ', false, nil)
		mod_bounce(398, 1, 0, -50, 'mini', 'Circ', false, nil)
		mod_bounce(400, 1, 0, -50, 'rotationx', 'Circ', false, nil)
		mod_bounce(400, 1, 0, r(-50), 'confusionxoffset', 'Circ', false, nil)
		mod_bounce(400, 1, 0, -200, 'movey', 'Circ', false, nil)
		me(400, 1, 2, 0, function(t)
			local pos = t
			local string = '*-1 '.. -50*math.sin(pos*math.pi+math.rad(90))+50 ..' flip,'..
			'*-1 '.. -36*math.cos((pos*math.pi+math.rad(90))+math.pi) ..' reverse,'..
			'*-1 '.. -48*math.cos(pos*math.pi+math.rad(90)) ..' split,'..
			'*-1 '.. -24*math.cos(pos*math.pi+math.rad(90)) ..' alternate'
			mod_do(string,nil)
		end, l, outCirc, nil)
		bouncy_wiggle(401,1,0.5,0,200,'bumpyx',l,'Quad',false,false,nil)
		bouncy_wiggle(401,1,0.5,0,10,'rotationz',l,'Quad',false,false,nil)
		mod_bounce(401, 1, 0, 30, 'reverse', 'Circ', false, nil)
		bouncy_wiggle(401,2,0.5,0,100,'square',l,'Circ',false,false,nil,50)
		bouncy_wiggle(401,2,0.5,0,5,'skewx',l,'Circ',false,false,nil,5)
		mod_bounce(403, 1, 0, -150, 'x', 'Circ', false, 1)
		mod_bounce(403, 1, 0, 150, 'x', 'Circ', false, 2)
		me(403, 2, 360, 0, 'rotationz', l, inOutExpo, 1, 0.2)
		me(403, 2, -360, 0, 'rotationz', l, inOutExpo, 2, 0.2)
		m(404.5, 0.5, '*2 20 reverse,*2 140 zoomx,*10 invert,*10 -2500 tinyz',l,nil)
		m(405, 0.5, '*2 40 reverse,*2 200 zoomx,*10 no invert,*10 -5000 tinyz',l,nil)
		me(405.25, 1.5, 40, 0, 'reverse', l, inOutBack, nil)
		me(405.25, 1.5, 200, 100, 'zoomx', l, inOutBack, nil)
		me(405.25, 1.5, -5000, 0, 'tinyz', l, inOutBack, nil)
		mod_bounce(405.5, 0.5, 0, 50, 'tipsy', 'Quad', false, nil)

		mm(407,function()
			for pn = 1,2 do
				local a = Plr(pn)
				if a then
					a:tween(spb(),'inCirc(%f,0,1,1)')
					a:y(sh+400)
				end
			end
		end)
		for col = 0,3 do
			me(407, 1, 0, math.random(-200,200), 'movex'..col, l, inQuad, nil)
			me(407, 1, 0, math.random(-200,200), 'confusionoffset'..col, l, inQuad, nil)
			m(408, 1, '*-1 no movex'..col..',*-1 no confusionoffset'..col,l,nil)
		end
		mod_bounce(406, 2, 0, -1000, 'tiny', 'Expo', true, nil)
		mod_bounce(408, 2, 0, -1000, 'tiny', 'Expo', true, nil)
		mod_bounce(406, 2, 0, -150, 'mini', 'Expo', true, nil)
		m(407, 2, '*-1 flip',l,nil)
		mod_bounce(408, 2, 0, -150, 'mini', 'Expo', true, nil)
		mm(408,function()
			for pn = 1,2 do
				local a = Plr(pn)
				if a then
					a:y(scy)
				end
			end
		end)
		me(408, 1, 40, 0, 'reverse', l, outExpo, nil)
		me(408, 1, 0, 100, 'zoomy', l, outExpo, nil)
		me(408, 1, 400, 100, 'zoomx', l, outExpo, nil)
		m(409, 1, '*-1 no flip',l,nil)
		m(409, 8, '*-1 -99 squareperiod,*-1 400 zoomz',l,nil)
		me(409, 1, 40, 0, 'square', l, inExpo, nil, 1)
		me(409, 1, 0, 100, 'reverse', l, outCirc, nil, 3)
		mod_bounce(409, 1, 0, 100, 'drunk', 'Circ', false, nil)
		mod_bounce(409, 1, 2, 1, 'xmod', 'Sine', false, nil)
		mod_bounce(409, 1, 0, 20, 'flip', 'Sine', false, nil)
		mod_bounce(409, 1, 0, -200, 'mini', 'Sine', false, nil)

		mod_bounce(410.5, 0.75, 2, 3, 'xmod', 'Quad', false, nil)
		mod_bounce(410.5, 1.5, 0, -40, 'rotationx', 'Quad', false, nil)
		mod_bounce(410.5, 1.5, 0, -40, 'rotationy', 'Quad', false, nil)
		me(410.5, 1.5, 360, 0, 'rotationz', l, inOutExpo, nil)

		me(412.25, 1, 100, 0, 'reverse', l, inOutExpo, nil)
		mod_bounce(412, 0.75, 2, 3, 'xmod', 'Quad', false, nil)
		mod_bounce(412, 2, 0, 40, 'rotationx', 'Quad', false, nil)
		mod_bounce(412, 2, 0, 40, 'rotationy', 'Quad', false, nil)
		me(412, 1.5, -360, 0, 'rotationz', l, inOutExpo, nil)

		local fuck = {
			{414.000,1,1},
			{414.250,2,1},
			{414.750,3,1},
			{415.250,2,1},
			{415.750,1,1},
			{416.000,0,1},
			{416.500,0,1},
			{417.000,3,1},
			{418.000,3,1},
		}
		local f = 1
		local last,cur = 0,0
		for i = 2,table.getn(fuck) do
			local beat = fuck[i-1][1]
			local diff = (fuck[i][1] - beat)
			cur = cur - 10
			me(beat, 1, -200, 0, 'tiny', l, outExpo, nil)
			mod_bounce(beat, diff, -200, 50, 'mini', 'Expo', false, nil)
			me(beat, diff, last, cur, 'flip', l, outExpo, nil)
			me(beat, 1, 400*f, 0, 'tipsy', l, outExpo, nil)
			me(beat, 1, 400*f, 0, 'drunk', l, outExpo, nil)
			last = cur
			f=-f
		end




		-- twisties

		--me(416, 2, 360*2, 0, 'rotationy', l, inQuad, nil, 0.2)
		--me(416, 2, r(360*2), 0, 'confusionyoffset', l, inQuad, nil, 0.2)
		me(416, 2, 360, 180, 'rotationz', l, inBack, nil, 0.2)
		me(416, 2, 100, 500, 'zoom', l, inBack, nil)
		mm(416,function()
			for pn = 1,2 do
				local a = Plr(pn)
				if a then
					a:tween(spb()*2,'inQuad(%f,0,1,1)')
					a:x(scx)
					--a:x(scx*(pn-0.5)-100*(pn*2-3))
				end
			end
			--h_clouds:GetShader():uniform3f('skycolour1',242/255,103/255,31/255)
			--h_clouds:GetShader():uniform3f('skycolour2',22/255,10/255,71/255)
		end)

		m(418, 32, '*-1 800 bumpyxperiod,*-1 50 drawsize,*-1 25 brake,*-1 no mini,*-1 25 wave',l,nil)
		m(418, 32, '*-1 reverse',l,2)

		me(511, 1, 100, 0, 'zoom', l, inCirc, nil, 0.2)
		me(511, 1, 360, 180, 'rotationz', l, inCirc, nil, 0.2)
		m(512, 32, '*-1 800 bumpyxperiod,*-1 50 drawsize,*-1 25 brake,*-1 no mini,*-1 no reverse,*-1 25 wave',l,nil)
		m(512, 32, '*-1 reverse',l,2)

		me(420.25, 2, r(360*4), 0, 'confusionoffset', l, inQuad, nil, 0.2)
		me(425, 1, -r(360*2), 0, 'confusionoffset', l, inQuad, nil, 0.2)
		me(432.5, 1.5, r(360*2), 0, 'confusionoffset', l, inQuad, nil, 0.2)
		me(437, 1, -r(360*2), 0, 'confusionoffset', l, inQuad, nil, 0.2)
		me(441, 1, r(360), 0, 'confusionoffset', l, linear, nil, 0.2)

		me(514, 2, r(360*4), 0, 'confusionoffset', l, inQuad, nil, 0.2)
		me(518.5, 1, -r(360*2), 0, 'confusionoffset', l, inQuad, nil, 0.2)
		me(526.5, 1.5, r(360*2), 0, 'confusionoffset', l, inQuad, nil, 0.2)
		me(530.5, 1.5, -r(360*2), 0, 'confusionoffset', l, inQuad, nil, 0.2)
		me(534.5, 1.5, r(360), 0, 'confusionoffset', l, linear, nil, 0.2)

		local f = 1
		for i = 0,28,4 do
			for pn = 1,2 do
				mod_bounce(418+i, 4, 0, 400*(f*(pn*2-3)), 'bumpyx', 'Circ', false, pn)
				mod_bounce(418+i, 4, 0, 100*(f*(pn*2-3)), 'movex', 'Circ', false, pn)

				mod_bounce(512+i, 4, 0, 400*(f*(pn*2-3)), 'bumpyx', 'Circ', false, pn)
				mod_bounce(512+i, 4, 0, 100*(f*(pn*2-3)), 'movex', 'Circ', false, pn)
			end
			mod_bounce(418+i, 4, 0, -4000, 'parabolaz', 'Circ', false, nil)
			mod_bounce(418+i, 4, 4, 1.75, 'xmod', 'Circ', false, nil)
			mod_bounce(418+i, 4, 0, 125, 'zoom', 'Circ', false, nil)
			me(418+i, 4, (360+180)*f, 180*f, 'rotationz', l, outInExpo, nil, 0.2)
			--mod_bounce(420+i, 2, 0, 50*f, 'skewx', 'Circ', false, nil)

			mod_bounce(512+i, 4, 0, -4000*f, 'parabolaz', 'Circ', false, nil)
			mod_bounce(512+i, 4, 4, normalize(f,-1,1,1.5,1.75), 'xmod', 'Circ', false, nil)
			mod_bounce(512+i, 4, 0, normalize(f,-1,1,50,125), 'zoom', 'Circ', false, nil)
			me(512+i, 4, (360+180)*f, 180*f, 'rotationz', l, outInExpo, nil, 0.2)
			--mod_bounce(514+i, 2, 0, 50*f, 'skewx', 'Circ', false, nil)
			f=-f
		end

		-- end twisties
		m(300+150, 5, '*-1 400 zoomz,*10 50 movey',l,nil)
		mod_bounce(300+150, 1, 100, 150, 'zoomy', 'Circ', false, nil)
		mod_bounce(300+150, 1, 0, -10, 'rotationz', 'Circ', false, nil)
		mod_bounce(300+150, 1, 0, 200, 'tipsy', 'Circ', false, nil)
		mod_bounce(300+150, 1, 0, 100, 'mini', 'Circ', false, nil)
		mod_bounce(301+150, 1, 0, 200, 'drunk', 'Circ', false, nil)
		mod_bounce(301+150, 1, 0, -200, 'tipsy', 'Circ', false, nil)
		mod_bounce(301+150, 1, 0, -50, 'skewx', 'Circ', false, nil)
		--mod_bounce(301+150, 1, 0, 50, 'mini', 'Circ', false, nil)
		bouncy_wiggle(302+150,1,0.5,0,100,'tipsy',l,'Circ',false,false,nil,100)
		bouncy_wiggle(302+150,1,0.5,0,20,'rotationy',l,'Circ',false,false,nil,10)
		m(302+150, 1, '*-1 400 zigzagperiod',l,nil)
		bouncy_wiggle(302+150,1,0.5,0,300,'zigzag',l,'Circ',false,false,nil)
		--mod_bounce(303+150, 1, 0, 50, 'mini', 'Expo', false, nil)
		mod_bounce(303+150, 2, 0, 20, 'rotationz', 'Quad', false, nil)
		me(303+150, 1, 2, 0, function(t)
			local pos = t
			local string = '*-1 '.. -math.cos(pos*math.pi)*50+50 ..' invert,'..
			'*-1 '.. math.sin((pos*math.pi)+math.pi)*(10) ..' reverse,'..
			'*-1 '.. math.sin(pos*math.pi)*(20) ..' alternate'
			mod_do(string,nil)
		end, l, outCirc, nil)
		me(450, 2, 2, 2, 'xmod', l, linear, nil)
		me(450, 2, 0, 0, 'skewx', l, linear, nil)
		me(450, 2, 0, 0, 'movex', l, linear, nil)
		me(450, 2, 0, 0, 'bumpyx', l, linear, nil)
		me(450, 2, 0, 0, 'parabolaz', l, linear, nil)
		me(450, 2, 500, 100, 'zoom', l, outExpo, nil)
		m(450, 2, '*-1 no reverse',l,nil)






		mm(446,function()
			for pn = 1,2 do
				local a = Plr(pn)
				if a then
					a:tween(spb()*4,'inOutCirc(%f,0,1,1)')
					a:x(scx)
				end
			end
		end)


		-- star spline

		m(455, 37, '*-1 200 arrowpathgirth,*-1 -100 arrowpathdrawsizeback,*-1 -100 drawsizeback,*0.04 4000 zoomz,*-1 50 reverse,*-1 50 flip,*-1 250 splinextype,*-1 250 splineytype,*-1 200 wave,*0.04 dark,*1 50 beatz',l,nil)
		mod_bounce(454, 2, 100, 0, 'zoom', 'Circ', true, nil)
		me(454, 1, 2, 1, 'xmod', l, outQuad, nil)
		me(454, 2, 360+20, 0, 'rotationz', l, inOutExpo, 1)
		me(454, 2, r(360), 0, 'confusionoffset', l, inOutExpo, 1)
		me(454, 2, -360+20, 0, 'rotationz', l, inOutExpo, 2)
		me(454, 2, r(-360), 0, 'confusionoffset', l, inOutExpo, 2)
		mm(455,function()
			local dist = 600
			local size = (dist/2)
			local offset = 50
			for pn = 1,2 do
				local a = Plr(pn)
				if a then
					a:NoClearSplines(true)
					a:x(scx)

					a:SetXSpline(0,0,-size,0,-1) a:SetYSpline(0,1,size,0,-1) a:SetYSpline(0,2,-size,0,-1) a:SetXSpline(0,3,size,0,-1)
					
					a:SetXSpline(1,0,-offset,dist/2,-1) a:SetYSpline(1,0,-offset,dist/2,-1)
					a:SetXSpline(1,1,-offset,dist/2,-1) a:SetYSpline(1,1,offset,dist/2,-1)
					a:SetXSpline(1,2,offset,dist/2,-1) a:SetYSpline(1,2,-offset,dist/2,-1)
					a:SetXSpline(1,3,offset,dist/2,-1) a:SetYSpline(1,3,offset,dist/2,-1)

					a:SetXSpline(2,0,0,dist,-1) a:SetYSpline(2,0,-size,dist,-1)
					a:SetXSpline(2,1,-size,dist,-1) a:SetYSpline(2,1,0,dist,-1)
					a:SetXSpline(2,2,size,dist,-1) a:SetYSpline(2,2,0,dist,-1)
					a:SetXSpline(2,3,0,dist,-1) a:SetYSpline(2,3,size,dist,-1)

					for col = 0,3 do
						a:SetNumPathGradientPoints(col,3)
						a:SetPathGradientColor(0,col,1,1,1,0)
						a:SetPathGradientColor(1,col,1,1,1,1)
						a:SetPathGradientColor(2,col,1,1,1,0)

						a:SetNumArrowGradientPoints(col,3)
						a:SetArrowGradientColor(0,col,1,1,1,0)
						a:SetArrowGradientColor(1,col,1,1,1,1)
						a:SetArrowGradientColor(2,col,1,1,1,0)

						a:SetArrowGradientPoint(0,col,0)
						a:SetArrowGradientPoint(1,col,4-1)
						a:SetArrowGradientPoint(2,col,6-1)
					end

				end
			end
		end)

		me(476, 8, 1, 2, function(t)
			for pn = 1,2 do
				local a = Plr(pn)
				if a then
					for col = 0,3 do
						a:SetArrowGradientPoint(0,col,t)
						a:SetArrowGradientPoint(1,col,t+2)
						a:SetArrowGradientPoint(2,col,t+4)
					end
				end
			end
		end, l, inQuad, nil)

		local cur,last = 0,0
		for i = 0,35 do
			cur = cur + math.pi*(90/10)
			me(456+i, 1, last, cur, function(t)
				local amt = h_rotControl:GetX()
				mod_RotationFromAux(amt,0,t,h_camera,nil)

				local dist = h_rotControl:GetY()
				local size = (dist/2)
				local offset = 50
				for pn = 1,2 do
					local a = Plr(pn)
					if a then
						a:NoClearSplines(false)
						a:SetXSpline(0,0,-size,0,-1) a:SetYSpline(0,1,size,0,-1) a:SetYSpline(0,2,-size,0,-1) a:SetXSpline(0,3,size,0,-1)
						
						a:SetXSpline(1,0,-offset,dist/2,-1) a:SetYSpline(1,0,-offset,dist/2,-1)
						a:SetXSpline(1,1,-offset,dist/2,-1) a:SetYSpline(1,1,offset,dist/2,-1)
						a:SetXSpline(1,2,offset,dist/2,-1) a:SetYSpline(1,2,-offset,dist/2,-1)
						a:SetXSpline(1,3,offset,dist/2,-1) a:SetYSpline(1,3,offset,dist/2,-1)

						a:SetXSpline(2,0,0,dist,-1) a:SetYSpline(2,0,-size,dist,-1)
						a:SetXSpline(2,1,-size,dist,-1) a:SetYSpline(2,1,0,dist,-1)
						a:SetXSpline(2,2,size,dist,-1) a:SetYSpline(2,2,0,dist,-1)
						a:SetXSpline(2,3,0,dist,-1) a:SetYSpline(2,3,size,dist,-1)
					end
				end
			end, l, inQuint, nil, 0.2)
			last = cur
		end

		mm(456,function()
			h_rotControl:xy(0,600)
			h_rotControl:linear(spb()*32)
			h_rotControl:x(-70)

			omm_overlayquad:hidden(0)
			omm_overlayquad:diffusealpha(1)
			omm_overlayquad:linear(1)
			omm_overlayquad:diffusealpha(0)
		end)

		for i = 1,table.getn(h_arrowpathshine) do
			local beat = h_arrowpathshine[i][1]
			local col = h_arrowpathshine[i][2]
			me(beat, 2, 100, 0, 'arrowpath'..col, l, outSine, nil)
			me(beat-0.25, 1, 6, -2, function(t)
				local which = col
				for pn = 1,2 do
					local a = Plr(pn)
					if a then
						a:SetPathGradientPoint(0,which,t)
						a:SetPathGradientPoint(1,which,t+1)
						a:SetPathGradientPoint(2,which,t+2)
					end
				end
			end, l, linear, nil)
		end

		me(480, 2, 50, 0, 'stealth', l, outQuad, nil)
		me(480, 2, -500, 0, 'tiny', l, outQuad, nil)

		mm(491,function()
			h_rotControl:tween(spb(),'inCirc(%f,0,1,1)')
			h_rotControl:xy(0,0)
		end)
		mm(456+36,function()
			for pn = 1,2 do
				local a = Plr(pn)
				if a then
					a:NoClearSplines(false)
				end
			end
		end)
		mod_bounce(492, 1, 100, 400, 'zoom', 'Circ', false, nil)
		me(492, 2, 50, 0, 'flip', l, inOutExpo, nil)
		me(492, 2, 50, 0, 'reverse', l, inOutExpo, nil)
		me(492, 2, 0, 0, 'rotationz', l, inOutExpo, nil)
		me(492, 2, 0, 0, 'confusionoffset', l, inOutExpo, nil)

		mm(493,function()
			for pn = 1,2 do
				local a = Plr(pn)
				if a then
					for col = 0,3 do
						a:SetNumPathGradientPoints(col,0)
						a:SetNumArrowGradientPoints(col,0)
					end
					a:x(scx)
				end
			end
		end)

		-- end star spline

		local f = 1
		for i = 0,5 do
			me(493+i, 1, 50, 0, 'stealth', l, outQuad, nil)
			me(493+i, 1, 5000*f, 0, 'drunk', l, outExpo, nil)
			me(493+i, 1, 5000*f, 0, 'tipsy', l, outExpo, nil)
			me(493+i, 1, -5000, 0, 'tiny', l, outExpo, nil)
			f=-f
		end
		bouncy_wiggle(493,5,1,200,100,'zoom',l,'Expo',true,false,nil,-15)
		bouncy_wiggle(493,5,1,0,20,'rotationx',l,'Expo',false,false,nil,10)
		me(495, 3, 360*2, 0, 'rotationz', l, inQuart, nil)
		me(495, 3, r(360*2), 0, 'confusionoffset', l, inSine, nil)

		m(498, 5, '*-1 50 reverse,*-1 50 flip,*-1 400 bumpyperiod,*-1 -100 arrowpathdrawsizeback',l,nil)
		--mod_bounce(498, 5, 0, 300, 'longholds', 'Quad', false, nil)
		--mod_bounce(498, 5, 0, 5000, 'gayholds', 'Quad', false, nil)
		me(498, 5, 100, 0, 'distant', l, inSine, nil, 0.2)
		--me(498, 5, 40, 0, 'arrowpath', l, inCirc, nil, 0.2)
		me(498, 5, 500, 0, 'bumpy', l, inCirc, nil, 0.2)
		me(498, 5, 1000, 0, 'bumpyoffset', l, outSine, nil)
		me(498, 5, 1, 2, 'xmod', l, inCirc, nil, 0.2)
		me(498, 5, 360*2, -((90+45)-(90/4)), 'rotationz', l, outCirc, nil)
		me(498, 5, r(360*2), -r((90+45)-(90/4)), 'confusionoffset', l, outCirc, nil)
		me(498, 1, -1000, 0, 'tiny', l, outQuad, nil)
		me(498, 5, 200, 0, 'zoom', l, outInExpo, nil)
		m(498, 6, '*-1 -100 spiralholds',l,nil)

		mm(498,function()
			for pn = 1,2 do
				local a = Plr(pn)
				if a then
					a:NoClearSplines(true)
					for col = 0,3 do
						a:SetXSpline(0,col,0,0,-1)
						a:SetYSpline(0,col,0,0,-1)

						a:SetXSpline(1,col,500*math.sin(math.pi+(pn*math.pi)+(col/4*math.pi)),600,-1)
						a:SetYSpline(1,col,500*math.cos(math.pi+(pn*math.pi)+(col/4*math.pi)),600,-1)
					end
				end
			end
			h_fisheye:hidden(0)
		end)
		
		--me(498, 4, -2, 0, function(t) h_fisheye:GetShader():uniform1f('amount', t) end, l, outQuad, nil)
		me(498, 4, -2, 0, function(t) h_fisheye:GetShader():uniform1f('amt', t) end, l, outQuad, nil)

		me(503, 0.2, 0, 0, 'rotationz', l, linear, nil)
		me(503, 0.2, 0, 0, 'confusionoffset', l, linear, nil)
		mm(503,function()
			for pn = 1,2 do
				local a = Plr(pn)
				if a then
					a:NoClearSplines(false)
					a:SetXSpline(0,-1,0,0,-1)
					a:SetYSpline(0,-1,0,0,-1)
					a:SetXSpline(1,-1,0,0,-1)
					a:SetYSpline(1,-1,0,0,-1)
					a:x(scx)
				end
			end
			h_fisheye:hidden(1)
		end)
		-- i do not care anymore, copy paste this shit
		local fuck = {
			{414.000+90,1,1},
			{414.250+90,2,1},
			{414.750+90,3,1},
			{415.250+90,2,1},
			{415.750+90,1,1},
			{416.000+90,0,1},
			{416.500+90,0,1},
			{417.000+90,3,1},
			{418.000+90,3,1},
		}
		local f = 1
		local last,cur = 0,0
		for i = 2,table.getn(fuck) do
			local beat = fuck[i-1][1]
			local diff = (fuck[i][1] - beat)
			cur = cur - 10
			me(beat, 1, -200, 0, 'tiny', l, outExpo, nil)
			mod_bounce(beat, diff, -200, 50, 'mini', 'Expo', false, nil)
			me(beat, diff, last, cur, 'flip', l, outExpo, nil)
			me(beat, 1, 400*f, 0, 'tipsy', l, outExpo, nil)
			me(beat, 1, 400*f, 0, 'drunk', l, outExpo, nil)
			last = cur
			f=-f
		end
		me(507, 1, 0, 100, 'reverse', l, inOutExpo, nil, 4)
		me(506, 3, 360, 0, 'rotationz', l, inOutExpo, nil)
		local fuck = {
			{414.000+94,1,1},
			{414.250+94,2,1},
			{414.750+94,3,1},
			{415.250+94,2,1},
			{415.750+94,1,1},
			{416.000+94,0,1},
			{416.500+94,0,1},
			{417.000+94,3,1},
			{418.000+94,3,1},
		}
		local f = 1
		local last,cur = 0,0
		for i = 2,table.getn(fuck) do
			local beat = fuck[i-1][1]
			local diff = (fuck[i][1] - beat)
			cur = cur - 10
			me(beat, 1, -200, 0, 'tiny', l, outExpo, nil)
			mod_bounce(beat, diff, -200, 50, 'mini', 'Expo', false, nil)
			me(beat, diff, last, cur, 'flip', l, outExpo, nil)
			me(beat, 1, 400*f, 0, 'tipsy', l, outExpo, nil)
			me(beat, 1, 400*f, 0, 'drunk', l, outExpo, nil)
			last = cur
			f=-f
		end


		-- lumikey spam
		me(544, 2, 100, 100, 'zoom', l, linear, nil)
		mm(544,function()
			omm_overlayquad:hidden(0)
			omm_overlayquad:diffusealpha(1)
			omm_overlayquad:linear(1)
			omm_overlayquad:diffusealpha(0)
		end)

		me(540, 4, 360, 0, 'rotationz', l, inBack, nil,0.2)
		me(540, 4, r(360), 0, 'confusionoffset', l, inBack, nil,0.2)
		me(538, 6, 2, 0.5, 'xmod', l, outSine, nil)
		me(540, 6, 0, -2000, 'tiny', l, inQuart, nil)
		me(544, 0.5, -2000, 0, 'tiny', l, outExpo, nil)
		me(544, 2, 50, 0, 'stealth', l, outSine, nil)
		mm(544,function()
			h_blackquad:hidden(0)
			for i = 1,table.getn(h_lumiarray) do
				local l = h_lumiarray[i]
				if l then
					l:hidden(0)
					l:fadetop(0.2)
					l:fadebottom(0.2)
				end
			end
			for pn = 1,2 do
				local a = Plr(pn)
				if a then
					a:x(scx)
				end
			end
		end)

		--bouncy_wiggle(544,32,1,0,-50,'movey',l,'Circ',true,nil)
		local f = 1
		for i = 0,31 do
			me(544.5+i, 1, -1000, 0, 'tinyz', l, outSine, nil)
			me(544.5+i, 1, -1000, 0, 'tiny', l, outExpo, nil)
			me(544.5+i, 1, 400*f, 0, 'drunk', l, outExpo, nil)
			me(544.5+i, 1, 400*f, 0, 'tipsy', l, outExpo, nil)
			f=-f
		end

		m(544, 31, '*-1 7.5 flip,*0.25 wave,*-1 500 zoomz',l,nil)

		local speed_div = 6
		mpf(544,576,function(beat)
			for i = 1,(table.getn(h_lumiarray)/2)-1 do
				local lumi = h_lumiarray[i]
				if lumi then
					local sawtooth = ((beat/speed_div)+(i/6)-math.floor(beat/speed_div+(i/6)))
					lumi:x(scx+inOutQuad(sawtooth, -sw, sw, 1))
					lumi:y(scy+inExpo(sawtooth, -sh/8, sh*2, 1))
					lumi:rotationz(inExpo(sawtooth, 0, -80, 1))
				end
			end

			for i = (table.getn(h_lumiarray)/2)-1,table.getn(h_lumiarray) do -- TODO: get rid of this second loop
				local lumi = h_lumiarray[i]
				if lumi then
					local sawtooth = (((beat+(speed_div/4))/speed_div)+(i/6)-math.floor((beat+1)/speed_div+(i/6)))
					lumi:x(scx-inOutQuad(sawtooth, -sw, sw, 1))
					lumi:y(scy+inExpo(sawtooth, -sh/8, sh*2, 1))
					lumi:rotationz(inExpo(sawtooth, 0, 80, 1))
				end
			end
		end)
		
		me(572, 4, 1, 0, function(t)
			for i = 1,table.getn(h_lumiarray) do
				local l = h_lumiarray[i]
				if l then
					l:zoom(t)
				end
			end 
		end, l, inQuad, nil)

		mm(576,function()
			h_blackquad:linear(spb()*1)
			h_blackquad:diffusealpha(0)
			h_lumiEnv:hidden(1)
			for i = 1,table.getn(h_lumiarray) do
				local l = h_lumiarray[i]
				if l then
					l:hidden(1)
				end
			end
			for pn = 1,2 do
				local a = Plr(pn)
				if a then
					a:x(scx*(pn-0.5))
				end
			end
		end)
		mod_bounce(572, 4, 0, -50, 'movey', 'Quad', false, nil)
		mod_bounce(572, 2, 100, 50, 'zoomx', 'Circ', false, nil)
		me(572, 2, 2, 1, 'xmod', l, outExpo, nil, 2)
		me(572, 4, 360, 0, 'rotationy', l, inOutExpo, nil)
		me(572, 4, r(360), 0, 'confusionyoffset', l, inOutExpo, nil)
		mod_bounce(574, 2, 0, 10, 'tornado', 'Circ', false, nil)

		me(576, 2, -2000, 0, 'tiny', l, outQuart, nil)


		mm(583,function()
			for pn = 1,2 do
				local a = Plr(pn)
				if a then
					a:tween(spb(),'outBack(%f,0,1,1)')
					a:x(scx)
				end
			end
		end,true)

		m(300+276, 6, '*-1 400 zoomz',l,nil)
		mod_bounce(300+276, 1, 100, 150, 'zoomy', 'Circ', false, nil)
		mod_bounce(300+276, 1, 0, 10, 'rotationz', 'Circ', false, nil)
		mod_bounce(300+276, 1, 0, 200, 'tipsy', 'Circ', false, nil)
		mod_bounce(300+276, 1, 0, 100, 'mini', 'Circ', false, nil)
		mod_bounce(301+276, 1, 0, 200, 'drunk', 'Circ', false, nil)
		mod_bounce(301+276, 1, 0, -200, 'tipsy', 'Circ', false, nil)
		mod_bounce(301+276, 1, 0, 50, 'skewx', 'Circ', false, nil)
		mod_bounce(301+276, 1, 0, 50, 'mini', 'Circ', false, nil)
		bouncy_wiggle(302+276,1,0.5,0,100,'tipsy',l,'Circ',false,false,nil,100)
		bouncy_wiggle(302+276,1,0.5,0,-20,'rotationy',l,'Circ',false,false,nil,-10)
		m(302+276, 1, '*-1 400 zigzagperiod',l,nil)
		bouncy_wiggle(302+276,1,0.5,0,300,'zigzag',l,'Circ',false,false,nil)
		mod_bounce(303+276, 1, 0, 50, 'mini', 'Expo', false, nil)
		mod_bounce(303+276, 2, 0, 20, 'rotationz', 'Quad', false, nil)
		for col = 0,3 do
			me(303.5+276, 1, 0, 100, 'reverse'..col, l, inOutExpo, nil, 4)
		end
		mod_bounce(305+276, 2, 0, 20, 'rotationz', 'Quad', false, nil)
		me(303+276, 1, -2, 0, function(t)
			local pos = t
			local string = '*-1 '.. -math.cos(pos*math.pi)*50+50 ..' invert,'..
			'*-1 '.. math.sin((pos*math.pi)+math.pi)*(10) ..' reverse,'..
			'*-1 '.. math.sin(pos*math.pi)*(20) ..' alternate'
			mod_do(string,nil)
		end, l, outCirc, nil)
		--mod_bounce(304, 2, 2, 3, 'xmod', 'Quad', false, nil)
		mod_bounce(304+276, 0.75, 0, 50, 'rotationx', 'Circ', false, nil)
		mod_bounce(304+276, 0.75, 0, -100, 'cubicx', 'Circ', false, nil)
		mod_bounce(304.75+276, 1.25, 0, -50, 'rotationx', 'Circ', false, nil)
		mod_bounce(304.75+276, 1.25, 0, 100, 'cubicx', 'Circ', false, nil)
		m(306+276, 2, '*-1 1000 zigzagzperiod',l,nil)
		bouncy_wiggle(306+276,1,0.5,0,-1500,'zigzagz',l,'Circ',false,false,nil)
		bouncy_wiggle(306+276,1,0.5,0,200,'tipsy',l,'Circ',false,false,nil,200)

		local fuck = {
			{304.000+276,3,1},
			{304.250+276,1,1},
			{304.750+276,3,1},
			{305.250+276,2,1},
			{305.500+276,1,1},
			{305.750+276,0,1},
			{306.000+276,3,1},
		}
		local f = 1
		for i = 2,table.getn(fuck) do
			local beat = fuck[i-1][1]
			local diff = (fuck[i][1] - beat)
			mod_bounce(beat, diff, 0, diff*400*f, 'drunk', 'Circ', false, nil)
			f=-f
		end

		me(306-0.4+276, 0.5, 0, 15, 'reverse', l, outBack, nil)
		me(306.5-0.4+276, 0.5, 15, 35, 'reverse', l, outBack, nil)
		me(307-0.4+276, 0.5, 35, 50, 'reverse', l, outBack, nil)
		mod_bounce(583, 1, 0, -1000, 'tiny', 'Quad', false, nil)
		me(583, 1, 360, 0, 'rotationz', l, outExpo, nil)
		me(583, 1, r(360), 0, 'confusionoffset', l, outExpo, nil)







		
		
		

		local f1,f2 = 1,1
		for i = 1,table.getn(h_wenisExtender) do
			local beat = h_wenisExtender[i][1]
			local which = h_wenisExtender[i][2]
			if which == 0 then
				m(beat, 1, '*-1 100 drunkperiod',l,nil)
				me(beat, 1, 200*f, 0, 'drunk', l, outCirc, 1)
				me(beat, 1, -200*f, 0, 'drunk', l, outCirc, 2)
				f1=-f1
			elseif which == 1 then
				me(beat, 1, -400, 0, 'tiny', l, outExpo, nil)
				me(beat, 1, 500*f2, 0, 'tipsy', l, outExpo, nil)
				me(beat, 1, -500, 0, 'tinyx', l, outExpo, nil)
				me(beat, 1, -50, 0, 'flip', l, outExpo, nil)
				f2=-f2
			end
		end


		-- uncomment for funny meme
		--[[mpf(326,381,function(beat)
			local sawtooth = ((beat/8)-math.floor(beat/8))
			local ww = DISPLAY:GetWindowWidth()
			local wh = DISPLAY:GetWindowHeight()
			local desw = DISPLAY:GetDesktopWidth()
			local desh = DISPLAY:GetDesktopHeight()
			DISPLAY:SetWindowPosition(
				(-desw/2)-(ww/2)+((desw*2)+ww)*sawtooth,
				(desh/2)-(wh/2)-24+(-100*math.abs(math.sin(beat*math.pi))))
		end)--]]

	end"
	/>

	<!-- Aux Vars! :D -->
	<Aux Var="h_camera" InitCommand="hidden,1;" OnCommand="xyz,0,0,0;" />
	<Aux Var="h_rotControl" InitCommand="hidden,1;" OnCommand="xy,0,0;" />
	
	<Layer Var="yin_throne" File="throneroom" OnCommand="hidden,1;xy,sw/2,sh/2;zoom,1.5;zoomz,1.5;z,-1000;" />
	
	<Layer Type="ActorFrame" Var="yin_tapestry" OnCommand="hidden,1;fov,60;" ><children>
		<Layer File="tapestry" OnCommand="stretchto,0,0,sw,sh;diffuse,1,1,1,1" TapFadeMessageCommand="sleep,120/174;linear,120/174;diffusealpha,0;" />
		<Layer File="hills" OnCommand="fadebottom,.2;cropbottom,.1;valign,1;x,sw/2;y,sh*(.7);diffuse,236/255,202/255,184/255,1;
		basezoomx,1.2;basezoomy,1.2;customtexturerect,0,0,4,1;zoomx,4;texcoordvelocity,-.2,0;" TapFadeMessageCommand="linear,120/174;diffusealpha,0;" />
		<Layer File="hills" OnCommand="fadebottom,.2;cropbottom,.1;valign,1;x,sw/2;y,sh*(.8);diffuse,207/255,172/255,154/255,1;
		basezoomx,1.5;basezoomy,1.5;customtexturerect,0,0,3,1;zoomx,-3;texcoordvelocity,.3,0;" TapFadeMessageCommand="linear,120/174;diffusealpha,0;" />
		<Layer File="hills" OnCommand="fadebottom,.2;cropbottom,.1;valign,1;x,sw/2;y,sh*(.9);diffuse,170/255,136/255,118/255,1;
		basezoomx,1.8;basezoomy,1.8;customtexturerect,0,0,2,1;zoomx,2;texcoordvelocity,-.4,0;" TapFadeMessageCommand="linear,120/174;diffusealpha,0;" />
	</children></Layer>
	
	<Layer Type="Quad" Var="yin_thronebgcover" OnCommand="hidden,1;clearzbuffer,1;diffuse,0,0,0,0;stretchto,0,0,sw,sh" />
	
	<Layer Type="ActorFrame" OnCommand="fov,60;" ><children>
		<Layer File="../YinBao" Var="char_yin1" />
	</children></Layer>
	
	<Layer Type="ActorProxy" OnCommand="hidden,1;" Var="Proxy1E" GetProxyMessageCommand="%function(self) if P1 then self:SetTarget(P1) end end" />
	<Layer Type="ActorProxy" OnCommand="hidden,1;" Var="Proxy2E" GetProxyMessageCommand="%function(self) if P2 then self:SetTarget(P2) end end" />

	<Layer Type="ActorFrameTexture" Var="h_aft" InitCommand="hidden,1" 
		OnCommand="%function(self) 
			self:SetWidth(dw)
			self:SetHeight(dh)
			self:EnableDepthBuffer(false)
			self:EnableAlphaBuffer(true)
			self:EnableFloat(false)
			self:EnablePreserveTexture(true)
			self:Create()
			table.insert(h_afts,self)
		end"
	/>

	<Layer Type="Quad" Var="h_blackquad" InitCommand="hidden,1;zoomto,sw,sh;xy,scx,scy;diffuse,0,0,0,1;"/>
	
	<Layer Var="yin_throne2" File="throneroom" OnCommand="hidden,1;xy,sw/2,0;zoom,1.5;zoomz,1.5;z,-1000;" HideCommand="hidden,1;" />
	
	<Layer Type="Quad" Var="yin_thronebgcover2" OnCommand="hidden,1;clearzbuffer,1;diffuse,0,0,0,0;stretchto,0,0,sw,sh" />

	<Layer Type="ActorFrame" Var="h_lumiEnv"><children>
		<Layer Type="Sprite" Texture="../white.png" Frag="chroma.frag"
			OnCommand="hidden,1;xy,scx,scy;basezoomx,sw/dw;basezoomy,-(sh)/dh;zoom,1;diffusealpha,1;sleep,0.02;queuecommand,Render;"
			RenderCommand="%function(self) self:SetTexture(h_aft:GetTexture()) self:hidden(1) table.insert(h_lumiarray,self) end"
		/>
		<Layer Type="Sprite" Texture="../white.png" Frag="chroma.frag"
			OnCommand="hidden,1;xy,scx,scy;basezoomx,sw/dw;basezoomy,-(sh)/dh;zoom,1;diffusealpha,1;sleep,0.02;queuecommand,Render;"
			RenderCommand="%function(self) self:SetTexture(h_aft:GetTexture()) self:hidden(1) table.insert(h_lumiarray,self) end"
		/>
		<Layer Type="Sprite" Texture="../white.png" Frag="chroma.frag"
			OnCommand="hidden,1;xy,scx,scy;basezoomx,sw/dw;basezoomy,-(sh)/dh;zoom,1;diffusealpha,1;sleep,0.02;queuecommand,Render;"
			RenderCommand="%function(self) self:SetTexture(h_aft:GetTexture()) self:hidden(1) table.insert(h_lumiarray,self) end"
		/>
		<Layer Type="Sprite" Texture="../white.png" Frag="chroma.frag"
			OnCommand="hidden,1;xy,scx,scy;basezoomx,sw/dw;basezoomy,-(sh)/dh;zoom,1;diffusealpha,1;sleep,0.02;queuecommand,Render;"
			RenderCommand="%function(self) self:SetTexture(h_aft:GetTexture()) self:hidden(1) table.insert(h_lumiarray,self) end"
		/>
		<Layer Type="Sprite" Texture="../white.png" Frag="chroma.frag"
			OnCommand="hidden,1;xy,scx,scy;basezoomx,sw/dw;basezoomy,-(sh)/dh;zoom,1;diffusealpha,1;sleep,0.02;queuecommand,Render;"
			RenderCommand="%function(self) self:SetTexture(h_aft:GetTexture()) self:hidden(1) table.insert(h_lumiarray,self) end"
		/>
		<Layer Type="Sprite" Texture="../white.png" Frag="chroma.frag"
			OnCommand="hidden,1;xy,scx,scy;basezoomx,sw/dw;basezoomy,-(sh)/dh;zoom,1;diffusealpha,1;sleep,0.02;queuecommand,Render;"
			RenderCommand="%function(self) self:SetTexture(h_aft:GetTexture()) self:hidden(1) table.insert(h_lumiarray,self) end"
		/>
		<Layer Type="Sprite" Texture="../white.png" Frag="chroma.frag"
			OnCommand="hidden,1;xy,scx,scy;basezoomx,sw/dw;basezoomy,-(sh)/dh;zoom,1;diffusealpha,1;sleep,0.02;queuecommand,Render;"
			RenderCommand="%function(self) self:SetTexture(h_aft:GetTexture()) self:hidden(1) table.insert(h_lumiarray,self) end"
		/>
		<Layer Type="Sprite" Texture="../white.png" Frag="chroma.frag"
			OnCommand="hidden,1;xy,scx,scy;basezoomx,sw/dw;basezoomy,-(sh)/dh;zoom,1;diffusealpha,1;sleep,0.02;queuecommand,Render;"
			RenderCommand="%function(self) self:SetTexture(h_aft:GetTexture()) self:hidden(1) table.insert(h_lumiarray,self) end"
		/>
		<Layer Type="Sprite" Texture="../white.png" Frag="chroma.frag"
			OnCommand="hidden,1;xy,scx,scy;basezoomx,sw/dw;basezoomy,-(sh)/dh;zoom,1;diffusealpha,1;sleep,0.02;queuecommand,Render;"
			RenderCommand="%function(self) self:SetTexture(h_aft:GetTexture()) self:hidden(1) table.insert(h_lumiarray,self) end"
		/>
		<Layer Type="Sprite" Texture="../white.png" Frag="chroma.frag"
			OnCommand="hidden,1;xy,scx,scy;basezoomx,sw/dw;basezoomy,-(sh)/dh;zoom,1;diffusealpha,1;sleep,0.02;queuecommand,Render;"
			RenderCommand="%function(self) self:SetTexture(h_aft:GetTexture()) self:hidden(1) table.insert(h_lumiarray,self) end"
		/>
		<Layer Type="Sprite" Texture="../white.png" Frag="chroma.frag"
			OnCommand="hidden,1;xy,scx,scy;basezoomx,sw/dw;basezoomy,-(sh)/dh;zoom,1;diffusealpha,1;sleep,0.02;queuecommand,Render;"
			RenderCommand="%function(self) self:SetTexture(h_aft:GetTexture()) self:hidden(1) table.insert(h_lumiarray,self) end"
		/>
		<Layer Type="Sprite" Texture="../white.png" Frag="chroma.frag"
			OnCommand="hidden,1;xy,scx,scy;basezoomx,sw/dw;basezoomy,-(sh)/dh;zoom,1;diffusealpha,1;sleep,0.02;queuecommand,Render;"
			RenderCommand="%function(self) self:SetTexture(h_aft:GetTexture()) self:hidden(1) table.insert(h_lumiarray,self) end"
		/>
		<Layer Type="Sprite" Texture="../white.png" Frag="chroma.frag"
			OnCommand="hidden,1;xy,scx,scy;basezoomx,sw/dw;basezoomy,-(sh)/dh;zoom,1;diffusealpha,1;sleep,0.02;queuecommand,Render;"
			RenderCommand="%function(self) self:SetTexture(h_aft:GetTexture()) self:hidden(1) table.insert(h_lumiarray,self) end"
		/>
		<Layer Type="Sprite" Texture="../white.png" Frag="chroma.frag"
			OnCommand="hidden,1;xy,scx,scy;basezoomx,sw/dw;basezoomy,-(sh)/dh;zoom,1;diffusealpha,1;sleep,0.02;queuecommand,Render;"
			RenderCommand="%function(self) self:SetTexture(h_aft:GetTexture()) self:hidden(1) table.insert(h_lumiarray,self) end"
		/>
		<Layer Type="Sprite" Texture="../white.png" Frag="chroma.frag"
			OnCommand="hidden,1;xy,scx,scy;basezoomx,sw/dw;basezoomy,-(sh)/dh;zoom,1;diffusealpha,1;sleep,0.02;queuecommand,Render;"
			RenderCommand="%function(self) self:SetTexture(h_aft:GetTexture()) self:hidden(1) table.insert(h_lumiarray,self) end"
		/>
		<Layer Type="Sprite" Texture="../white.png" Frag="chroma.frag"
			OnCommand="hidden,1;xy,scx,scy;basezoomx,sw/dw;basezoomy,-(sh)/dh;zoom,1;diffusealpha,1;sleep,0.02;queuecommand,Render;"
			RenderCommand="%function(self) self:SetTexture(h_aft:GetTexture()) self:hidden(1) table.insert(h_lumiarray,self) end"
		/>
	</children></Layer>

	<Layer Type="ActorFrame" Var="h_proxyEnv" OnCommand="fov,45"><children>
		<Layer Type="ActorProxy" OnCommand="%function(self) table.insert(h_playerproxies,self) end"/>
		<Layer Type="ActorProxy" OnCommand="%function(self) table.insert(h_playerproxies,self) end"/>
		<Layer Type="ActorProxy" OnCommand="%function(self) table.insert(h_playerproxies,self) end"/>
		<Layer Type="ActorProxy" OnCommand="%function(self) table.insert(h_playerproxies,self) end"/>
	</children></Layer>
	
	<Layer File="tex16" Var="h_noise1" OnCommand="hidden,1;texturewrapping,1;" />
	<Layer File="tex02" Var="h_noise2" OnCommand="hidden,1;texturewrapping,1;" />
	
	<Layer Type="ActorFrameTexture" Var="paint_aft" InitCommand="hidden,1" 
		OnCommand="%function(self) 
			self:SetWidth(dw)
			self:SetHeight(dh)
			self:EnableDepthBuffer(false)
			self:EnableAlphaBuffer(true)
			self:EnableFloat(false)
			self:EnablePreserveTexture(true)
			self:Create()
			self:hidden(1)
		end"
	/>

	<Layer Type="Sprite" Texture="../white.png" Frag="woah.frag" Var="h_fisheye"
		OnCommand="hidden,1;xy,scx,scy;basezoomx,sw/dw;basezoomy,-(sh)/dh;zoom,1;diffusealpha,1;sleep,0.02;queuecommand,Render;"
		RenderCommand="%function(self) self:SetTexture(h_aft:GetTexture()) self:hidden(1) end"
	/>
	
	<Layer Type="Quad" Var="h_paint_black" OnCommand="hidden,1;stretchto,0,0,sw,sh;diffuse,0,0,0,1;" />
	
	<Layer Type="Sprite" Texture="../white.png" Frag="painting.frag" Var="h_painting"
		OnCommand="hidden,1;texturewrapping,1;xy,scx,scy;basezoomx,sw/dw;basezoomy,-(sh)/dh;zoom,1;diffusealpha,1;sleep,0.02;queuecommand,Render;"
		RenderCommand="%function(self) self:SetTexture(paint_aft:GetTexture()) self:hidden(1) end"
	/>
	
	<Layer Type="ActorProxy" OnCommand="hidden,1;" Var="Proxy1F" GetProxyMessageCommand="%function(self) if P1 then self:SetTarget(P1) end end" />
	<Layer Type="ActorProxy" OnCommand="hidden,1;" Var="Proxy2F" GetProxyMessageCommand="%function(self) if P2 then self:SetTarget(P2) end end" />

</children></Layer>