<ActorFrame
    InitCommand="%function(self)

        songName = GAMESTATE:GetCurrentSong():GetSongDir();
	
		function mod_do(str,pn)
			if pn then
				GAMESTATE:ApplyGameCommand('mod,'..str,pn)
			else
				GAMESTATE:ApplyGameCommand('mod,'..str)
			end
		end
		
		sw = SCREEN_WIDTH
		sh = SCREEN_HEIGHT
	
    end"
><children>

	<Layer Type="Quad" OnCommand="hidden,1;sleep,1000" />
	
	<Layer File="easing" />
	<Layer File="modhelpers" />
	<Layer File="spicy" />
	<Layer File="spellcard" />
	
	<Layer
		Type="Quad"
		InitCommand="%function(self)
			P1=nil;P2=nil;P3=nil;P4=nil;jud1=nil;com1=nil;jud2=nil;com2=nil;jud3=nil;com3=nil;
		end"
		OnCommand="%function(self)
			
			mod_perframes = {
				
			}
			
			function mpf(s,e,f)
				table.insert(mod_perframes,{s,e,f})
			end
			
			self:hidden(1)
		
			debug_show = false;
			spb = 2/7
---------------------------------------------------------------------------------------
----------------------DON'T TOUCH IT KIDDO---------------------------------------------
---------------------------------------------------------------------------------------

			checked = false;
			mod_plr = {};
			mod_firstSeenBeat = GAMESTATE:GetSongBeat();
			local m=mod_insert
			local me=mod_ease
			local mm=mod_message
			 ch_flicker = 1
---------------------------------------------------------------------------------------
----------------------END DON'T TOUCH IT KIDDO-----------------------------------------
---------------------------------------------------------------------------------------

            --beat based mods
            --{beat_start, beat_end, mods, len_or_end, player_number}
            mods = {
				{0,404,'*100000 -1000000 cover, *1000 1x, *1000 C325, *100000 overhead','end'},
            }
            --m(i,.5,'*1000 '.. valuething ..' reverse, *1000 '.. valuething2 ..' invert','len')
			
			--beat-based ease mods
			--{time_start, time_end, mod_start, mod_end, mod, len_or_end, ease_type, player_number, sustaintime, optional_param1, optional_param2}
			--valid ease types are:
				--linear
				--inQuad    outQuad    inOutQuad    outInQuad
				--inCubic   outCubic   inOutCubic   outInCubic
				--inQuart   outQuart   inOutQuart   outInQuart
				--inQuint   outQuint   inOutQuint   outInQuint
				--inSine    outSine    inOutSine    outInSine
				--inExpo    outExpo    inOutExpo    outInExpo
				--inCirc    outCirc    inOutCirc    outInCirc
				--inElastic outElastic inOutElastic outInElastic    --can take 2 optional parameters - amplitude & period
				--inBack    outBack    inOutBack    outInBack       --can take 1 optional parameter  - spring amount
				--inBounce  outBounce  inOutBounce  outInBounce
				
			mods_ease = {
				-- EXAMPLE TWEEN: from beat 0 to 4, make rotationz go from 360 to 0 with the inOutBack tween
				--{32,40,0,1.75,'xmod','end',outInBounce},
			}
			
			--me(beat,len,str1,str2,mod,t,ease,pn,sus,opt1,opt2)
			
            --SCREAMING GUMBALL / timed message broadcaster
            --they no longer have to be in order, because they're sorted now
            curmessage = 1;
            --{beat,message,persists}
            messages = { 
				
            }
			
			m(0,12,'*1 100 dark','end')
			
			local function Plr(pn)
				return _G['P'..pn]
			end
			
			mm(8,function()
				if cap_eye then
					cap_eye:accelerate(spb*4)
					cap_eye:diffusealpha(1)
					cap_eye:zoom(1)
					cap_eye:sleep(spb*8)
					cap_eye:linear(spb*8)
					cap_eye:diffusealpha(0)
				end
			end)
			
			mm(12,function()
				for pn=1,2 do
					local a = Plr(pn)
					if a then
						a:x(sw/2)
					end
				end
			end)
			
			mpf(8,44,function(beat)
				
				local ang = beat*math.pi*0.5
				
				local zoom = 1
				local radius = 0
				
				if beat > 8 and beat < 12 then
					zoom = 2*inCirc((beat-8)/4,0,1,1)
					radius = 1*inCirc((beat-8)/4,0,1,1)
				elseif beat >= 12 and beat < 44 then
					zoom = 2-inCirc((beat-12)/32,0,1,1)
					radius = (-1+2*linear((beat-12)/32,0,1,1))
				end
				
                mod_do('*10000 '.. 50*(1 - radius) + radius*(math.cos(ang)*-50+50) .. ' flip,*10000 '.. (radius*zoom)*math.sin(ang)*-43.75 ..' split,*10000 '.. (radius*zoom)*math.sin(ang)*-18.75 ..' alternate,*10000 '.. (radius*zoom)*math.sin(ang)*31.25 ..' reverse',1)
				
				mod_do('*10000 stealth',1)
				mod_do('*10000 dark, *10000 -314.15 dizzy, *10000 drunk, *10000 tipsy',2)
				
				mod_do('*10000 '..(200*(1-zoom))..' mini')
                
                for pn=1,1 do
                    local a = Plr(pn)
                    if a then
                        a:rotationz(math.deg(ang))
                        a:x( sw/2 + 0*160*(pn*2-3) + 128*math.sin(-ang) )
                        if beat < 36 then
							a:y( sh/2 + 128*math.cos(-ang) )
						else
							local test = ((beat - 36)/8)^2
							a:y( sh/2 - (128*test) + 128*math.cos(-ang) )
						end
                    end
                end
				
			end)
			
			m(44,48,'*1000 no dizzy, *1000 no stealth',e,1)
			m(44,48,'*1000 no dizzy, *1000 no stealth',e,2)
			
			mpf(44,48,function(beat)
			
				local amp = outElastic((beat-44)/4,0,1,1)
			
				for pn=1,2 do
					local a = Plr(pn)
					if a then
						a:rotationz(0)
						a:x(sw/2 + 160*amp*(pn*2-3))
						a:y(sh*.5)
					end
				end
				
			end)
			
			mm(48,function()
				for pn=1,2 do
					local a = Plr(pn)
					if a then
						a:rotationz(0)
						a:x(sw/2 + 160*(pn*2-3))
					end
				end
			end)
			
			--[[
			m(4,8,'*10 -200 mini, *10 50 flip','end')
			
			me(12,44,-200,0,'mini','end',inCirc)
			me(8,12,100,0,'dark','end',inCirc)
			me(8,12,200,-200,'mini','end',inCirc)
			me(8,12,50,100,'flip','end',inCirc)
			me(12,44,100,0,'flip','end',inCirc)
			me(8,12,0,100,'drunk','end',inCirc)
			me(8,12,0,100,'tipsy','end',inCirc)
			
			m(12,44,'*100 100 drunk, *100 100 tipsy, *100 75 dark','end')
			]]
			
			me(8,12,100,75,'dark','end',inCirc,1,44)
			
			me(44,8,200,0,'drunk','len',outElastic)
			me(44,8,200,0,'tipsy','len',outElastic)
			me(44,76,0,-200,'hallway','end',linear)
			m(136,146,'*5 no stealth','end')
			
			
			m(44,.1,'*1000 50 stealth','len')
			m(80,.1,'*1000 50 stealth','len')
			m(112,.1,'*1000 50 stealth','len')
			m(128,.1,'*1000 50 stealth','len')
			m(132,.1,'*1000 50 stealth','len')
			m(136,.1,'*1000 50 stealth','len')
			m(138,.1,'*1000 50 stealth','len')
			m(140,.1,'*1000 50 stealth','len')
			m(141,.1,'*1000 50 stealth','len')
			m(142,.1,'*1000 50 stealth','len')
			m(143,.1,'*1000 50 stealth','len')
			
			mm(44,function()
				if cap_left then
					cap_left:accelerate(spb*28)
					cap_left:rotationx(-10)
					cap_left:zoomz(10)
					cap_left:zoomy(2)
					
					cap_left:bouncebegin(spb*4)
					cap_left:zoomz(1)
					cap_left:zoom(.7)
					cap_left:rotationx(20)
				end
				if cap_right then
					cap_right:accelerate(spb*28)
					cap_right:rotationx(-10)
					cap_right:zoomz(20)
					cap_right:zoomy(2)
					
					cap_right:bouncebegin(spb*4)
					cap_right:zoomz(1)
					cap_right:rotationx(20)
					cap_right:zoom(.7)
				end
			end)
			
			me(52,4,3,0,'reverse','len',inOutQuad)
			me(56,4,6,0,'reverse','len',inOutQuad)
			me(60,2,10,0,'reverse','len',inOutQuad)
			me(62,2,13,0,'reverse','len',inOutQuad)
			me(64,2,16,0,'reverse','len',inOutQuad)
			me(66,2,20,0,'reverse','len',inOutQuad)
			me(68,4,25,0,'reverse','len',inQuad)
			
			
			mm(72,function(self)
				for i,v in pairs(mod_plr) do
					if v then
						v:decelerate(spb*.5)
						v:zoomz(-3)
						v:accelerate(spb)
						v:zoomz(4)
						v:decelerate(spb)
						v:zoomz(-6)
						v:accelerate(spb*1.5)
						v:zoomz(15)
						v:decelerate(spb*4)
						v:zoomz(1)
					end
				end
			end)
			
			me(76,4,-150,0,'hallway','len',linear)
			me(76,4,0,50,'flip','len',outCirc)
			m(76,1,'*10000 no bumpy','len')
			local spicy_parity = 1
			for i=80,109,1 do
				me(i,1,25*spicy_parity+25,-25*spicy_parity+25,'flip','len',inCubic)
				spicy_parity = spicy_parity * -1
				mm(i,function(self)
					for i,v in pairs(mod_plr) do
						if v then
							v:zoomz(75)
							v:decelerate(spb)
							v:zoomz(1)
						end
					end
					if cap_left then
						cap_left:finishtweening()
						cap_left:zoom(.8)
						cap_left:decelerate(spb)
						cap_left:zoom(.7)
					end
					if cap_right then
						cap_right:finishtweening()
						cap_right:zoom(.8)
						cap_right:decelerate(spb)
						cap_right:zoom(.7)
					end
				end)				
			end
			
			for i=86,102,8 do
				me(i,1,0,157*spicy_parity,'dizzy','len',inCubic)
				me(i,1,0,50,'stealth','len',inCubic)
				me(i+1,1,157*spicy_parity,0,'dizzy','len',inCubic)
				me(i+1,1,50,0,'stealth','len',inCubic)
				spicy_parity = spicy_parity*-1
			end
			me(110,1,50,100,'flip','len',outQuad)
			me(111,1,100,50,'flip','len',inQuad)
			mm(110,function(self)
				for i,v in pairs(mod_plr) do
					if v then
						v:zoomz(1)
						v:accelerate(spb)
						v:zoomz(100)
						v:bouncebegin(spb)
						v:zoomz(1)
					end
				end
				if cap_left then
					cap_left:accelerate(spb)
					cap_left:rotationz(30)
					cap_left:zoom(2)
					cap_left:bouncebegin(spb)
					cap_left:rotationz(0)
					cap_left:zoom(.7)
				end
				if cap_right then
					cap_right:accelerate(spb)
					cap_right:rotationz(-30)
					cap_right:zoom(2)
					cap_right:bouncebegin(spb)
					cap_right:rotationz(0)
					cap_right:zoom(.7)
				end
			end)
			spicy_parity = 1
			for i=112,143,1 do
				me(i,1,25*spicy_parity+25,-25*spicy_parity+25,'flip','len',inCubic)
				--when 1, = 0 when -1 is spicyparity*1257
				--when 1, = everyuthing
				--me(i,1,(spicy_parity-1)*157,(spicy_parity+1)*157,'dizzy','len',inCubic)
				--me(i,1,(spicy_parity-1)*50,(spicy_parity+1)*50,'stealth','len',inCubic)
				
				if math.mod(i,4)==0 then
					me(i,1,0,100,'invert','len',inCubic)
					me(i+1,1,100,0,'invert','len',inCubic)
					if i<=134 then
						me(i,1,0,-78,'dizzy','len',inCubic)
						me(i+1,1,-78,0,'dizzy','len',inCubic)
						me(i,1,0,50,'stealth','len',inCubic)
						me(i+1,1,50,0,'stealth','len',inCubic)
					end
				end
				spicy_parity = spicy_parity * -1
				mm(i,function(self)
					for i,v in pairs(mod_plr) do
						if v then
							v:zoomz(75)
							v:decelerate(spb)
							v:zoomz(1)
						end
					end
					if cap_left then
						cap_left:finishtweening()
						cap_left:zoom(.85)
						cap_left:decelerate(spb)
						cap_left:zoom(.7)
					end
					if cap_right then
						cap_right:finishtweening()
						cap_right:zoom(.85)
						cap_right:decelerate(spb)
						cap_right:zoom(.7)
					end
				end)				
			end
			
			function resetSkew()
				for i,v in pairs(mod_plr) do
					if v then
						v:skewx(0)
					end
				end
				if cap_left then cap_left:skewx(0) end
				if cap_right then cap_right:skewx(0) end
			end
			mm(128,resetSkew)
			mm(144,resetSkew)
			mm(332,resetSkew)
			
			me(162,2,50,0,'stealth','len',linear)
			me(176,2,50,0,'stealth','len',linear)
			me(192,2,50,0,'stealth','len',linear)
			
			m(144,270,'*1000 100 sudden,*1000 100 suddenoffset','end')
			
			me(200,1,50,0,'stealth','len',linear)
			me(202,1,50,0,'stealth','len',linear)
			me(172,1,0,100,'reverse','len',outCirc)
			me(173,1,100,0,'reverse','len',outCirc)
			
			me(174,.5,0,-200,'mini','len',outQuad)
			me(174.5,.5,-200,200,'mini','len',inQuad)
			me(175,.5,200,-200,'mini','len',outQuad)
			me(175.5,.5,-200,0,'mini','len',inQuad)
			
			me(190,1,0,-200,'hallway','len',outCirc)
			me(191,1,-200,0,'hallway','len',inCirc)
			
			me(207,1,0,500,'invert','len',inQuad,nil,63)
			me(207,1,0,0,'flip','len',linear)
			
			mm(208,function(self)
				for i,v in pairs(mod_plr) do
					if v then
						v:x(SCREEN_CENTER_X+(i*2-3)*SCREEN_CENTER_X)
						v:rotationz((i*2-3)*180)
						v:decelerate(spb*2)
						v:rotationz(0)
						v:GetChild('Judgment'):x(SCREEN_CENTER_X*(i*2-3)*-.5)
						v:GetChild('Combo'):x(SCREEN_CENTER_X*(i*2-3)*-.5)
					end
				end
				if cap_left and cap_right then
					cap_left:rotationz(-180)
					cap_left:decelerate(spb*2)
					cap_left:rotationz(0)
					cap_right:rotationz(180)
					cap_right:decelerate(spb*2)
					cap_right:rotationz(0)
				end
			end,true)
			
			mm(210,function(self)
				if P2 then
					P2:bounceend(spb*.5)
					P2:rotationy(10)
					P2:bounceend(spb*.5)
					P2:rotationy(20)
					P2:bounceend(spb*.5)
					P2:rotationy(30)
					P2:bounceend(spb*.5)
					P2:rotationy(40)
				end
				if cap_right then
					cap_right:bounceend(spb*.5)
					cap_right:rotationy(30)
					cap_right:bounceend(spb*.5)
					cap_right:rotationy(40)
					cap_right:bounceend(spb*.5)
					cap_right:rotationy(50)
					cap_right:bounceend(spb*.5)
					cap_right:rotationy(60)
				end
			end)
			mm(212,function(self)
				if P1 then
					P1:bounceend(spb*.5)
					P1:rotationy(-10)
					P1:bounceend(spb*.25)
					P1:rotationy(-20)
					P1:bounceend(spb*.25)
					P1:rotationy(-25)
					P1:bounceend(spb*.5)
					P1:rotationy(-30)
					P1:bounceend(spb*.5)
					P1:rotationy(-40)
				end
				if cap_left then
					cap_left:bounceend(spb*.5)
					cap_left:rotationy(-30)
					cap_left:bounceend(spb*.25)
					cap_left:rotationy(-40)
					cap_left:bounceend(spb*.25)
					cap_left:rotationy(-45)
					cap_left:bounceend(spb*.5)
					cap_left:rotationy(-50)
					cap_left:bounceend(spb*.5)
					cap_left:rotationy(-60)
				end
			end)
			mm(214,function(self)
				if P1 then
					P1:bounceend(spb*.5)
					P1:rotationy(-20)
					P1:bounceend(spb*1.5)
					P1:rotationy(0)
				end
				if P2 then
					P2:bounceend(spb*.5)
					P2:rotationy(20)
					P2:bounceend(spb*1.5)
					P2:rotationy(0)
				end
				if cap_left then
					cap_left:bounceend(spb*.5)
					cap_left:rotationy(-40)
					cap_left:bounceend(spb*1.5)
					cap_left:rotationy(-20)
				end
				if cap_right then
					cap_right:bounceend(spb*.5)
					cap_right:rotationy(40)
					cap_right:bounceend(spb*1.5)
					cap_right:rotationy(20)
				end

			end)
			
			mm(216,function(self)
				for i,v in pairs(mod_plr) do
					if v then
						v:rotationz((i*2-3)*360)
						v:decelerate(spb*2)
						v:rotationz(0)
					end
				end
				if cap_left and cap_right then
					cap_left:rotationz(-360)
					cap_left:decelerate(spb*2)
					cap_left:rotationz(0)
					cap_right:rotationz(360)
					cap_right:decelerate(spb*2)
					cap_right:rotationz(0)
				end
			end)
			
			mm(218,function(self)
				if P1 then
					P1:bounceend(spb*.5)
					P1:zoomy(.9)
					P1:bounceend(spb*.5)
					P1:zoomy(.8)
					P1:bounceend(spb*.5)
					P1:zoomy(.7)
					P1:bounceend(spb*.5)
					P1:zoomy(.6)
				end
				if cap_left then
					cap_left:bounceend(spb*.5)
					cap_left:zoomy(.6)
					cap_left:bounceend(spb*.5)
					cap_left:zoomy(.5)
					cap_left:bounceend(spb*.5)
					cap_left:zoomy(.4)
					cap_left:bounceend(spb*.5)
					cap_left:zoomy(.3)
				end
			end)
			
			mm(220,function(self)
				if P2 then
					P2:bounceend(spb*.5)
					P2:skewx(-.3)
					P2:bounceend(spb*.5)
					P2:skewx(-.6)
					P2:bounceend(spb*.5)
					P2:skewx(-1)
					P2:bounceend(spb*.5)
					P2:skewx(-1.5)
				end
				if cap_right then
					cap_right:bounceend(spb*.5)
					cap_right:skewx(-.3)
					cap_right:bounceend(spb*.5)
					cap_right:skewx(-.6)
					cap_right:bounceend(spb*.5)
					cap_right:skewx(-1)
					cap_right:bounceend(spb*.5)
					cap_right:skewx(-1.5)
				end
			end)
			
			mm(222,function(self)
				if P1 then
					P1:bounceend(spb*.5)
					P1:zoomy(.8)
					P1:bounceend(spb*1.5)
					P1:zoomy(1)
				end
				if P2 then
					P2:bounceend(spb*.5)
					P2:skewx(-.75)
					P2:bounceend(spb*1.5)
					P2:skewx(0)
				end
				if cap_left then
					cap_left:bounceend(spb*.5)
					cap_left:zoomy(.5)
					cap_left:bounceend(spb*1.5)
					cap_left:zoomy(.7)
				end
				if cap_right then
					cap_right:bounceend(spb*.5)
					cap_right:skewx(-.75)
					cap_right:bounceend(spb*1.5)
					cap_right:skewx(0)
				end
			end)
			
			mm(224,function(self)
				for i,v in pairs(mod_plr) do
					if v then
						v:rotationz((i*2-3)*360)
						v:decelerate(spb*2)
						v:rotationz(0)
					end
				end
				if cap_left and cap_right then
					cap_left:rotationz(-360)
					cap_left:decelerate(spb*2)
					cap_left:rotationz(0)
					cap_right:rotationz(360)
					cap_right:decelerate(spb*2)
					cap_right:rotationz(0)
				end
			end)
			mm(226,function(self)
				if P2 then
					P2:bounceend(spb*.5)
					P2:zoomz(10)
					P2:bounceend(spb*.5)
					P2:zoomz(20)
					P2:bounceend(spb*.5)
					P2:zoomz(30)
					P2:bounceend(spb*.5)
					P2:zoomz(40)
				end
				if cap_right then
					cap_right:bounceend(spb*.5)
					cap_right:zoomz(10)
					cap_right:bounceend(spb*.5)
					cap_right:zoomz(20)
					cap_right:bounceend(spb*.5)
					cap_right:zoomz(30)
					cap_right:bounceend(spb*.5)
					cap_right:zoomz(40)
				end

			end)
			mm(228,function(self)
				if P1 then
					P1:bounceend(spb*.5)
					P1:zoomz(-10)
					P1:bounceend(spb*.25)
					P1:zoomz(-20)
					P1:bounceend(spb*.25)
					P1:zoomz(-25)
					P1:bounceend(spb*.5)
					P1:zoomz(-30)
					P1:bounceend(spb*.5)
					P1:zoomz(-40)
				end
				if cap_left then
					cap_left:bounceend(spb*.5)
					cap_left:zoomz(-10)
					cap_left:bounceend(spb*.25)
					cap_left:zoomz(-20)
					cap_left:bounceend(spb*.25)
					cap_left:zoomz(-25)
					cap_left:bounceend(spb*.5)
					cap_left:zoomz(-30)
					cap_left:bounceend(spb*.5)
					cap_left:zoomz(-40)
				end
			end)
			mm(230,function(self)
				if P1 then
					P1:bounceend(spb*.5)
					P1:zoomz(-20)
					P1:bounceend(spb*1.5)
					P1:zoomz(1)
				end
				if P2 then
					P2:bounceend(spb*.5)
					P2:zoomz(20)
					P2:bounceend(spb*1.5)
					P2:zoomz(1)
				end
				if cap_left then
					cap_left:bounceend(spb*.5)
					cap_left:zoomz(-20)
					cap_left:bounceend(spb*1.5)
					cap_left:zoomz(1)
				end
				if cap_right then
					cap_right:bounceend(spb*.5)
					cap_right:zoomz(20)
					cap_right:bounceend(spb*1.5)
					cap_right:zoomz(1)
				end
			end)
			
			local prevtipsy = 15
			for i=232,236,.5 do
				me(i,.5,prevtipsy,prevtipsy * -1 - prevtipsy/2,'tipsy','len',outBack,1)
				me(i,.5,-1*prevtipsy,(prevtipsy * -1 - prevtipsy/2)*-1,'tipsy','len',outBack,2)
				prevtipsy = prevtipsy * -1 - prevtipsy/2
			end
			me(237,.5,prevtipsy,prevtipsy*.5,'tipsy','len',outBack,1)
			me(237,.5,prevtipsy*-1,prevtipsy*1.5,'tipsy','len',outBack,2)
			me(237.5,.5,prevtipsy*.5,0,'tipsy','len',outBack,1)
			me(237.5,.5,prevtipsy*-.5,0,'tipsy','len',outBack,2)
			
			me(238,1,0,-200,'hallway','len',outCirc)
			me(239,1,-200,0,'hallway','len',inCirc)
			
			mm(240,function(self)
				for i,v in pairs(mod_plr) do
					if v then
						v:rotationz((i*2-3)*360)
						v:decelerate(spb*2)
						v:rotationz(0)
					end
				end
				if cap_left and cap_right then
					cap_left:rotationz(-360)
					cap_left:decelerate(spb*2)
					cap_left:rotationz(0)
					cap_right:rotationz(360)
					cap_right:decelerate(spb*2)
					cap_right:rotationz(0)
				end
			end)
			
			mm(242,function(self)
				for i,v in ipairs(mod_plr) do
					if v then
						v:bounceend(spb*.5)
						v:rotationy(10)
						v:bounceend(spb*.5)
						v:rotationy(20)
						v:bounceend(spb*.5)
						v:rotationy(30)
						v:bounceend(spb*.5)
						v:rotationy(40)
					end
				end
				if cap_left and cap_right then
					cap_left:bounceend(spb*.5)
					cap_left:rotationy(-10)
					cap_left:bounceend(spb*.5)
					cap_left:rotationy(0)
					cap_left:bounceend(spb*.5)
					cap_left:rotationy(10)
					cap_left:bounceend(spb*.5)
					cap_left:rotationy(20)
					cap_right:bounceend(spb*.5)
					cap_right:rotationy(30)
					cap_right:bounceend(spb*.5)
					cap_right:rotationy(40)
					cap_right:bounceend(spb*.5)
					cap_right:rotationy(50)
					cap_right:bounceend(spb*.5)
					cap_right:rotationy(60)
				end
			end)
			mm(244,function(self)
				for i,v in ipairs(mod_plr) do
					if v then
						v:bounceend(spb*.5)
						v:rotationx(10)
						v:bounceend(spb*.25)
						v:rotationx(20)
						v:bounceend(spb*.25)
						v:rotationx(25)
						v:bounceend(spb*.5)
						v:rotationx(30)
						v:bounceend(spb*.5)
						v:rotationx(40)
					end
				end
				if cap_left and cap_right then
					cap_left:bounceend(spb*.5)
					cap_left:rotationx(30)
					cap_left:bounceend(spb*.25)
					cap_left:rotationx(40)
					cap_left:bounceend(spb*.25)
					cap_left:rotationx(45)
					cap_left:bounceend(spb*.5)
					cap_left:rotationx(50)
					cap_left:bounceend(spb*.5)
					cap_left:rotationx(60)
					cap_right:bounceend(spb*.5)
					cap_right:rotationx(30)
					cap_right:bounceend(spb*.25)
					cap_right:rotationx(40)
					cap_right:bounceend(spb*.25)
					cap_right:rotationx(45)
					cap_right:bounceend(spb*.5)
					cap_right:rotationx(50)
					cap_right:bounceend(spb*.5)
					cap_right:rotationx(60)
				end
			end)
			mm(246,function(self)
				for i,v in ipairs(mod_plr) do
					if v then
						v:bounceend(spb*.5)
						v:rotationx(20)
						v:rotationy(20)
						v:bounceend(spb*1.5)
						v:rotationx(0)
						v:rotationy(0)
					end
				end
				if cap_left and cap_right then
					cap_left:bounceend(spb*.5)
					cap_left:rotationx(20)
					cap_left:rotationy(20)
					cap_left:bounceend(spb*1.5)
					cap_left:rotationx(0)
					cap_left:rotationy(-20)
					cap_right:bounceend(spb*.5)
					cap_right:rotationx(20)
					cap_right:rotationy(40)
					cap_right:bounceend(spb*1.5)
					cap_right:rotationx(0)
					cap_right:rotationy(20)
				end
			end)
			mm(248,function(self)
				for i,v in pairs(mod_plr) do
					if v then
						v:rotationz((i*2-3)*360)
						v:decelerate(spb*2)
						v:rotationz(0)
					end
				end
				if cap_left and cap_right then
					cap_left:rotationz(-360)
					cap_left:decelerate(spb*2)
					cap_left:rotationz(0)
					cap_right:rotationz(360)
					cap_right:decelerate(spb*2)
					cap_right:rotationz(0)
				end
			end)
			mm(250,function(self)
				for i,v in ipairs(mod_plr) do
					if v then
						v:bounceend(spb*.5)
						v:zoomx(1.15)
						v:bounceend(spb*.5)
						v:zoomx(1.3)
						v:bounceend(spb*.5)
						v:zoomx(1.45)
						v:bounceend(spb*.5)
						v:zoomx(1.6)
					end
				end
				if cap_left and cap_right then
					cap_left:bounceend(spb*.5)
					cap_left:zoomx(.85)
					cap_left:bounceend(spb*.5)
					cap_left:zoomx(1)
					cap_left:bounceend(spb*.5)
					cap_left:zoomx(1.15)
					cap_left:bounceend(spb*.5)
					cap_left:zoomx(1.3)
					cap_right:bounceend(spb*.5)
					cap_right:zoomx(.85)
					cap_right:bounceend(spb*.5)
					cap_right:zoomx(1)
					cap_right:bounceend(spb*.5)
					cap_right:zoomx(1.15)
					cap_right:bounceend(spb*.5)
					cap_right:zoomx(1.3)
				end
			end)
			mm(252,function(self)
				for i,v in ipairs(mod_plr) do
					if v then
						v:bounceend(spb*.5)
						v:skewx(.5)
						v:bounceend(spb*.5)
						v:skewx(1)
						v:bounceend(spb*.5)
						v:skewx(1.5)
						v:bounceend(spb*.5)
						v:skewx(2)
					end
				end
				if cap_left and cap_right then
					cap_left:bounceend(spb*.5)
					cap_left:skewx(.5)
					cap_left:bounceend(spb*.5)
					cap_left:skewx(1)
					cap_left:bounceend(spb*.5)
					cap_left:skewx(1.5)
					cap_left:bounceend(spb*.5)
					cap_left:skewx(2)
					cap_right:bounceend(spb*.5)
					cap_right:skewx(.5)
					cap_right:bounceend(spb*.5)
					cap_right:skewx(1)
					cap_right:bounceend(spb*.5)
					cap_right:skewx(1.5)
					cap_right:bounceend(spb*.5)
					cap_right:skewx(2)
				end
			end)
			mm(254,function(self)
				for i,v in ipairs(mod_plr) do
					if v then
						v:bounceend(spb*2)
						v:skewx(0)
						v:zoomx(1)
					end
				end
				if cap_left and cap_right then
					cap_left:bounceend(spb*2)
					cap_left:skewx(0)
					cap_left:zoomx(.7)
					cap_right:bounceend(spb*2)
					cap_right:skewx(0)
					cap_right:zoomx(.7)
				end
			end)
			mm(256,function(self)
				for i,v in pairs(mod_plr) do
					if v then
						v:rotationz((i*2-3)*180)
						v:decelerate(spb*1)
						v:rotationz(0)
					end
				end
				if cap_left and cap_right then
					cap_left:rotationz(-180)
					cap_left:decelerate(spb*2)
					cap_left:rotationz(0)
					cap_right:rotationz(180)
					cap_right:decelerate(spb*2)
					cap_right:rotationz(0)
				end
			end)
			mm(258,function(self)
				for i,v in ipairs(mod_plr) do
					if v then
						v:bounceend(spb*.5)
						v:zoomz(10)
						v:bounceend(spb*.5)
						v:zoomz(20)
						v:bounceend(spb*.5)
						v:zoomz(30)
						v:bounceend(spb*.5)
						v:zoomz(40)
					end
				end
				if cap_left and cap_right then
					cap_left:bounceend(spb*.5)
					cap_left:zoomz(10)
					cap_left:bounceend(spb*.5)
					cap_left:zoomz(20)
					cap_left:bounceend(spb*.5)
					cap_left:zoomz(30)
					cap_left:bounceend(spb*.5)
					cap_left:zoomz(40)
					cap_right:bounceend(spb*.5)
					cap_right:zoomz(10)
					cap_right:bounceend(spb*.5)
					cap_right:zoomz(20)
					cap_right:bounceend(spb*.5)
					cap_right:zoomz(30)
					cap_right:bounceend(spb*.5)
					cap_right:zoomz(40)
				end
			end)
			mm(260,function(self)
				for i,v in ipairs(mod_plr) do
					if v then
						v:bounceend(spb*.5)
						v:zoomz(20)
						v:bounceend(spb*.25)
						v:zoomz(10)
						v:bounceend(spb*.25)
						v:zoomz(0)
						v:bounceend(spb*.5)
						v:zoomz(-20)
						v:bounceend(spb*.5)
						v:zoomz(-40)
						v:bounceend(spb*2)
						v:zoomz(1)
					end
				end
				if cap_left and cap_right then
					cap_left:bounceend(spb*.5)
					cap_left:zoomz(20)
					cap_left:bounceend(spb*.25)
					cap_left:zoomz(10)
					cap_left:bounceend(spb*.25)
					cap_left:zoomz(0)
					cap_left:bounceend(spb*.5)
					cap_left:zoomz(-20)
					cap_left:bounceend(spb*.5)
					cap_left:zoomz(-40)
					cap_left:bounceend(spb*2)
					cap_left:zoomz(1)
					cap_right:bounceend(spb*.5)
					cap_right:zoomz(20)
					cap_right:bounceend(spb*.25)
					cap_right:zoomz(10)
					cap_right:bounceend(spb*.25)
					cap_right:zoomz(0)
					cap_right:bounceend(spb*.5)
					cap_right:zoomz(-20)
					cap_right:bounceend(spb*.5)
					cap_right:zoomz(-40)
					cap_right:bounceend(spb*2)
					cap_right:zoomz(1)
				end
			end)
			mm(264,function(self)
			
				if cap_left and cap_right then
					cap_left:accelerate(spb*6)
					cap_left:zoom(1.5)
					cap_left:zoomz(10)
					cap_left:accelerate(spb*2)
					cap_left:zoomz(1)
					cap_left:zoom(.7)
					cap_right:accelerate(spb*6)
					cap_right:zoom(1.5)
					cap_right:zoomz(10)
					cap_right:accelerate(spb*2)
					cap_right:zoom(.7)
					cap_right:zoomz(1.5)
				end
			end)
			mm(270,function(self)
				for i,v in ipairs(mod_plr) do
					if v then
						v:accelerate(spb*2)
						v:zoomz(10)
						v:x(SCREEN_CENTER_X)
						v:sleep(0)
						v:zoomz(1)
						
						v:GetChild('Judgment'):accelerate(spb*2)
						v:GetChild('Judgment'):x(SCREEN_CENTER_X*(i*2-3)*.5)
						v:GetChild('Combo'):accelerate(spb*2)
						v:GetChild('Combo'):x(SCREEN_CENTER_X*(i*2-3)*.5)
					end
				end
				
			end,true)
			me(270,1,0,-105,'hallway','len',outCirc)
			me(270,2,500,0,'invert','len',inCirc,nil,1)
			me(270,2,0,0,'flip','len',inCirc,nil,1)
			me(271,1,-105,100,'hallway','len',inCirc)
			me(271,1,0,50,'reverse','len',inCirc)
			--0,600 \ 100,400 \ 100,500 \ 0,500
			--100,500 \ 100,400 \ 0,600 \ 0,500
			me(214,1,-50,100,'mini','len',outCubic)
			me(215,1,100,0,'mini','len',inCubic,nil,1)
			me(230,1,0,100,'mini','len',outCubic)
			me(231,1,100,0,'mini','len',inCubic,nil,1)
			me(262,1,0,100,'mini','len',outCubic)
			me(263,1,100,0,'mini','len',inCubic,nil,1)
			local fliptable = {{0,100,100,0},{100,100,0,0}}
			local invtable = {{600,400,500,500},{500,400,600,500}}
			local flipprev = {0,0}
			local invprev = {500,500}
			for i=264,270,.5 do
				local indextrack = math.mod(i*2-528,4)+1
				me(i,.5,flipprev[1],fliptable[1][indextrack],'flip','len',outBack,1)
				me(i,.5,invprev[1],invtable[1][indextrack],'invert','len',outBack,1)
				me(i,.5,flipprev[2],fliptable[2][indextrack],'flip','len',outBack,2)
				me(i,.5,invprev[2],invtable[2][indextrack],'invert','len',outBack,2)
				flipprev[1] = fliptable[1][indextrack]
				invprev[1] = invtable[1][indextrack]
				flipprev[2] = fliptable[2][indextrack]
				invprev[2] = invtable[2][indextrack]
			end
			
			m(272,294,'*10000 100 stealth','end',1)
			m(272,294,'*10000 50 reverse, *10000 100 dark, *1000 50 dizzy','end',2)
			function spicy_und(beat,leng,start,fin,name,twee1,twee2,plr)
				me(beat,leng,start,fin,name,'len',twee1,plr)
				me(beat+leng,leng,fin,start,name,'len',twee2,plr)
			end
			
			if FUCK_EXE then
				m(272,294,'*10000 -99 drawsizeback, *10000 stealthtype','end')
			end
			
			spicy_und(272,2,50,100,'reverse',outQuad,inQuad,1)
			spicy_und(272,2,0,300,'drunk',outCirc,inCirc,1)
			spicy_und(272,2,0,300,'tipsy',outCirc,inCirc,1)
			me(272,2,314,0,'dizzy','len',outCirc,nil,2)
			
			spicy_und(276,2,50,0,'reverse',outQuad,inQuad,1)
			spicy_und(276,2,0,-300,'drunk',outCirc,inCirc,1)
			spicy_und(276,2,0,-300,'tipsy',outCirc,inCirc,1)
			me(276,2,-314,0,'dizzy','len',outCirc,nil,2)
			
			me(280,1,0,100,'flip','len',outCirc,nil,3)
			me(284,1,100,0,'flip','len',outCirc,nil,1)			
			spicy_und(280,2,50,100,'reverse',outQuad,inQuad,1)
			spicy_und(280,2,0,300,'drunk',outCirc,inCirc,1)
			spicy_und(280,2,0,300,'tipsy',outCirc,inCirc,1)
			me(280,2,314,0,'dizzy','len',outCirc,nil,2)
			
			spicy_und(284,2,50,0,'reverse',outQuad,inQuad,1)
			spicy_und(284,2,0,-300,'drunk',outCirc,inCirc,1)
			spicy_und(284,2,0,-300,'tipsy',outCirc,inCirc,1)
			me(284,2,-314,0,'dizzy','len',outCirc,nil,2)
			me(284,288,1.5476,1.5476*2,'xmod','end',linear,nil,294)
			
			spicy_und(288,1,50,100,'reverse',outQuad,inQuad,1)
			spicy_und(288,1,0,500,'drunk',outCirc,inCirc,1)
			spicy_und(288,1,0,500,'tipsy',outCirc,inCirc,1)
			me(288,1,314,0,'dizzy','len',outCirc,nil,1)
			
			spicy_und(290,1,50,0,'reverse',outQuad,inQuad,1)
			spicy_und(290,1,0,-500,'drunk',outCirc,inCirc,1)
			spicy_und(290,1,0,-500,'tipsy',outCirc,inCirc,1)
			me(290,1,-314,0,'dizzy','len',outCirc,nil,1)
			
			spicy_und(292,1,50,100,'reverse',outQuad,inQuad,1)
			spicy_und(292,1,0,500,'drunk',outCirc,inCirc,1)
			spicy_und(292,1,0,500,'tipsy',outCirc,inCirc,1)
			me(292,1,314,0,'dizzy','len',outCirc,nil,1)
			
			me(294,2,100,0,'stealth','len',linear)
			me(294,2,50,0,'reverse','len',outCirc)
			me(294,2,0,0,'drunk','len',linear)
			me(294,2,0,0,'tipsy','len',linear)
			
			spicy_und(296,1,0,100,'reverse',outCirc,outCirc,nil)
			spicy_und(298,1,0,100,'reverse',outCirc,outCirc,nil)
			me(300,8,0,10,'hallway','len',linear)
			me(300,8,0,50,'reverse','len',linear)
			me(308,4,50,0,'reverse','len',outCirc)
			--spicy_und(294,1,50,0,'reverse',outQuad,inQuad,1)
			--spicy_und(294,1,0,-500,'drunk',outCirc,inCirc,1)
			--spicy_und(294,1,0,-500,'tipsy',outCirc,inCirc,1)
			--me(294,1,-314,0,'dizzy','len',outCirc,nil,1)
			mm(300,function(self)
				for i,v in pairs(mod_plr) do
					if v then
						v:accelerate(spb*4)
						v:rotationz(720)
						v:zoomz(100)
						v:linear(spb*4)
						v:rotationz(3600)
						v:sleep(0)
						v:zoomz(1)
					end
				end
			end)
			mm(308,function(self)
				for i,v in pairs(mod_plr) do
					if v then
						v:vibrate()
						v:effectmagnitude(0,50,0)
					end
				end
				if cap_eye then
					cap_eye:diffusealpha(1)
				end
			end)
			mm(312,function(self)
				for i,v in pairs(mod_plr) do
					if v then
						v:stopeffect()
					end
				end
				
			end)
			m(312,4,'*1000 -50 flip, *1000 100 invert','len',1)
			m(312,4,'*1000 150 flip, *1000 -100 invert','len',2)
			--m(316,11111,'*1000 100 reverse','len',2)
			
			ch_swapLock = {{-156.25,68.75},{50,-200},{131.25,-243.75},{50,200}}
			--ch_swapLock = {{-200,250},{50,-500},{50,-500},{300,-250}}
			
			for i=312,316,.25 do
				local multiplier = (i-312)/4
				m(i,.25,'*1000 '.. ch_swapLock[1][1]*multiplier ..' flip, *1000 '.. ch_swapLock[1][2]*multiplier ..' invert','len',1)
				m(i,.25,'*1000 '.. ch_swapLock[3][1]*multiplier ..' flip, *1000 '.. ch_swapLock[3][2]*multiplier ..' invert','len',2)
				m(i,.25,'*1000 '.. -25*multiplier ..' reverse','len')
				m(i,.1,'*1000 50 stealth, *1000 no dark','len')
				m(i+.1,.15,'*1000 stealth, *1000 dark','len')
			end
			
			me(316,4,131.25,-156.25,'flip','len',linear,2)
			me(316,4,-243.75,68.75,'invert','len',linear,2)	
			
			for i=316,332,16 do
				me(i,2,-156.25,-156.25,'flip','len',linear,1)
				me(i,2,68.75,343.75,'invert','len',linear,1)				
				me(i+2,6,-156.25,256.25,'flip','len',linear,1)
				me(i+2,6,343.75,-68.75,'invert','len',linear,1)				
				me(i+8,2,256.25,256.25,'flip','len',linear,1)
				me(i+8,2,-68.75,-343.75,'invert','len',linear,1)				
				me(i+10,6,256.25,-156.25,'flip','len',linear,1)
				me(i+10,6,-343.75,68.75,'invert','len',linear,1)
				
				me(4+i,2,-156.25,-156.25,'flip','len',linear,2)
				me(4+i,2,68.75,343.75,'invert','len',linear,2)				
				me(4+i+2,6,-156.25,256.25,'flip','len',linear,2)
				me(4+i+2,6,343.75,-68.75,'invert','len',linear,2)				
				me(4+i+8,2,256.25,256.25,'flip','len',linear,2)
				me(4+i+8,2,-68.75,-343.75,'invert','len',linear,2)				
				me(4+i+10,6,256.25,-156.25,'flip','len',linear,2)
				me(4+i+10,6,-343.75,68.75,'invert','len',linear,2)
			end
			me(348,2,131.25,-156.25,'flip','len',linear,2)
			me(348,2,-243.75,68.75,'invert','len',linear,2)	
			for i=348,372,8 do
				me(i,1,-156.25,-156.25,'flip','len',linear,1)
				me(i,1,68.75,343.75,'invert','len',linear,1)				
				me(i+1,3,-156.25,256.25,'flip','len',linear,1)
				me(i+1,3,343.75,-68.75,'invert','len',linear,1)				
				me(i+4,1,256.25,256.25,'flip','len',linear,1)
				me(i+4,1,-68.75,-343.75,'invert','len',linear,1)				
				me(i+5,3,256.25,-156.25,'flip','len',linear,1)
				me(i+5,3,-343.75,68.75,'invert','len',linear,1)
				
				me(2+i,1,-156.25,-156.25,'flip','len',linear,2)
				me(2+i,1,68.75,343.75,'invert','len',linear,2)				
				me(2+i+1,3,-156.25,256.25,'flip','len',linear,2)
				me(2+i+1,3,343.75,-68.75,'invert','len',linear,2)				
				me(2+i+4,1,256.25,256.25,'flip','len',linear,2)
				me(2+i+4,1,-68.75,-343.75,'invert','len',linear,2)				
				me(2+i+5,3,256.25,-156.25,'flip','len',linear,2)
				me(2+i+5,3,-343.75,68.75,'invert','len',linear,2)
			end
			
			--m(316,372,'*1000 100 centered','end')
			--m(316,372,'*1000 50 boost','end',2)
			
			me(378,2,256.25,0,'flip','len',inQuad,2,4)
			me(378,2,-68.75,0,'invert','len',inQuad,2,4)
			
			me(378,2,-206.25,0,'flip','len',inQuad,1)
			me(378,2,-206.25,0,'invert','len',inQuad,1)
			
			me(376,2,0,-206.25,'bumpy','len',outQuad,1)
			me(376,2,0,206.25,'bumpy','len',outQuad,2)
			me(378,2,-206.25,0,'bumpy','len',inQuad,1)
			me(378,2,206.25,0,'bumpy','len',inQuad,2)
			
			
			me(344,1,0,-160,'hallway','len',outCirc)
			me(345,1,-160,0,'hallway','len',inCirc)
			
			me(346,1,0,200,'hallway','len',outCirc)
			me(347,1,200,0,'hallway','len',inCirc)
			
			
			
			me(314,376,0,15,'dizzy','end',linear,1)
			me(314,376,0,-15,'dizzy','end',linear,2)
			ch_P1Parse = {}
			ch_P2Parse = {}
			
			for i,v in pairs(ch_spicy) do
				if math.mod(i,2) == 1 then
					table.insert(ch_P1Parse,{v[1],v[2]})
				else
					table.insert(ch_P2Parse,{v[1],v[2]})
				end
			end
			--LD UR -50 100
			--LU DR 50 -200
			--RU DL 150 -100
			--RD UL 50 200
			
			ch_P1lock = 0
			ch_P2lock = 2
			
			for i=1,table.getn(ch_P1Parse)-1,1 do
				local cufk = 1
				local oldLock = ch_P1lock
				local col = ch_P1Parse[i][2]
				if col == 0 or col == 3 then cufk = 2 end
				ch_P1lock = math.mod(ch_P1lock+cufk,4)
				--me(ch_P1Parse[i][1],ch_P1Parse[i+1][1],ch_swapLock[oldLock+1][1],ch_swapLock[ch_P1lock+1][1],'flip','end',inOutBack,1)
				--me(ch_P1Parse[i][1],ch_P1Parse[i+1][1],ch_swapLock[oldLock+1][2],ch_swapLock[ch_P1lock+1][2],'invert','end',inOutBack,1)
			end
			for i=1,table.getn(ch_P2Parse)-1,1 do
				local cufk = 1
				local oldLock = ch_P2lock
				local col = ch_P2Parse[i][2]
				if col == 0 or col == 3 then cufk = 2 end
				ch_P2lock = math.mod(ch_P2lock+cufk,4)
				--me(ch_P2Parse[i][1],ch_P2Parse[i+1][1],ch_swapLock[oldLock+1][1],ch_swapLock[ch_P2lock+1][1],'flip','end',inOutBack,2)
				--me(ch_P2Parse[i][1],ch_P2Parse[i+1][1],ch_swapLock[oldLock+1][2],ch_swapLock[ch_P2lock+1][2],'invert','end',inOutBack,2)
			end
			
			local ch_stealthparity = 1
			for i=316.5,374.5,1 do
				m(i,1,'*1000 '.. ch_stealthparity*25+25 ..' stealth','len',1)
				m(i,1,'*1000 '.. ch_stealthparity*-25+25 ..' stealth','len',2)
				ch_stealthparity = ch_stealthparity * -1
				local funcparity = ch_stealthparity
				mm(i,function(self)
					local pnum = (funcparity+3)/2
					local v = mod_plr[pnum]
					if v then
						--v:zoomz(-50)
					end
				end)
				mm(i+1,function(self)
					local pnum = (funcparity+3)/2
					local v = mod_plr[pnum]
					if v then
						--v:zoomz(1)
					end
				end)	
			end
					
			mm(376,function()
				for i,v in ipairs(mod_plr) do
					if v then
						v:decelerate(spb)
							v:skewx(-1)
						v:accelerate(spb)
							v:skewx(0)
							v:rotationy(0)
							v:rotationx(0)
							v:rotationz(0)
						v:decelerate(spb)
							v:zoomy(3)
							v:zoomx(.5)
							v:skewx(3)
						v:accelerate(spb)
							v:zoomy(1)
							v:zoomx(1)
							v:skewx(0)
					end
				end
			end,true)
			m(316,376,'*100000 C320','end')
			me(380,404,0,-100,'hallway','end',linear)
			me(380,400,0,100,'flip','end',linear,nil,404)
			me(380,400,0,-100,'tornado','end',linear,nil,404)
			me(380,404,1.5,.5,'xmod','end',linear)
			--me(380,404,0,120,'wave','end',linear)
			me(380,404,0,100,'boost','end',linear)
			--me(399,404,0,50,'reverse','end',outInCirc,nil,410)
			me(399,404,0,150,'centered','end',outInCirc)
			me(399,404,0,628,'dizzy','end',outInCirc)
			me(402,404,0,-628,'mini','end',outInCirc)
			me(404,404.5,0,100,'dark','end',linear,nil,500)
			me(402,404,100,50,'flip','end',linear,nil,500)
			m(404,999,'*100000 50 reverse,*100000 0x, *10000 no tornado, *10000 50 flip, *100000 no hallway','len')
			me(404,12,628,-134,'dizzy','len',outCirc,nil,111)
			mm(399,function()
				for i,v in ipairs(mod_plr) do
					if v then
						v:decelerate(spb*2)
							v:zoomz(-10)
						v:accelerate(spb*1)
							v:zoomz(1)
						v:bouncebegin(spb*2)
							v:zoomz(500)
					end
				end
			end,true)
			
			
			
			
			
			
			--------------------------------------------
			--taro
			
			--BG STUFF
			
			mm(12,function()
				
				cap_bgcover:linear(5)
				cap_bgcover:diffusealpha(.5)
				
			end)
			
			mm(32,function()
				
				cap_bgcover:diffusealpha(.5)
				
			end,true)
			
			mm(76,function()
				
				cap_bgcover:linear(spb*4)
				cap_bgcover:diffusealpha(1)
				cap_bgcover:linear(.2)
				cap_bgcover:diffusealpha(.5)
				
				
				
			end)
			
			mm(80,function()
				
				cap_bg_all:playcommand('Pulse')
				cap_left:wag()
				cap_left:effectclock('bgm')
				cap_left:effectperiod(4)
				cap_left:effectmagnitude(0,0,2)
				cap_right:wag()
				cap_right:effectclock('bgm')
				cap_right:effectperiod(4)
				cap_right:effectoffset(2)
				cap_right:effectmagnitude(0,0,2)
			end,true)
			
			mm(176,function()
				
				cap_left:effectperiod(2)
				cap_left:effectmagnitude(0,0,4)
				cap_right:effectperiod(2)
				cap_right:effectoffset(1)
				cap_right:effectmagnitude(0,0,4)
				
			end,true)
			
			mm(204,function()
				
				cap_bgcover:linear(spb*4)
				cap_bgcover:diffusealpha(.9)
				
			end,true)
			
			mm(208,function()
				cap_left:stopeffect()
				cap_right:stopeffect()
				cap_bg_all:playcommand('Glow')
				
			end,true)
			
			for i=0,3 do
				mm(272+4*i,function()
					cap_bgcover:diffusealpha(0)
					cap_bgcover:linear(spb*2)
					cap_bgcover:diffusealpha(1)
				end)
			end
			for i=0,3 do
				mm(288+2*i,function()
					cap_bgcover:diffusealpha(0)
					cap_bgcover:linear(spb*2)
					cap_bgcover:diffusealpha(1)
				end)
			end
			
			mm(308-.2,function()
				
				cap_static:linear(.3)
				cap_static:diffusealpha(.4)
				cap_static:sleep(spb*4		 - .3)
				cap_static:linear(spb*4)
				cap_static:diffusealpha(0)
				
				cap_bgcover:linear(.2)
				cap_bgcover:diffusealpha(0)
				cap_bgcover:linear(spb*6)
				cap_bgcover:diffusealpha(.7)
				
				cap_bgcover:linear(spb*6)
				cap_metal:texcoordvelocity(0,1.2);
				cap_metal:diffusealpha(1);
				
			end)
			
			mm(316-.3,function()
				
				cap_bg_all:playcommand('No')
				cap_bg_all:playcommand('Pulse')
				cap_bgcover:linear(.2)
				cap_bgcover:diffusealpha(.7)
				
				cap_bg_all:playcommand('TapeOn')
				
			end,true)
			
			for i=348.5,375 do
				
				mm(i,function()
					cap_static:diffusealpha(.1)
					cap_static:linear(spb*.9)
					cap_static:diffusealpha(0)
				end)
				
			end
			
			mm(348,function()
				cap_left:pulse()
				cap_left:effectclock('bgm')
				cap_left:effectperiod(1)
				cap_left:effectoffset(0)
				cap_left:effectmagnitude(.7,1,0)
				cap_right:pulse()
				cap_right:effectclock('bgm')
				cap_right:effectperiod(1)
				cap_right:effectoffset(0)
				cap_right:effectmagnitude(.7,1,0)
				cap_tape1:pulse()
				cap_tape1:effectclock('bgm')
				cap_tape1:effectperiod(2)
				cap_tape1:effectoffset(0)
				cap_tape1:effectmagnitude(.7,1,0)
				cap_tape2:pulse()
				cap_tape2:effectclock('bgm')
				cap_tape2:effectperiod(2)
				cap_tape2:effectoffset(1)
				cap_tape2:effectmagnitude(.7,1,0)
			end)
			
			mm(368,function()
				cap_bg_all:playcommand('TapeOff')
			end)
			mm(376,function()
				cap_bg_all:playcommand('Glow')
				cap_bg_all:playcommand('Text')
				cap_left:stopeffect()
				cap_left:decelerate(spb*2)
				cap_left:zoom(2)
				cap_left:accelerate(spb*2)
				cap_left:zoom(0)
				cap_right:decelerate(spb*2)
				cap_right:stopeffect()
				cap_right:zoom(2)
				cap_right:accelerate(spb*2)
				cap_right:zoom(0)
				cap_tape1:stopeffect()
				cap_tape2:stopeffect()
			end)
			
			mm(376,function()
				
				cap_bgcover:linear(spb*16)
				cap_bgcover:diffusealpha(1)
				cap_red:diffusealpha(0)
				
			end,true)
			
			mm(403,function()
				if cap_eye then
					cap_eye:skewx(0)
					cap_eye:zoom(1)
					cap_eye:diffusealpha(0)
					cap_eye:bouncebegin(spb)
					cap_eye:zoom(1.5)
					cap_eye:diffusealpha(1)
					cap_eye:linear(spb*8)
					cap_eye:zoom(.9)
					cap_eye:diffusealpha(0)
				end
				if cap_red then
					cap_red:diffuse(0,0,0,0)
					cap_red:linear(spb*16)
					cap_red:diffusealpha(1)
				end
			end)
			
			
			
			
			
			
			
---------------------------------------------------------------------------------------
----------------------DON'T TOUCH IT KIDDO---------------------------------------------
---------------------------------------------------------------------------------------
			
			function message_compare(a,b)
				return a[1] < b[1]
			end
			
			if table.getn(messages) > 1 then
				table.sort(messages, message_compare)
			end
			
			self:queuecommand('Update');
			
		end"
        
		UpdateCommand="%function(self)

        ---------------------------------------------------------------------------------------
        ----------------------DON'T TOUCH IT KIDDO---------------------------------------------
        ---------------------------------------------------------------------------------------

            --hide things as needed, and set up aliases if checked is false
			if not checked and GAMESTATE:GetSongBeat()>=0 then
				
                thingsToGrab = {'LifeP1','LifeP2','ScoreP1','ScoreP2','BPMDisplay','LifeFrame','ScoreFrame','Lyrics','SongForeground','SongBackground','Overlay','Underlay'}
                thingsToHide = {'LifeP1','LifeP2','ScoreP1','ScoreP2','BPMDisplay','LifeFrame','ScoreFrame','Overlay','Underlay'}
                
                for i,v in ipairs(thingsToGrab) do
                    _G[v] = SCREENMAN:GetTopScreen():GetChild(v) or nil
                end
                
                for i,v in ipairs(thingsToHide) do
                    if _G[v] then _G[v]:hidden(1) end
                end
				
				table.insert(mod_plr,SCREENMAN:GetTopScreen():GetChild('PlayerP1'));
				table.insert(mod_plr,SCREENMAN:GetTopScreen():GetChild('PlayerP2'));
				
				for i,v in pairs(mod_plr) do
					if SCREENMAN:GetTopScreen():GetChild('PlayerOptionsP'..i) then
						_G['init_modsp'..i] = SCREENMAN:GetTopScreen():GetChild('PlayerOptionsP'..i):GetText();
					end
				end
				
				screen = SCREENMAN:GetTopScreen();
				screen:SetDrawByZPosition(false);
				checked = true;
                
                P1 = SCREENMAN:GetTopScreen():GetChild('PlayerP1');
				P2 = SCREENMAN:GetTopScreen():GetChild('PlayerP2');
			end
			
			local beat = GAMESTATE:GetSongBeat()
				

            if beat > mod_firstSeenBeat+0.1 then -- performance coding!! --
            
                -----------------------
                -- Player mod resets --
                -----------------------
            
                for i=1,2 do
                    GAMESTATE:ApplyGameCommand('mod,clearall',i)
                    if _G['init_modsp'..i] then 
                        GAMESTATE:ApplyGameCommand('mod,'.._G['init_modsp'..i],i)
                    end
                end
            
                ------------------------------------------------------------------------------
                -- custom mod reader by TaroNuke edited by WinDEU and re-stolen by TaroNuke --
                ------------------------------------------------------------------------------
                for i,v in pairs(mods) do
                    if v and table.getn(v) > 3 and v[1] and v[2] and v[3] and v[4] then
                        if beat >=v[1] then
                            if (v[4] == 'len' and beat <=v[1]+v[2]) or (v[4] == 'end' and beat <=v[2]) then
                                if table.getn(v) == 5 then
                                    GAMESTATE:ApplyGameCommand('mod,'..v[3],v[5]);
                                else
                                    GAMESTATE:ApplyGameCommand('mod,'..v[3]);
                                end						
                            end
                        end
                    else
                        v[1] = 0;
                        v[2] = 0;
                        v[3] = '';
                        v[4] = 'error';
                        SCREENMAN:SystemMessage('Bad mod in beat-based table (line '..i..')');
                    end
                end
                
				---------------------------------------------------
				-- ease mod reader v2                            --
				-- friendship ended with if wall                 --
				-- now functions as parameters is my best friend --
				---------------------------------------------------
				for i,v in pairs(mods_ease) do
					if v and table.getn(v) > 6 and v[1] and v[2] and v[3] and v[4] and v[5] and v[6] and v[7] then
						if beat >=v[1] then
							if (v[6] == 'len' and beat <=v[1]+v[2]) or (v[6] == 'end' and beat <=v[2]) then
								
								local duration = v[2];
								if v[6] == 'end' then duration = v[2] - v[1] end
								local curtime = beat - v[1]
								local diff = v[4] - v[3]
								local startstrength = v[3]
								local curve = v[7]
								local mod = v[5]
								
								local strength = curve(curtime, startstrength, diff, duration, v[10], v[11]) --extra parameters for back and elastic eases :eyes:
								
								if v[5] == 'xmod' then
									if table.getn(v) >= 8 then GAMESTATE:ApplyGameCommand('mod,*10000 '..strength..'x',v[8]);
									else GAMESTATE:ApplyGameCommand('mod,*10000 '..strength..'x'); end
								else
									if table.getn(v) >= 8 then GAMESTATE:ApplyGameCommand('mod,*10000 '..strength..' '..mod,v[8]);
									else GAMESTATE:ApplyGameCommand('mod,*10000 '..strength..' '..mod); end
								end
							elseif (v[9] and ((v[6] == 'len' and beat <=v[1]+v[2]+v[9]) or (v[6] == 'end' and beat <=v[9]))) then
								if v[5] == 'xmod' then
									if v[8] then GAMESTATE:ApplyGameCommand('mod,*10000 '..v[4]..'x', v[8]);
									else GAMESTATE:ApplyGameCommand('mod,*10000 '..v[4]..'x'); end
								else
									if v[8] then GAMESTATE:ApplyGameCommand('mod,*10000 '..v[4]..' '..v[5], v[8]);
									else GAMESTATE:ApplyGameCommand('mod,*10000 '..v[4]..' '..v[5]); end
								end
							end
						end
					else
						SCREENMAN:SystemMessage('Bad mod in beat-based ease table (line '..i..')');
					end
				end
				
                ------------------
                -- Actions shit --
                ------------------
                while curmessage<=table.getn(messages) and GAMESTATE:GetSongBeat()>=messages[curmessage][1] do
                    if messages[curmessage][3] or GAMESTATE:GetSongBeat() < messages[curmessage][1]+2 then
                        if type(messages[curmessage][2]) == 'function' then
                            messages[curmessage][2]()
                        elseif type(messages[curmessage][2]) == 'string' then
                            MESSAGEMAN:Broadcast(messages[curmessage][2]);
                        end
                    end
                    curmessage = curmessage+1;
                end

				if beat > 44 and beat < 76 then
					GAMESTATE:ApplyGameCommand('mod,*10000 '.. 10*math.sin(beat*math.pi)*(beat-43)*ch_flicker .. ' bumpy')
					ch_flicker = ch_flicker * -1
				elseif (beat > 126 and beat < 128) then
					local mult = 1.5
					if (beat > 127 and beat < 128 )  then mult = 3 end
					for i,v in pairs(mod_plr) do
						if v then
							v:skewx(math.sin(beat*math.pi)*mult)
						end
					end
					if cap_left then
						cap_left:skewx(-1*math.sin(beat*math.pi)*mult)
					end
					if cap_right then
						cap_right:skewx(-1*math.sin(beat*math.pi)*mult)
					end
				elseif beat > 136 and beat < 144 then
					local mult = 1
					if (beat > 138 and beat < 142) then mult = 2
					elseif (beat > 142 and beat < 144)  then mult = 3 end
					for i,v in pairs(mod_plr) do
						if v then
							v:skewx(math.sin(beat*math.pi/2)*mult)
						end
					end
					if cap_left then
						cap_left:skewx(-1*math.sin(beat*math.pi/2)*mult)
					end
					if cap_right then
						cap_right:skewx(-1*math.sin(beat*math.pi/2)*mult)
					end
				elseif beat > 144 and beat < 208 then
					--local flipparity = math.mod(math.floor(beat),2)*2-1
					
					--GAMESTATE:ApplyGameCommand('mod,*10000 '.. math.sin(beat*math.pi/3)*50+50 .. ' stealth',1)
					--GAMESTATE:ApplyGameCommand('mod,*10000 '.. math.sin(beat*math.pi/3+math.pi)*50+50 .. ' stealth',2)
					local dir = 1
					if beat > 176 then dir = -1 end
					for i,v in pairs(mod_plr) do
						if v then
							v:z(math.cos(dir*beat*math.pi/4+(i-.5)*math.pi)^3*650-200)
							if beat > 176 and beat < 207 then
								if beat > 192 then
									GAMESTATE:ApplyGameCommand('mod,*10000 '.. math.sin(beat*math.pi)*50+50 .. ' flip,*10000 '.. math.cos(beat*math.pi+math.pi*(i-1))*-43.75 ..' split,*10000 '.. math.cos(beat*math.pi+math.pi*(i-1))*-18.75 ..' alternate,*10000 '.. math.cos(beat*math.pi+math.pi*(i-1))*31.25 ..' reverse,*10000 '.. 10*math.sin(beat*math.pi)*ch_flicker*(beat-193) ..' tornado',i)
								else
									GAMESTATE:ApplyGameCommand('mod,*10000 '.. math.sin(beat*math.pi)*50+50 .. ' flip,*10000 '.. math.cos(beat*math.pi+math.pi*(i-1))*-43.75 ..' split,*10000 '.. math.cos(beat*math.pi+math.pi*(i-1))*-18.75 ..' alternate,*10000 '.. math.cos(beat*math.pi+math.pi*(i-1))*31.25 ..' reverse',i)
								end
							elseif beat <= 176 then
								GAMESTATE:ApplyGameCommand('mod,*10000 '.. math.sin(beat*math.pi)*50+50 .. ' flip',i)
							end
							if beat < 207 then
								v:x(math.sin(dir*beat*math.pi/4+(i-.5)*math.pi)^3*SCREEN_WIDTH*.25+SCREEN_CENTER_X)
								v:z(math.cos(dir*beat*math.pi/4+(i-.5)*math.pi)^3*650-200)
							else
								local ugh = (beat-207)^2
								v:x(SCREEN_CENTER_X+SCREEN_CENTER_X*(i*2-3)*ugh)
								v:z(0)
							end
						end
					end
					ch_flicker = ch_flicker * -1
				elseif beat > 208 and beat < 272 then
				
					cap_bgcover:diffusealpha( .7 + .2*math.cos(beat*math.pi*0.25) )
				
				elseif beat > 272 and beat < 308 then
					local testm = 4
					if beat > 300 then testm = .5 
					elseif beat > 296 then testm = 1
					elseif beat > 288 then testm = 2 end
					local test = (testm-math.mod(beat,testm))/testm
					
					GAMESTATE:ApplyGameCommand('mod,*10000 '.. ch_flicker*1200*test .. ' bumpy',2)
					ch_flicker = ch_flicker * -1
				elseif beat > 308 and beat < 312 then
					local calculator = (312-beat)/4
					if cap_eye then
						cap_eye:y(SCREEN_CENTER_Y+ (math.random()*200-100)*calculator)
					end
				elseif beat > 312 and beat < 316 then
					local calculator = (beat-312)*8
					if cap_eye then
						if math.mod(math.floor(calculator),2) == 0 then
							cap_eye:diffusealpha(1-calculator/32)
						else
							cap_eye:diffusealpha(0)
						end
					end
				elseif beat > 316 and beat < 348 then
					local zoomval = math.sin(beat*math.pi)^2+.5
					for i,v in pairs(mod_plr) do
						GAMESTATE:ApplyGameCommand('mod,*10000 '.. math.sin((beat)*math.pi/2+(math.pi/2*i))^12*100-25 .. ' reverse,*10000 '.. math.sin((beat)*math.pi/2+(math.pi/2*(i-1)))^12*100 .. ' tipsy,*10000 '.. math.sin((beat)*math.pi/2+(math.pi/2*i))^12*100 .. ' stealth',i)
					end
					--SCREENMAN:GetTopScreen():zoom(zoomval)
					--SCREENMAN:GetTopScreen():x(SCREEN_CENTER_X*(1-zoomval))
					--SCREENMAN:GetTopScreen():y(SCREEN_CENTER_Y*(1-zoomval))
					if (beat > 328 and beat < 332) then
						for i,v in pairs(mod_plr) do
							if v then
								local mult = 1
								if beat > 330 then mult = 2 end
								v:skewx(math.sin(beat*math.pi/2)*mult)
							end
						end
					end
					local calculator = (beat-316)*2
					if cap_eye then
						if math.mod(math.floor(calculator),2) == 1 then
							cap_eye:diffusealpha(.25)
						else
							cap_eye:diffusealpha(0)
						end
					end
				elseif beat > 348 and beat < 376 then
					local zoomval = math.sin(beat*math.pi)^2+.5
					for i,v in pairs(mod_plr) do
						GAMESTATE:ApplyGameCommand('mod,*10000 '.. math.sin((beat)*math.pi/2+(math.pi/2*i))^12*100-25 .. ' reverse,*10000 '.. math.sin((beat)*math.pi/2+(math.pi/2*(i-1)))^12*100 .. ' tipsy,*10000 '.. math.sin((beat)*math.pi/2+(math.pi/2*i))^12*100 .. ' stealth',i)
						v:rotationx(math.sin(beat*math.pi)*(beat-338)/2)
						v:rotationz(math.cos(beat*math.pi)*(beat-338)/2)
						v:rotationy(math.cos(beat*math.pi)*(beat-338)/2)
						if beat > 360 and beat < 364 then
							v:skewx(math.sin(beat*math.pi))
						end
					end
					local calculator = (beat-348)*2
					if cap_eye then
						if math.mod(math.floor(calculator),2) == 1 then
							if beat > 374 then
								cap_eye:diffusealpha(.25 * (1-(beat-374)/2))
							else
								cap_eye:diffusealpha(.25)
							end
							cap_eye:skewx(math.random()*.5-.25)
						else
							cap_eye:diffusealpha(0)
						end
					end
				elseif beat > 380 and beat < 404 then
					local semiconst = ((beat-380)/18)+1
					GAMESTATE:ApplyGameCommand('mod,*10000 '.. 15*math.sin(beat*math.pi*semiconst)*(beat-379)*ch_flicker .. ' bumpy')
					ch_flicker = ch_flicker * -1
				end
				
				if beat>315 and beat<375 then
					cap_red:diffusealpha( .1 - .1*math.cos((beat-1)*math.pi) )
				end
				
				if beat>270 and beat<286 then
					cap_red:diffusealpha( .1 - .1*math.cos((beat-2)*math.pi*0.5) )
					if beat > 274 then
						cap_warning:diffusealpha( .1 - .1*math.cos((beat-2)*math.pi*0.5) )
						cap_eye:diffusealpha( .1 - .1*math.cos((beat-2)*math.pi*0.5) )
						cap_eye:zoom(1)
					end
				end
				if beat>287 and beat<295 then
					cap_red:diffusealpha( .1 - .1*math.cos((beat-1)*math.pi) )
					cap_warning:diffusealpha( .1 - .1*math.cos((beat-1)*math.pi) )
					cap_eye:diffusealpha( .1 - .1*math.cos((beat-1)*math.pi) )
						cap_eye:zoom(1)
				end
				if beat>295.5 and beat<299.5 then
					cap_red:diffusealpha( .1 - .1*math.cos((beat-.5)*math.pi*2) )
					cap_warning:diffusealpha( 0 )
					cap_eye:diffusealpha( 0 )
					cap_eye:zoom(1)
				end
					
				
				
            end
			
			
			
			self:sleep(1/60);
			self:queuecommand('Update');

---------------------------------------------------------------------------------------
----------------------END DON'T TOUCH IT KIDDO-----------------------------------------
---------------------------------------------------------------------------------------
          
        end"
		
	/>
	
	<Layer Type="Quad" OnCommand="hidden,1;queuecommand,Update"
		UpdateCommand="%function(self)
		
			local beat = GAMESTATE:GetSongBeat()
			
			if beat > mod_firstSeenBeat+0.1 then
			
				if table.getn(mod_perframes)>0 then
					for i=1,table.getn(mod_perframes) do
						local a = mod_perframes[i]
						if beat > a[1] and beat < a[2] then
							a[3](beat);
						end
					end
				end
			
			end
			
			self:sleep(1/100)
			self:queuecommand('Update')
			
		end"
	/>
	
	<Layer InitCommand="%function(self) cap_warning = self end" File="warning" OnCommand="diffusealpha,0;zoom,1.5;x,SCREEN_CENTER_X;y,SCREEN_CENTER_Y-100;" />
	
	<Layer InitCommand="%function(self) cap_red = self end" Type="Quad" OnCommand="diffuse,1,0,0,0;stretchto,0,0,SCREEN_WIDTH,SCREEN_HEIGHT;" />
	
	<Layer InitCommand="%function(self) cap_static = self end" File="static.sprite" OnCommand="diffusealpha,0;stretchto,0,0,SCREEN_WIDTH,SCREEN_HEIGHT;" />
	
	<Layer InitCommand="%function(self) cap_eye = self end" File="eggeye" OnCommand="diffusealpha,0;blend,add;x,SCREEN_CENTER_X;y,SCREEN_CENTER_Y;zoom,0;glowshift;effectclock,bgm;effectcolor1,1,0,0,.1;effectcolor2,1,0,0,0;effectperiod,8" />
	
</children></ActorFrame>