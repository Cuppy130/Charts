<ActorFrame
InitCommand="%function(self)

	if FUCK_EXE then

		slumpo = false
		for pn=1,2 do
			if GAMESTATE:IsPlayerEnabled(pn-1) then
				if GAMESTATE:GetCurrentSteps(pn-1):GetDifficulty() == 5 then
					slumpo = true
				end
			end
		end

		songName = GAMESTATE:GetCurrentSong():GetSongDir();
		
		mod_globaloffset = PREFSMAN:GetPreference('GlobalOffsetSeconds');
		
		sw = SCREEN_WIDTH
		sh = SCREEN_HEIGHT --shortcuts
		
		function Plr(pn)
			return _G['P'..pn]
		end
		function GetJud(pn)
			return _G['jud'..pn]
		end
		function GetCom(pn)
			return _G['com'..pn]
		end
		
		function mod_do(str,pn)
			if pn then
				GAMESTATE:ApplyGameCommand('mod,'..str,pn)
			else
				GAMESTATE:ApplyGameCommand('mod,'..str)
			end
		end
		
		function taro_Sound(str)
			local met = GAMESTATE:GetCurrentSong():GetSongDir();
			SOUND:PlayOnce(met..'lua/'..str..'.ogg');
		end
		
		spb = 60/128
	
	else
		
		SCREENMAN:SystemMessage('Requires NotITG!')
		
	end
	
end"
><children>

	<Layer Type="ActorFrame" Condition="FUCK_EXE"><children>

		<Layer
			Type="Quad"
			InitCommand="hidden,1"
			OnCommand="sleep,1000"
		/>
		
		<Layer File="spellcard.xml" />
		<Layer File="modhelpers.xml" />
		<Layer File="easing.xml" />
		
		<Layer
			Type="Quad"
			OnCommand="hidden,1"
			InitCommand="%function(self)
			
				checked = false; P1=nil;P2=nil;P3=nil;P4=nil;jud1=nil;com1=nil;jud2=nil;com2=nil;jud3=nil;com3=nil;
			
				---------------------------------------------------------
				---------DOCUMENTATION-----------------------------------
				---------------------------------------------------------
				
				--function perframe( beat, endBeat )
					--return true if the current beat is between 'beat' and 'endBeat'
				
				--function mod_shader(beat,key,which)
					--turn on shader key at specified beat (up to 10 keys available, defined by 'which' = 0-9
					
				--function mod_insert(beat,len,mod,len_or_end,pn)
					--insert mod into beat mods table
				--function mod_insert2(time,len,mod,len_or_end,pn)
					--insert mod into time mods table
					
				--function mod_message(beat,msg,persistent)
					--insert something into the actions table.
					--msg can also be a function. If string, a message gets broadcast at that beat
					--if 'persistent' is true, message will run even if editor starts at a beat past it
					
				--function mod_blacklist(t,n)
					--check if number n occurs in table t
					--useful for doing 'every beat EXCEPT the contents of t'
					
				--function simple_m0d(beat,strength,mult,mod)
				--function simple_m0d2(beat,strength,mult,mod,pn)
				--function simple_m0d3(beat,strength,duration,bpm,mod,pn)
					--activate mods at specific beat but also deactivate them
					
				--function mod_wiggle(beat,num,div,amt,speed,mod,pn,first)
					--alternates a mod back and forth before resetting to 0
					
				--function mod_springt(time,strength,dur,mod,pn)
					--time-based per-frame alternating mod that decreases based on how much time is left.
						--think doorstopper
				
				--function mod_springt2(time,strength,dur,mod,pn)
					--time-based per-frame alternating mod
				
				--function mod_onebeat(beat,strength,pn)
					--turns on beat for the beat specified, at the desired strength	
				
				--function switcheroo_add(beat,which,speed,len,pn)
					--adds a column swap at the desired beat
				--[[	switcheroos = {normal = {0,0}, ldur = {0,0}, reset = {0,0},
						flip = {100,0}, rudl = {100,0}, invert = {0,100}, dlru = {0,100},
						ludr = {25,-75}, rdul = {75,75}, drlu = {25,125}, ulrd = {75,-125}, urld = {100,-100}}
				]]
				
				--use a variable called 'switcheroo_width' to change how much space is between each column
				--e.g. switcheroo_width = 2 for ayakashi
				
				--function mod_sugarkiller(beat,duration,speed,minstealth,maxstealth,pn)
					--portable version of the effect from sugarkill X
					
				--function doSpline(spd, axis, path, col)
					--draws spline 'path' in specified axis, for specific col. Offsets are *10000, but positions use *spd
					
				--function doSplineAll(spd, axis, path)
					--same as above, but for all columns
					--(faster performance than using doSpline 4 times due to more efficient concat)
				
				--function mindf_rotateAndCounter(xDegrees, yDegrees, zDegrees, player)
					--counteract euler rotations after rotating player in multiple axes, using a TON of math.
				
				
				---------------------------------------------------------
				--------END DOCUMENTATION--------------------------------
				---------------------------------------------------------
				
				local m = mod_insert
				local m2 = mod_message
				local me = mod_ease
				
				
				local l = 'len'
				local e = 'end'
				
				
				
				
				
				
				
				init_modsp1 = '';
				init_modsp2 = '';
				
				mod_plr = {};
				
				mod_firstSeenBeat = GAMESTATE:GetSongBeat(); --necessary to prevent long freezes
				
				
				
				
				
				
				
				
				
				
				
	---------------------------------------------------------------------------------------
	----------------------Begin tables 'n stuff--------------------------------------------
	---------------------------------------------------------------------------------------

				--beat based mods
				--{beat_start, beat_end, mods, len_or_end, player_number}
				mods = {
					{0,9999,'*2 2x, *1000 no beat, *10000 -99999 cover','end'},
				}
				
				--switcheroos = {{0,0},{100,0},{0,100},{25,-75},{75,75},{25,125},{75,-125},{100,-100}}
				
				
				
				
				
				
				
				--time based mods
				mod_time = 0;
				--{time_start, time_end, mods, len_or_end, player_number}
				mods2 = {
					--{0,200.345,'3x','end',1},
				}
				
				
				
				
				--this is both a message broadcaster and a function runner
				--if you put {beat,'String'}, then 'String' is broadcast as a message on that beat
				--if you put {beat,function() somecode end}, then function() is run at that beat
				--see example on beat 32
				
				curaction = 1;
				--{beat,thing,persists}
				mod_actions = {
				
				
					
				}
				
				
				
				
				
				
				--beat-based ease mods
				--{time_start, time_end, mod_start, mod_end, mod, len_or_end, ease_type, player_number, sustaintime, optional_param1, optional_param2}
				--valid ease types are:
					--linear
					--inQuad    outQuad    inOutQuad    outInQuad
					--inCubic   outCubic   inOutCubic   outInCubic
					--inQuart   outQuart   inOutQuart   outInQuart
					--inQuint   outQuint   inOutQuint   outInQuint
					--inSine    outSine    inOutSine    outInSine
					--inExpo    outExpo    inOutExpo    outInExpo
					--inCirc    outCirc    inOutCirc    outInCirc
					--inElastic outElastic inOutElastic outInElastic    --can take 2 optional parameters - amplitude & period
					--inBack    outBack    inOutBack    outInBack       --can take 1 optional parameter  - spring amount
					--inBounce  outBounce  inOutBounce  outInBounce
					
				mods_ease = {
					-- EXAMPLE TWEEN: from beat 0 to 4, make rotationz go from 360 to 0 with the inOutBack tween
					--{0,4,360,0,'rotationz','end',inOutBack},
				}
				
				
				
				mod_perframes = {
					
				}
				
				function mpf(s,e,f)
					table.insert(mod_perframes,{s,e,f})
				end
				
				local cpi = math.pi*100
				confuse_angs = {cpi/2,0,-cpi,-cpi/2}
				
				local function sm0d(be,st,mu,mo,tw,pn)
					if not tw then tw = outQuad end
					me(be,mu,st,0,mo,l,tw,pn,.1)
				end
				
				function confuse_on(b,dur,ang,lend,tween,pn,sus,only)
					if sus and lend == l then
						sus = sus-dur
					end
					for i=0,3 do
						if i == only or not only then
							me(b,dur,0,-confuse_angs[i+1] + 100*math.rad(ang),'confusionoffset'..i,lend,tween,pn,sus)
						end
					end
				end
				
				function confuse_change(b,dur,sang,eang,lend,tween,pn,sus,only)
					if sus and lend == l then
						sus = sus-dur
					end
					for i=0,3 do
						if i == only or not only then
							me(b,dur,-confuse_angs[i+1] + 100*math.rad(sang),-confuse_angs[i+1] + 100*math.rad(eang),'confusionoffset'..i,lend,tween,pn,sus)
						end
					end
				end
				
				function confuse_off(b,dur,ang,lend,tween,pn,only)
					local sus = .5
					if sus and lend == e then
						sus = sus+b
					end
					for i=0,3 do
						if i == only or not only then
							me(b,dur,-confuse_angs[i+1] + 100*math.rad(ang),0,'confusionoffset'..i,lend,tween,pn,sus)
						end
					end
				end
				
				m2(0,function()
					
					for pn=1,2 do
						local d = 0.25; if pn == 2 then d = 0.75 end
						
						local b = _G['jud'..pn]
						if b then
							b:hidden(1);
							b:sleep(999)
							b:basezoomx(1);
							b:basezoomy(1);
						end
						local c = _G['com'..pn]
						if c then
							c:hidden(1);
							c:sleep(999)
							c:basezoomx(1);
							c:basezoomy(1);
						end
						
						local b = _G['jud'..pn..'p']
						if b then
							b:hidden(0);
							b:basezoomx(.8);
							b:basezoomy(.8);
							b:x(SCREEN_WIDTH*d)
							b:y(SCREEN_HEIGHT*0.5)
							--Trace(tostring(b));
						end
						local c = _G['com'..pn..'p']
						if c then
							c:hidden(0);
							c:basezoomx(.8);
							c:basezoomy(.8);
							c:x(SCREEN_WIDTH*d)
							c:y(SCREEN_HEIGHT*0.45)
						end
						
					end
					
					MESSAGEMAN:Broadcast('GetProxy');
					
				end,true)
				
				me(0,2,50,100,'dark',l,linear,nil,2)
				
				m2(2,function()
					
					for pn=1,2 do
						local a = Plr(pn)
						if a then
							a:x(sw/2)
						end
					end
					
				end)
				
				mpf(2,14,function(beat)
				
					local ang = beat*math.pi*0.25
					
					local radius = 1
					
					if beat > 10 then
						radius = 1-inOutExpo((beat-10)/4,0,1,1)
					end
					
					local addr = 0
					
					if beat > 7.5 and beat < 8 then
						addr = 720*(beat-7.5)/0.5
					end
					
					for pn=1,2 do
						local str = ''
						for c=0,3 do
							
							local w = (pn-1)*4+c
							
							local xp = radius*300*math.sin(ang + math.pi*2*(w/8))
							local yp = radius*100*math.cos(ang + math.pi*2*(w/8))
							local zp = radius*500*math.cos(ang + math.pi*2*(w/8))
							local cz = -confuse_angs[c+1]+(math.rad(addr + xp/6))*100
							
							str = str..'*10000 '..xp..' movex'..c..',*10000 '..yp..' movey'..c..',*10000 '..zp..' movez'..c..',*1000 '..cz..' confusionoffset'..c..','
							
							
						end
						mod_do(str,pn)
					end
					
				end)
				
				me(4,8,1000,0,'tipsy',e,outElastic)
				
				m(2,10,'*1000 50 flip',e)
				me(10,4,50,0,'flip',l,inOutExpo)
				
				sm0d(10,-200,.75,'tiny')
				sm0d(10.75,-200,.75,'tiny')
				sm0d(11.5,-200,.5,'tiny')
				sm0d(12,-200,2,'tiny')
				
				--confuse_on(b,dur,ang,lend,tween,pn,sus)
				confuse_on(14,0,0,l,linear,nil,1.5)
				confuse_on(16,0,90,l,linear,nil,2)
				confuse_change(18,.75,90,0,l,outQuart)
				confuse_change(18.75,.75,0,-180,l,outQuart)
				confuse_change(19.5,.5,-180,-90,l,outQuart)
				confuse_off(20,2,-90,l,outQuart)
				
				me(15.5,.5,-720,0,'confusionoffset',l,linear,nil,.1)
				--me(23.5,.5,-720,0,'confusionoffset',l,linear,nil,.1)
				--me(31.5,.5,-720,0,'confusionoffset',l,linear,nil,.1)
				
				m2(10,function()
					
					for pn=1,2 do
						local a = Plr(pn)
						if a then
							a:tween(spb*4,'inOutExpo(%f,0,1,1)')
							a:x(sw/2 + 160*(pn*2-3))
						end
					end
					
				end)
				
				m2(4,'Haihai1')
				
				m2(131,function()
					
					for pn=1,2 do
						local a = Plr(pn)
						if a then
							a:tween(spb,'inExpo(%f,0,1,1)')
							a:x(sw/2 - 30*(pn*2-3))
							a:tween(spb*2,'outElastic(%f,0,1,1)')
							a:x(sw/2)
						end
					end
					
				end)
				
				m(132,140,'*1000 sudden, *1000 80 suddenoffset',e)
				
				mpf(131,132+12,function(beat)
				
					local ang = beat*math.pi*0.25
					
					local radius = 1
					
					if beat < 132 then
						radius = 1.5*inExpo((beat-131),0,1,1)
					elseif beat >= 132 and beat < 134 then
						radius = 1.5 - 0.5*outElastic((beat-132)/2,0,1,1)
					end
					
					if beat > 138 then
						radius = 1-inOutExpo((beat-138)/4,0,1,1)
					end
					
					local addr = 0
					
					if beat > 128+7.5 and beat < 128+8 then
						addr = 720*(beat-(128+7.5))/0.5
					end
					
					for pn=1,2 do
						local str = ''
						for c=0,3 do
							
							local w = (pn-1)*4+c
							
							local xp = radius*300*math.sin(ang + math.pi*2*(w/8))
							local yp = radius*100*math.cos(ang + math.pi*2*(w/8))
							local zp = radius*500*math.cos(ang + math.pi*2*(w/8))
							local cz = -confuse_angs[c+1]+(math.rad(addr + xp/15))*100
							
							str = str..'*10000 '..xp..' movex'..c..',*10000 '..yp..' movey'..c..',*10000 '..zp..' movez'..c..',*1000 '..cz..' confusionoffset'..c..','
							
							
						end
						mod_do(str,pn)
					end
					
				end)
				
				m(132,138,'*1000 50 flip',e)
				me(138,4,50,0,'flip',l,inOutExpo)
				
				sm0d(128+10,-200,.75,'tiny')
				sm0d(128+10.75,-200,.75,'tiny')
				sm0d(128+11.5,-200,.5,'tiny')
				sm0d(128+12,-200,2,'tiny')
				
				me(128+15.5,.5,-720,0,'confusionoffset',l,linear,nil,.1)
				confuse_off(144,0,0,l,outQuart)
				--me(23.5,.5,-720,0,'confusionoffset',l,linear,nil,.1)
				--me(31.5,.5,-720,0,'confusionoffset',l,linear,nil,.1)
				
				confuse_on(128+14,0,0,l,linear,nil,1.5)
				confuse_on(128+16,0,90,l,linear,nil,2)
				confuse_change(128+18,.75,90,0,l,outQuart)
				confuse_change(128+18.75,.75,0,-180,l,outQuart)
				confuse_change(128+19.5,.5,-180,-90,l,outQuart)
				confuse_off(128+20,2,-90,l,outQuart)
				
				me(128+20,14,360*14,0,'confusionoffset',l,linear)
				me(128+34,1,-360,0,'confusionoffset',l,outQuad)
				
				me(128+15.5,.5,-720,0,'confusionoffset',l,linear,nil,.1)
				
				m2(128+10,function()
					
					for pn=1,2 do
						local a = Plr(pn)
						if a then
							a:tween(spb*4,'inOutExpo(%f,0,1,1)')
							a:x(sw/2 + 160*(pn*2-3))
						end
					end
					
				end)
				
				m2(132,'Haihai2')
				
				m(0,999,'dizzyholds, stealthpastreceptors',e)
				
				me(65.75,67,2,1.4,'xmod',e,linear)
				m(67,99,'*1000 1.4x',e)
				m(99,100,'*1000 2x',e)
				
				--[[
				local str = '*10000 reverse0'
				for i=1,3 do
					str = str..', *10000 reverse'..i
				end
				m(67,100,str,e,2)
				]]
				for i=0,3 do
					me(65,68,100,100,'reverse'..i,e,outQuad,2,99)
					me(99,100,0,0,'reverse'..i,e,outQuad,2,99)
				end
				
				function brake_pulse(b,a)
					me(b-.12,.12,0,a,'brake',l,linear)
					me(b,.75,a,0,'brake',l,linear)
					me(b+1-.12,.12,0,a,'brake',l,linear)
					me(b+1,.75,a,0,'brake',l,linear)
				end
				
				function dizzy_pulse(b)
					me(b-.12,.12,0,40,'dizzy',l,linear)
					me(b,.75,40,0,'dizzy',l,linear)
					me(b+1-.12,.12,0,-40,'dizzy',l,linear)
					me(b+1,.75,-40,0,'dizzy',l,linear)
				end
				
				for i=0,3 do
					brake_pulse(42.5+16*i,40)
					--dizzy_pulse(170.5+16*i)
				end
				for i=0,1 do
					brake_pulse(170.5+16*i,-70)
				end
				
				--------------------------------------------------------
				--minna san
				
				--function confuse_on(b,dur,ang,lend,tween,pn,sus,only)
				confuse_on(35,1,0,l,outQuad,nil,2)
				
				--function confuse_change(b,dur,sang,eang,lend,tween,pn,sus,only)
				confuse_change(37,1,0,135,l,outQuad,nil,2)
				
				me(36,1,0,128,'y',l,linear,nil,1)
				me(38,1,128,0,'y',l,linear)
				me(38,0.5,0,-64,'x',l,linear)
				me(38.5,0.5,64,0,'x',l,linear)
				
				me(38,0.5,0,100,'stealth',l,linear)
				me(38.5,0.5,100,0,'stealth',l,linear)
				me(38,0.5,0,100,'dark',l,linear)
				me(38.5,0.5,100,0,'dark',l,linear)
				
				local new = {-30,-10,10,30}
				local new2 = {-180+30,-180+10,180-10,180-30}
				local new3 = {-180,-180,180,180}
				for i=0,3 do
					confuse_change(39,1,135,new[i+1],l,outQuad,nil,1.5,i)
					confuse_change(40.5,.5,new[i+1],new2[i+1],l,outQuad,nil,1,i)
					confuse_change(41.5,.5,new2[i+1],new[i+1],l,outQuad,nil,1,i)
					confuse_change(42.5,.5,new[i+1],new3[i+1],l,outQuad,nil,1,i)
					confuse_change(43,1,new2[i+1],-45,l,outQuad,nil,2,i)
				end
				for i=0,2 do
					me(40+i,.5,0,20,'flip',l,linear)
					me(40.4+i,.5,20,0,'flip',l,linear)
				end
				
				confuse_change(45,0,-45,-135,l,outQuad,nil,2)
				
				me(40,.5,0,20,'reverse',l,linear,nil,.5)
				me(41,.5,20,0,'reverse',l,linear,nil,.5)
				me(42,.5,0,20,'reverse',l,linear,nil,.5)
				me(43,.5,20,0,'reverse',l,linear,nil,.5)
				
				me(44,1,0,128,'y',l,linear)
				me(45,1,128,0,'y',l,linear)
				me(44,0.5,0,64,'x',l,linear)
				me(44.5,0.5,-64,0,'x',l,linear)
				me(45,0.5,0,64,'x',l,linear)
				me(45.5,0.5,-64,0,'x',l,linear)
				
				me(44,0.5,0,100,'stealth',l,linear)
				me(44.5,0.5,100,0,'stealth',l,linear)
				me(44,0.5,0,100,'dark',l,linear)
				me(44.5,0.5,100,0,'dark',l,linear)
				me(45,0.5,0,100,'stealth',l,linear)
				me(45.5,0.5,100,0,'stealth',l,linear)
				me(45,0.5,0,100,'dark',l,linear)
				me(45.5,0.5,100,0,'dark',l,linear)
				
				confuse_change(46,2,-135,360,l,outQuad,nil,8)
				
				me(49,50,0,100,'reverse',e,linear,nil,65)
				
				confuse_change(51,1,0,180,l,outQuad,nil,2)
				confuse_change(16+37,1,180,45,l,outQuad,nil,2)
				
				me(16+36,1,0,-128,'y',l,linear,nil,1)
				me(16+38,1,-128,0,'y',l,linear)
				me(16+38,0.5,0,-64,'x',l,linear)
				me(16+38.5,0.5,64,0,'x',l,linear)
				
				me(16+38,0.5,0,100,'stealth',l,linear)
				me(16+38.5,0.5,100,0,'stealth',l,linear)
				me(16+38,0.5,0,100,'dark',l,linear)
				me(16+38.5,0.5,100,0,'dark',l,linear)
				
				local new = {-30,-10,10,30}
				local new2 = {-180+30,-180+10,180-10,180-30}
				local new3 = {-180,-180,180,180}
				for i=0,3 do
					confuse_change(16+39,1,45,new2[i+1],l,outQuad,nil,1.5,i)
					confuse_change(16+40.5,.5,new2[i+1],new[i+1],l,outQuad,nil,1,i)
					confuse_change(16+41.5,.5,new[i+1],new2[i+1],l,outQuad,nil,1,i)
					confuse_change(16+42.5,.5,new2[i+1],0,l,outQuad,nil,1,i)
					confuse_change(16+43,1,0,-135,l,outQuad,nil,2,i)
				end
				for i=0,2 do
					me(16+40+i,.5,0,20,'flip',l,linear)
					me(16+40.4+i,.5,20,0,'flip',l,linear)
				end
				
				confuse_change(16+45,0,-135,-45,l,outQuad,nil,2)
				confuse_change(16+46,2,-45,540,l,outQuad,nil,8)
				
				me(16+40,.5,100,80,'reverse',l,linear,nil,.5)
				me(16+41,.5,80,100,'reverse',l,linear,nil,.5)
				me(16+42,.5,100,80,'reverse',l,linear,nil,.5)
				me(16+43,.5,80,100,'reverse',l,linear,nil,.5)
				
				me(16+44,1,0,-128,'y',l,linear)
				me(16+45,1,-128,0,'y',l,linear)
				me(16+44,0.5,0,64,'x',l,linear)
				me(16+44.5,0.5,-64,0,'x',l,linear)
				me(16+45,0.5,0,64,'x',l,linear)
				me(16+45.5,0.5,-64,0,'x',l,linear)
				
				me(16+44,0.5,0,100,'stealth',l,linear)
				me(16+44.5,0.5,100,0,'stealth',l,linear)
				me(16+44,0.5,0,100,'dark',l,linear)
				me(16+44.5,0.5,100,0,'dark',l,linear)
				me(16+45,0.5,0,100,'stealth',l,linear)
				me(16+45.5,0.5,100,0,'stealth',l,linear)
				me(16+45,0.5,0,100,'dark',l,linear)
				me(16+45.5,0.5,100,0,'dark',l,linear)
				
				me(20,14,360*14,0,'confusionoffset',l,linear)
				me(34,1,-360,0,'confusionoffset',l,outQuad)
				
				m(19.5,34.5,'*10000 beat',e)
				
				sm0d(23.5,-100,.5,'tiny')
				sm0d(24,-100,.5,'tiny')
				sm0d(23.5,50,.5,'stealth')
				sm0d(24,50,.5,'stealth')
				
				sm0d(26,-100,.5,'tiny')
				sm0d(26.75,-100,.5,'tiny')
				sm0d(27.5,-100,.5,'tiny')
				sm0d(28,-100,.5,'tiny')
				sm0d(26,50,.5,'stealth')
				sm0d(26.75,50,.5,'stealth')
				sm0d(27.5,50,.5,'stealth')
				sm0d(28,50,.5,'stealth')
				
				sm0d(31.5,-100,.5,'tiny')
				sm0d(32,-100,.5,'tiny')
				sm0d(31.5,50,.5,'stealth')
				sm0d(32,50,.5,'stealth')
				
				m(20,32,'50 drunk, 50 tipsy, 100 wave',e)
				
				mod_wiggle(54,4,4,150,1.5,'tipsy')
				mod_wiggle(65,3,4,150,1.5,'drunk')
				mod_wiggle(48,2,4,150,1.5,'drunk')
				mod_wiggle(50,4,4,150,1.5,'drunk')
				
				m(128+19.5,34.5,'*10000 beat',e)
				
				sm0d(128+23.5,-100,.5,'tiny')
				sm0d(128+24,-100,.5,'tiny')
				sm0d(128+23.5,50,.5,'stealth')
				sm0d(128+24,50,.5,'stealth')
				
				sm0d(128+26,-100,.5,'tiny')
				sm0d(128+26.75,-100,.5,'tiny')
				sm0d(128+27.5,-100,.5,'tiny')
				sm0d(128+28,-100,.5,'tiny')
				sm0d(128+26,50,.5,'stealth')
				sm0d(128+26.75,50,.5,'stealth')
				sm0d(128+27.5,50,.5,'stealth')
				sm0d(128+28,50,.5,'stealth')
				
				sm0d(128+31.5,-100,.5,'tiny')
				sm0d(128+32,-100,.5,'tiny')
				sm0d(128+31.5,50,.5,'stealth')
				sm0d(128+32,50,.5,'stealth')
				
				m(128+20,12,'*2 100 drunk, *1 50 tipsy, *2 150 wave',l)
				
				me(65,66,100,0,'reverse',e,linear,1)
				me(65,66,0,0,'reverse',e,linear,2)
				
				m(180,196,'50 drunk',e)
				
				m2(161,function()
					for pn=1,2 do
						local a = Plr(pn)
						if a then
							a:linear(spb)
							a:zoomz(80)
							a:spring(spb)
							a:zoomz(1)
						end
					end
				end)
				
				---------------------------------------------------------
				--It's your duty to be happy.
				
				for i=0,1 do
					
					if i==1 then
						confuse_on(67+i*16,0,0,l,outQuad,1,4)
						confuse_on(67+i*16,0,-180,l,outQuad,2,4)
					else
						confuse_on(67+i*16,1,0,l,outQuart,1,4)
						confuse_on(67+i*16,1,-180,l,outQuart,2,4)
					end
					
					confuse_on(71+i*16,0,-90,l,outQuad,1,4)
					confuse_on(71+i*16,0,90,l,outQuad,2,4)
					
					confuse_on(75+i*16,0,-180,l,outQuad,1,4)
					confuse_on(75+i*16,0,0,l,outQuad,2,4)
					
					confuse_on(79+i*16,0,90,l,outQuad,1,4)
					confuse_on(79+i*16,0,-90,l,outQuad,2,4)
				
					m(68+i*16,3,'*1.4 200 centered',l)
					m(71+i*16,1,'*1000 no centered',l)
					m(71+i*16,8,'*1000 reverse',l)
					
					m2(72+i*16,function()
						for pn=1,2 do
							local a = Plr(pn)
							if a then
								a:linear( 180/128 )
								a:x( sw/2 - 160*(pn*2-3) )
							end
						end
					end)
					
					m(76+i*16,3,'*1.4 200 centered',l)
					m(79+i*16,1,'*1000 no centered',l)
					m(79+i*16,8,'*1000 no reverse',l)
					
					m2(80+i*16,function()
						for pn=1,2 do
							local a = Plr(pn)
							if a then
								a:linear( 180/128 )
								a:x( sw/2 + 160*(pn*2-3) )
							end
						end
					end)
					
					--disappear between direction changes/reverse resets
					for j=0,3 do
						me(70+j*4+i*16,.75,0,100,'stealth',l,linear,nil,.25)
						me(71+j*4+i*16,1,100,0,'stealth',l,linear)
						me(70+j*4+i*16,.75,0,100,'dark',l,linear,nil,.25)
						me(71+j*4+i*16,1,100,0,'dark',l,linear)
					end
				
				end
				
				me(84,86,0,50,'drunk',e,linear,nil,96)
				me(84,86,0,150,'bumpy',e,linear,nil,96)
				me(96,4,50,00,'drunk',e,linear)
				me(96,4,150,0,'bumpy',e,linear)
				
				confuse_off(99,0,90,l,outQuad,1)
				confuse_off(99,0,-90,l,outQuad,2)
				
				me(163,1,2,1.5,'xmod',l,outQuad,nil,99)
				
				
				----------------------------------------------------------------------
				--100-132
				
				m(100,132,'*1000 stealth, *1000 -200 hidden, *1000 -200 sudden',e,1)
				m(100,132,'*1000 200 hidden, *1000 200 sudden',e,2)
				
				me(103,1,0*cpi/2,1*cpi/2,'confusionoffset',l,linear,1,3)
				me(107,1,1*cpi/2,2*cpi/2,'confusionoffset',l,linear,1,3)
				me(111,1,2*cpi/2,3*cpi/2,'confusionoffset',l,linear,1,3)
				me(115,1,-1*cpi/2,0*cpi/2,'confusionoffset',l,linear,1,3)
				
				for i=100,130,4 do
					
					me(i,4,200,-100,'suddenoffset',l,linear)
					me(i,4,200,-100,'hiddenoffset',l,linear)
					
				end
				
				m(100,130,'*1000 drawsize',e)
				m(100,130,'*1000 dark',e,2)
				m(130,131,'*1000 no dark',e,2)
				
				me(100,130,0,50,'y',e,linear)
				me(100,130,0,20,'reverse',e,linear)
				
				me(130,2,20,-20,'reverse',l,inExpo)
				me(132,4,-20,0,'reverse',l,outElastic)
				me(130,2,50,-20,'y',l,inExpo)
				me(132,4,-20,0,'y',l,outElastic)
				
				m(100,132,'*1000 2000 zigzagzperiod',e,2)
				me(100,132,0,15000,'zigzagz',e,linear,2)
				m(132,4,'*100000 no zigzagz',l,2)
				
				m2(99,function()
					for pn=1,2 do
						local a = Plr(pn)
						if a then
							a:sleep(0)
							a:x(sw/2)
						end
					end
				end,true)
				
				m(100,132,'*10000 2000 zigzagperiod',e,1)
				
				mpf(100,132,function(beat)
				
					local amp = math.min((beat-100)/16,1)
					local ang = amp*15*math.sin(beat*math.pi*0.25)
					
					--mod_do('*10000 '..(-100*math.rad(ang))..' confusionoffset, *10000 '..(ang)..' rotationz, *10000 '..(ang*2)..' skewx',1)
					mod_do('*10000 '..(40*ang)..' zigzag',1)
					
					local doit = 0
					if beat >= 116 and beat < 117 then
						doit = outQuad(beat-116,0,1,1)
					elseif beat >= 117 then
						doit = 1
					end
					local doit2 = 0
					if beat >= 129 and beat < 130 then
						doit2 = outQuad(beat-129,0,1,1)
					elseif beat >= 130 then
						doit2 = 1
					end
					
					local str = ''
					local str2 = ''
					for i=0,3 do
						str = str..'*10000 '..((-confuse_angs[i+1] + 100*math.rad(-35*math.sin(beat*math.pi*0.25)) )*doit)..' confusionoffset'..i..','
						str2 = str2..'*10000 '..((-confuse_angs[i+1] + 100*math.rad(-35*math.sin(beat*math.pi*0.25)) )*doit2)..' confusionoffset'..i..','
					end
					mod_do(str,1)
					mod_do(str2,2)
					
				end)
				
				m(132,2,'*1000 no zigzag',l)
				
				----------------------------------------------------------------------
				--do as much as possible with as little code as possible
				--counter rotation
				
				m2(163,function()
					
					for pn=1,2 do
						local a = Plr(pn)
						if a then
							a:tween(spb*1.25,'outExpo(%f,0,1,1)')
							a:xy(sw/2,sh/2)
						end
					end
					
				end)
				m2(165,function()
					
					for pn=1,2 do
						local a = Plr(pn)
						if a then
							a:xy(sw/2,sh/2)
						end
					end
					
				end,true)
				
				local function con_rc(b,d,sd,ed,lend,tween,pn,sus,skew)
					if sus and lend == l then
						sus = sus-d
					end
					me(b,d,-100*math.rad(sd),-100*math.rad(ed),'confusionoffset',lend,tween,pn,sus)
					me(b,d,sd,ed,'rotationz',lend,tween,pn,sus)
				end
				
				local function lazy(b,dir,d360)
					con_rc(b,1,0,dir,l,linear,nil,3)
					if d360 then
						con_rc(b+3,1,dir,-360,l,linear)
					else
						con_rc(b+3,1,dir,0,l,linear)
					end
				end
				
				local function lazy_fi(b,f,i)
					me(b,1,0,f,'flip',l,linear,nil,3)
					me(b+3,1,f,0,'flip',l,linear)
					me(b,1,0,i,'invert',l,linear,nil,3)
					me(b+3,1,i,0,'invert',l,linear)
				end
				
				lazy(164,90)
				lazy(168,-90)
				lazy(172,90)
				lazy(176,-180,true)
				lazy(180,-90)
				lazy(184,90)
				lazy(188,-90)
				lazy(192,180)
				
				lazy_fi(176,100,0)
				
				lazy_fi(180,25,125)
				lazy_fi(184,75,-125)
				lazy_fi(188,25,125)
				
				
				---------------------------------------
				--drop distortion beam!
				
				m2(195,function()
					for pn=1,2 do
						local a = Plr(pn)
						if a then
							a:linear(spb)
							a:y(sh/2-32)
							a:zoom(.8)
						end
					end
				end)
				m2(196,function()
					for pn=1,2 do
						local a = Plr(pn)
						if a then
							a:y(sh/2-32)
							a:zoom(.8)
						end
					end
				end,true)
				
				me(195,196,1.5,1.3,'xmod',e,linear,nil,227)
				me(163,164,0,100,'drawsize',e,linear,nil,227)
				me(195,196,0,-90,'drawsizeback',e,linear,nil,227)
				
				me(203,2,300,0,'digital',l,inOutQuad)
				
				m(196,227,'*1000 no centered, *5 stealth, *5 dark',e)
				for i=0,3 do
					m(196+i*8,7,'*1.3 500 centered',l,1)
					m(200+i*8,7,'*1.3 500 centered',l,2)
					
					m(195+8*i,3,'*5 no stealth, *5 no dark',l,1)
					m(199+8*i,3,'*5 no stealth, *5 no dark',l,2)
				end
				
				for i=0,1 do
					for pn=1,2 do
						local dl = (pn-1)*4
						con_rc(196+dl+i*8,2,0,-(30+i*20)*(pn*2-3),l,outQuad,pn,3)
						me(196+dl+i*8,2,0,-50*(pn*2-3),'skewx',l,outQuad,pn,3)
						con_rc(199+dl+i*8,2,-(40+i*20)*(pn*2-3),0,l,outQuad,pn)
						me(199+dl+i*8,2,-50*(pn*2-3),0,'skewx',l,outQuad,pn)
					end
				end
				
				for pn=1,2 do
					con_rc(212-4,214-4,0,-50*(pn*2-3),e,outQuad,pn)
					me(212-4,214-4,0,-50*(pn*2-3),'skewx',e,outQuad,pn)
					con_rc(214-4,227,-50*(pn*2-3),-40*(pn*2-3),e,outQuad,pn)
					me(214-4,227,-50*(pn*2-3),-30*(pn*2-3),'skewx',e,outQuad,pn)
				end
				
				for pn=1,2 do
					me(212,226,0,20,'rotationx',e,linear,pn)
					me(226,1,20,0,'rotationx',l,linear,pn)
					
					me(212,226,0,50*(pn*2-3),'rotationy',e,linear,pn)
					me(226,1,50*(pn*2-3),0,'rotationy',l,linear,pn,1)
					
					me(226,1,-40*(pn*2-3),0,'rotationz',l,linear,pn,1)
					me(226,1,-30*(pn*2-3),0,'skewx',l,linear,pn,1)
				end
				
				--[[
				m(195,198,'*10000 no beat, *10000 no beatz, *100000 100000 beatperiod, *100000 100000 beatzperiod',e)
				m(163,195,'*10000 100 beat, *10000 -50 beatmult',e)
				m(164,196,'*10000 1000 beatz, *10000 -50 beatzmult, *10000 100 beatzoffset',e)
				]]
				
				m(162,240,'*100 80 bumpyyoffset, *100 80 bumpyxoffset',e)
				
				local f = 1
				for i=164,225,2 do
					local amt = 100*math.min((i-164)/32,1)
				
					me(i-.5,.5,0,amt*f,'bumpyx',l,inOutCirc)
					me(i,.5,amt*f,0,'bumpyx',l,inOutCirc)
					
					me(i+1-.5,.5,0,amt*f,'bumpyy',l,inOutCirc)
					me(i+1,.5,amt*f,0,'bumpyy',l,inOutCirc)
					
					f = f*-1
				end
				
				m(212,224,'50 bumpy, 50 tipsy, 60 drunk',e)
				
				me(226,1,0,50,'reverse',l,linear,nil,4)
				me(226,1,0,50,'flip',l,linear,nil,4)
				
				me(226,.9,0,-1000,'mini',l,inCirc,nil,.1)
				me(227,3,-1000,200,'mini',l,outExpo,nil,2)
				
				m2(226,function()
					for pn=1,2 do
						local a = Plr(pn)
						if a then
							a:linear(spb)
							a:rotationz(360)
							a:zoom(1)
						end
					end
				end)
				
				m2(227+4.9,function()
					for pn=1,2 do
						local a = Plr(pn)
						if a then
							a:zoom(0)
						end
					end
				end)
				
				m(227,99,'hidemines,disablemines',e)
				
				
				----------------------------------------------------
				--bg stuff
				
				m2(10,function()
					
					ama_clouds1:tween(spb*4,'inOutExpo(%f,0,1,1)')
					ama_clouds1:diffusealpha(1)
					
					ama_floor1:tween(spb*4,'inOutExpo(%f,0,1,1)')
					ama_floor1:y(sh/2)
					ama_floor1:zoom(1)
					ama_floor1:diffusealpha(1)
					
				end)
				
				m2(14,function()
					
					ama_floor1:y(sh/2)
					ama_floor1:zoom(1)
					ama_floor1:diffusealpha(1)
					
					ama_clouds1:diffusealpha(1)
					
				end,true)
				
				m2(227,function()
					
					ama_clouds1:tween(spb*2,'outCirc(%f,0,1,1)')
					ama_clouds1:diffusealpha(0)
					
					ama_floor1:tween(spb*2,'outCirc(%f,0,1,1)')
					ama_floor1:y(sh/2 + 200)
					ama_floor1:zoom(1.5)
					ama_floor1:diffusealpha(0)
					
				end)
				
				mpf(10,999,function(beat)
					
					local zm = 1
					local amp = 0
					local amp2 = 0
					
					if beat >= 10 and beat < 14 then
						zm = 1 - 0.5*inOutExpo((beat-10)/4,0,1,1)
						amp2 = 1*inOutExpo((beat-10)/4,0,1,1)
						amp = inOutQuad((beat-10)/4,0,1,1)
					elseif beat >= 14 and beat < 227 then
						zm = 0.5
						amp = 1
						amp2 = 1
					elseif beat >= 227 and beat < 229 then
						zm = 0.5 + 0.5*outExpo((beat-227)/2,0,1,1)
						amp = 1 - 1*outExpo((beat-227)/2,0,1,1)
						amp2 = 1 - outExpo((beat-227)/2,0,1,1)
					end
					
					ama_bg:zoom(zm)
					ama_bg:diffusealpha(zm)
					
					ama_bg:rotationx( 4*amp*math.sin(beat*math.pi*0.125) )
					ama_bg:rotationy( 6*amp*math.cos(beat*math.pi*0.125) )
					ama_bg:rotationz( 2*amp*math.cos(beat*math.pi*0.25) )
					ama_bg:x( sw/2 + 4*amp*math.cos(beat*math.pi*0.125) )
					ama_bg:y( sh/2 - 60*amp2 + 3*amp*math.sin(beat*math.pi*0.125) )
					
				end)
				
				m2(20,function()
					
					pos_ama:x(sw/2 + 14) --let's position her in the middle of the screen, but +16 because the sprite itself is offset within the sheet
					pos_ama:y(sh/2)
					
					pos_ama:playcommand('Idle')
					pos_ama:playcommand('Spawn')
					MESSAGEMAN:Broadcast('SpotOn')
					
				end,true)
				
				m2(35,function()
					pos_ama:playcommand('Cast2')
				end)
				
				m2(37,function()
					pos_ama:playcommand('Hide')
					MESSAGEMAN:Broadcast('SpotOff')
				end)
				
				m2(65,function()
					pos_ama:playcommand('Idle')
					pos_ama:playcommand('Spawn')
					MESSAGEMAN:Broadcast('SpotOn')
				end)
				
				m2(67,function()
					pos_ama:playcommand('Cast2')
				end)
				
				m2(98,function()
					
					pos_ama:tween(spb*2,'inOutCubic(%f,0,1,1)')
					pos_ama:y(60)
					pos_ama:zoom(.8)
					
				end)
				
				m2(99,function()
					pos_ama:playcommand('Pissed')
				end)
				
				mpf(100,131,function(beat)
					
				
					local amp = 0
					
					if beat > 100 and beat < 100+16 then
						amp = ((beat-100)/16)
					end
					
					if beat > 116 then
						amp = 1
					end
					
					local sinewave = math.sin(beat*math.pi*0.25)
					local coswave = math.cos(beat*math.pi*0.25)
					
					if beat > 100 then
					
						ama_spotlight:rotationz( amp*30*sinewave )
						ama_light:x( sw/2 - amp*210*sinewave )
					
						pos_ama:x( sw/2 + 16 - amp*80*sinewave )
						pos_ama:y( 60 + 60*(beat-100)/31 )
					
						if math.abs(coswave) > 0.1 then
							pos_ama:playcommand('Strafe')
							if coswave > 0 then
								pos_ama:basezoomx(1)
							else
								pos_ama:basezoomx(-1)
							end
						else
							pos_ama:playcommand('Pissed')
						end
						
					end
						
				end)
				
				m2(131,function()
					pos_ama:playcommand('Hide')
					MESSAGEMAN:Broadcast('SpotOff')
				end)
				
				m2(148,function()
				
					pos_ama:basezoomx(1)
					
					pos_ama:x(sw/2 + 14) --let's position her in the middle of the screen, but +16 because the sprite itself is offset within the sheet
					pos_ama:y(sh/2)
					
					pos_ama:playcommand('Idle')
					pos_ama:playcommand('Spawn')
					MESSAGEMAN:Broadcast('SpotOn')
					
				end,true)
				
				local dir_names = {'Left','Down','Up','Right'}
				
				function ama_turn_down_for_what(b,d)
					m2(b,function() pos_ama:playcommand('PCast2') end)
					m2(b,'Turn'..dir_names[d+1])
					m2(b+3,function() pos_ama:playcommand('Idle2') end)
					m2(b+3,'TurnOff')
				end
				
				ama_turn_down_for_what(164,3)
				ama_turn_down_for_what(168,0)
				ama_turn_down_for_what(172,3)
				ama_turn_down_for_what(176,1)
				ama_turn_down_for_what(180,0)
				ama_turn_down_for_what(184,3)
				ama_turn_down_for_what(188,0)
				ama_turn_down_for_what(192,1)
				
				m2(196,function()
					pos_ama:playcommand('Cast2')
				end)
				
				for i=0,1 do
					m2(196+8*i,function()
						local a = ama_beam
						local b = a:GetChild('');
					   
						a:x(SCREEN_CENTER_X);
						a:y(SCREEN_CENTER_Y);
					   
						b:finishtweening()
						b:blend('add');
						b:zoomy(4);
						b:zoomx(1);
						a:rotationz(-40);
					   
						b:diffusealpha(.5);
						b:accelerate(.8);
						b:diffusealpha(0);
						b:zoomx(0.6);
					end)
					
					m2(200+8*i,function()
						local a = ama_beam
						local b = a:GetChild('');
					   
						a:x(SCREEN_CENTER_X);
						a:y(SCREEN_CENTER_Y);
					   
						b:finishtweening()
						b:blend('add');
						b:zoomy(4);
						b:zoomx(1);
						a:rotationz(40);
					   
						b:diffusealpha(.5);
						b:accelerate(.8);
						b:diffusealpha(0);
						b:zoomx(0.6);
					end)
				end
				
				m2(211,function()
					pos_ama:playcommand('Hide')
					MESSAGEMAN:Broadcast('SpotOff')
				end,true)
				
				
	---------------------------------------------------------------------------------------
	----------------------Sort the actions table-------------------------------------------
	---------------------------------------------------------------------------------------
				
				function modtable_compare(a,b)
					return a[1] < b[1]
				end
				
				if table.getn(mod_actions) > 1 then
					table.sort(mod_actions, modtable_compare)
				end
				
				self:queuecommand('Update');
				
			end"
			
			UpdateCommand="%function(self)

				if GAMESTATE:GetSongBeat()>=0 and not checked then
				
					local ThingsToGrab = {'LifeP1','LifeP2','ScoreP1','ScoreP2','BPMDisplay','LifeFrame','ScoreFrame',
											'Lyrics','SongBackground','SongForeground','Overlay','Underlay'}
					local ThingsToHide = {'LifeP1','LifeP2','BPMDisplay','LifeFrame','ScoreFrame','Overlay','Underlay'}
					
					for i,v in ipairs(ThingsToGrab) do
						_G[v] = SCREENMAN:GetTopScreen():GetChild(v) or nil
					end
					
					for i,v in ipairs(ThingsToHide) do
						if _G[v] then _G[v]:hidden(1) end
					end
					
					table.insert(mod_plr,SCREENMAN:GetTopScreen():GetChild('PlayerP1'));
					table.insert(mod_plr,SCREENMAN:GetTopScreen():GetChild('PlayerP2'));
					
					--name players, judgment and combo
					for pn=1,2 do
						_G['P'..pn] = SCREENMAN:GetTopScreen():GetChild('PlayerP'..pn) or nil;
						if _G['P'..pn] then
							_G['jud'..pn] = _G['P'..pn]:GetChild('Judgment');
							_G['com'..pn] = _G['P'..pn]:GetChild('Combo');
						end
						
						if _G['ScoreP'..pn] then 
							_G['ScoreP'..pn]:zoom(0)
						end
					end
					
					screen = SCREENMAN:GetTopScreen();
					checked = true; --let this only run once
					
				end

				local beat = GAMESTATE:GetSongBeat()
				
				
	---------------------------------------------------------------------------------------
	----------------------Begin table handlers---------------------------------------------
	---------------------------------------------------------------------------------------
				
				disable = false;
				if disable ~= true and beat > mod_firstSeenBeat+0.1 and checked then
					
					-----------------------
					-- Player mod resets --
					-----------------------
					for i=1,2 do
						mod_do('clearall',i)
					end
					
					------------------------------------------------------------------------------
					-- custom mod reader by TaroNuke edited by WinDEU and re-stolen by TaroNuke --
					------------------------------------------------------------------------------
					for i,v in pairs(mods) do
						if v and table.getn(v) > 3 and v[1] and v[2] and v[3] and v[4] then
							if beat >=v[1] then
								if (v[4] == 'len' and beat <=v[1]+v[2]) or (v[4] == 'end' and beat <=v[2]) then
									if table.getn(v) == 5 then
										mod_do(v[3],v[5]);
									else
										mod_do(v[3]);
									end
								end
							end
						else
							v[1] = 0;
							v[2] = 0;
							v[3] = '';
							v[4] = 'error';
							SCREENMAN:SystemMessage('Bad mod in beat-based table (line '..i..')');
						end
					end
					
					-----------------------------------------------------------------------------------------------------
					-- WinDEU's time-based len/end version of the #swag custom mod reader #teamproofofconcept (c) 2015 --
					-----------------------------------------------------------------------------------------------------
					for i,v in pairs(mods2) do
						if v and table.getn(v) > 3 and v[1] and v[2] and v[3] and v[4] then
							if mod_time >=v[1] then
								if (v[4] == 'len' and mod_time <=v[1]+v[2]) or (v[4] == 'end' and mod_time <=v[2]) then
									if table.getn(v) == 5 then
										mod_do(v[3],v[5]);
									else
										mod_do(v[3]);
									end
								end
							end
						else
							v[1] = 0;
							v[2] = 0;
							v[3] = 'error';
							v[4] = 'error';
							SCREENMAN:SystemMessage('Bad mod in time-based table (line '..i..')');
						end
					end
					
					--------------------------------------------------------------------------------------
					-- i dont know who this reader is but he looks like he is made out of EASE HAHAHAHA --
					-- original code by exschwasion, bastardized by taro for cmod support and less 'if' --
					--------------------------------------------------------------------------------------
					for i,v in pairs(mods_ease) do
						if v and table.getn(v) > 6 and v[1] and v[2] and v[3] and v[4] and v[5] and v[6] and v[7] then
							if beat >=v[1] then
								if (v[6] == 'len' and beat <=v[1]+v[2]) or (v[6] == 'end' and beat <=v[2]) then
									
									local duration = v[2];
									if v[6] == 'end' then duration = v[2] - v[1] end
									local curtime = beat - v[1]
									local diff = v[4] - v[3]
									local startstrength = v[3]
									local curve = v[7]
									local mod = v[5]
									
									local strength = curve(curtime, startstrength, diff, duration, v[10], v[11]) --extra parameters for back and elastic eases :eyes:
									
									local modstr = v[5] == 'xmod' and strength..'x' or (v[5] == 'cmod' and 'C'..strength or strength..' '..v[5])
									mod_do('*10000 '..modstr,v[8]);
									
								elseif (v[9] and ((v[6] == 'len' and beat <=v[1]+v[2]+v[9]) or (v[6] == 'end' and beat <=v[9]))) then
								
									local strength = v[4]
									
									local modstr = v[5] == 'xmod' and strength..'x' or (v[5] == 'cmod' and 'C'..strength or strength..' '..v[5])
									mod_do('*10000 '..modstr,v[8]);
									
								end
							end
						else
							SCREENMAN:SystemMessage('Bad mod in beat-based ease table (line '..i..')');
						end
					end
					
					--------------------
					-- Perframe stuff --
					--------------------
					
					----------------------------------------
					-- HBLBHCBLBJGBHL DO THIS EVERY FRAME --
					----------------------------------------
					
					if table.getn(mod_perframes)>0 then
						for i=1,table.getn(mod_perframes) do
							local a = mod_perframes[i]
							if beat > a[1] and beat < a[2] then
								a[3](beat);
							end
						end
					end
					
					---------------------------------------
					-- ACTION RPGS AINT GOT SHIT ON THIS --
					---------------------------------------
					while curaction<=table.getn(mod_actions) and GAMESTATE:GetSongBeat()>=mod_actions[curaction][1] do
						if mod_actions[curaction][3] or GAMESTATE:GetSongBeat() < mod_actions[curaction][1]+2 then
							if type(mod_actions[curaction][2]) == 'function' then
								mod_actions[curaction][2]()
							elseif type(mod_actions[curaction][2]) == 'string' then
								MESSAGEMAN:Broadcast(mod_actions[curaction][2]);
							end
						end
						curaction = curaction+1;
					end
					
				end
				
				self:sleep(1/60);
				self:queuecommand('Update');

	---------------------------------------------------------------------------------------
	----------------------END DON'T TOUCH IT KIDDO-----------------------------------------
	---------------------------------------------------------------------------------------
				
			end"
			
		/>
		
		<Layer Type="ActorFrame" OnCommand="fov,45" ><children>
		
			<Layer File="arena/sky1" Var="ama_sky1" OnCommand="basezoomx,sw/640;basezoomy,sh/480;x,sw/2;y,sh/2;diffuse,.6,.6,.6,1;" />
			
			<Layer File="background" Var="ama_bg" OnCommand="basezoomx,sw/640;basezoomy,sh/480;xy,sw/2,sh/2;diffuse,.5,.5,.5,1;zoom,1;" />
			
			<Layer File="arena/clouds" Var="ama_clouds1" InitCommand="x,SCREEN_CENTER_X;y,SCREEN_CENTER_Y;ZoomToWidth,SCREEN_WIDTH;ZoomToHeight,SCREEN_HEIGHT;
			customtexturerect,0,0,1,1;texcoordvelocity,0.05,0;fadebottom,0.1;cropbottom,0.1;diffuse,.7,.7,.7,0;" />
			
			<Layer File="arena/floor1" Var="ama_floor1" OnCommand="basezoomx,sw/640;basezoomy,sh/480;x,sw/2;y,sh/2+200;zoom,1.5;diffusealpha,0;
			diffuseshift;effectperiod,3;effectcolor2,.7,.7,.7,1;effectcolor1,.5,.5,.5,1;" />
			
			<Layer File="arena/light" Var="ama_light" OnCommand="blend,add;diffusealpha,.3;x,sw/2;basezoomx,1.8;basezoomy,.4;y,sh*.75;zoom,0;"
			SpotOnMessageCommand="x,sw/2;bounceend,0.3;zoom,1;" SpotOffMessageCommand="bouncebegin,0.3;zoom,0;x,sw/2;rotationz,0;" />
			
			<Layer File="chara" />
			
			<Layer File="arena/spotlight" Var="ama_spotlight" OnCommand="blend,add;diffusealpha,.4;valign,0;x,sw/2;y,-30;zoomx,0;"
			SpotOnMessageCommand="rotationz,0;bounceend,0.3;zoomx,1;" SpotOffMessageCommand="bouncebegin,0.3;zoomx,0;x,sw/2;rotationz,0;" />
			
			<Layer Type="ActorFrame" OnCommand="%function(self) ama_beam = self end" ><children>
				<Layer File="beam.png" OnCommand="diffusealpha,0;"/>
			</children></Layer>
		
		</children></Layer>
		
		<Layer Type="ActorFrame" InitCommand="%function(self) comc = self end"><children>
		<Layer Type="ActorProxy" InitCommand="%function(self) com1p = self end"
		GetProxyMessageCommand="%function(self) if P1 then self:SetTarget(P1:GetChild('Combo')) end end"/>
		<Layer Type="ActorProxy" InitCommand="%function(self) com2p = self end"
		GetProxyMessageCommand="%function(self) if P2 then self:SetTarget(P2:GetChild('Combo')) end end"/>
		</children></Layer>
		
		<Layer File="ama" OnCommand="diffusealpha,0;scaletofit,0,0,sw,sh*0.75;x,sw/2;vertalign,bottom;y,sh;"
			Haihai1MessageCommand="%function(self)
				self:diffusealpha(1)
				self:basezoomx(1)
				self:x(-240*0.75)
				self:tween(1.5,'outExpo(%f,0,1,1)')
				self:x(sw/2)
				self:accelerate(2)
				self:diffusealpha(0)
			end"
			Haihai2MessageCommand="%function(self)
				self:diffusealpha(1)
				self:basezoomx(-1)
				self:x(sw+240*0.75)
				self:tween(1.5,'outExpo(%f,0,1,1)')
				self:x(sw/2)
				self:accelerate(2)
				self:diffusealpha(0)
			end"
		/>
		
		<Layer Type="ActorProxy" GetProxyMessageCommand="%function(self) if P1 then self:SetTarget(P1) end end" />
		<Layer Type="ActorProxy" GetProxyMessageCommand="%function(self) if P2 then self:SetTarget(P2) end end" />
		
		<!--This is for the time based mod reader-->
		<BitmapText
			Font="Common Normal"
			Text="test"
			OnCommand="x,SCREEN_CENTER_X;y,SCREEN_CENTER_Y;effectclock,music;playcommand,SetTime;hidden,1"
			SetTimeCommand="%function(self) self:settext(self:GetSecsIntoEffect()); mod_time = mod_globaloffset+tonumber(self:GetText()); self:sleep(0.02); self:queuecommand('SetTime'); end"
		/>
		
		<Layer Type="ActorFrame" InitCommand="%function(self) judc = self end"><children>
		<Layer Type="ActorProxy" InitCommand="%function(self) jud1p = self end"
		GetProxyMessageCommand="%function(self) if P1 then self:SetTarget(P1:GetChild('Judgment')) end end"/>
		<Layer Type="ActorProxy" InitCommand="%function(self) jud2p = self end"
		GetProxyMessageCommand="%function(self) if P2 then self:SetTarget(P2:GetChild('Judgment')) end end"/>
		</children></Layer>
		
	</children></Layer>
	
</children></ActorFrame>