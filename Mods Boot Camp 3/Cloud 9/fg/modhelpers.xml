<ActorFrame><children>
<CODE Type="Quad" OnCommand="hidden,1"
	InitCommand="%function(self)

		function math.clamp(val,min,max)
			if val > max then return max end
			if val < min then return min end
			return val
		end

		function normalize(value,min,max,nmin,nmax)
			return nmin + (value-min)*(nmax-nmin)/(max-min)
		end

		function mod_do(str,pn)
			GAMESTATE:ApplyModifiers(str,pn)
		end

		function modtable_compare(a,b)
			return a[1] < b[1]
		end

		function perframe( beat, endBeat )
			local cur = GAMESTATE:GetSongBeat();
			return cur >= mod_firstSeenBeat+1 and cur >= beat and cur < (endBeat or beat+1);
		end

		function mod_insert(beat,len,mod,t,pn)
			if not t then t = 'len' end
			table.insert(mods,{beat,len,mod,t,pn});
		end
		
		function mod2_insert(beat,len,mod,t,pn)
			if not t then t = 'len' end
			table.insert(mods2,{beat,len,mod,t,pn});
		end
		
		function mod_ease(beat,len,str1,str2,mod,t,ease,pn,sus,a,p)
			table.insert(mods_ease,{beat,len,str1,str2,mod,t,ease,pn,sus,a,p})
		end
		
		function mod_message(beat,msg,p)
			table.insert(mod_actions,{beat,msg,p});
		end

		-- world's ugliest function
		-- ease_wiggle now supports absolute values
		function ease_wiggle(beat,len,amt,step,str,ease,t,pn,abs)
		    local s,count,pStart,pEnd,cur,prev,e = 0,1,0,0,-amt,amt,0
		    abs = abs or false
		    if t == 'end' then e = len elseif t == 'len' then e = (beat+len) end
		    if abs == true then prev,cur,s = 0,-cur,step end
		    for i = beat,(e-s),step do
		        if abs == false then
		            if i == beat then pStart = 0 else pStart = prev end
		            if i == e then pEnd = 0  else pEnd = cur end
		        elseif abs == true then
		            if count == -1 then cur,prev = 0,amt elseif count == 1 then cur,prev = amt,0 end
		            pStart,pEnd = prev,cur
		        end
		        mod_ease(i,step,pStart,pEnd,str,'len',ease,pn)
		        if abs == false then cur,prev = -cur,-prev
		        elseif abs == true then count = -count
		        end
		    end
		end

		function modulo(a, b)
			return a - math.floor(a/b)*b;
		end

		function mod_bounce(beat,length,start,apex,mod,ease,inverse,pn)
			local i,o = 'in','out'
			if inverse == true then i,o = 'out','in' end
			mod_ease(beat, (length/2), start, apex, mod, 'len', _G[o..''..tostring(ease)],pn)
			mod_ease(beat+(length/2), (length/2), apex, start, mod, 'len', _G[i..''..tostring(ease)],pn,0.2)
		end

		function randomXD(t)
			if t == 0 then return 0.5 else
			return modulo(math.sin(t * 3229.3) * 43758.5453, 1) end
		end
		
		local switcheroo_flip = {0,0,0};
		local switcheroo_invert = {0,0,0};
		function switcheroo_add(beat,which,speed,len,pn,width)
			if not width then width = 1 end
			local switcheroo_width = width
			local switcheroos = {normal = {0,0}, ldur = {0,0}, reset = {0,0},
			flip = {100,0}, rudl = {100,0}, invert = {0,100}, dlru = {0,100},
			ludr = {25,-75}, rdul = {75,75}, drlu = {25,125}, ulrd = {75,-125}, urld = {100,-100}}
			if not speed then speed = 1000000 end
			local mpn = 3
			if pn then mpn = pn end
			local w = {0,0}
			if type(which) == 'string' then w = switcheroos[which] end
			if type(which) == 'table' then w = which end
			if w then
				local targf = (switcheroos[which][1]*switcheroo_width) + ( 50 - switcheroo_width*50 )
				local targi = (switcheroos[which][2]*switcheroo_width)
				local sw_modlist = ''
				if switcheroo_flip[mpn] ~= targf then
					sw_modlist = sw_modlist..'*'..(0.01*speed*math.abs(targf-switcheroo_flip[mpn]))..' '..(targf)..' flip,'
				else
					sw_modlist = sw_modlist..'*1 '..(targf)..' flip,'
				end
				if switcheroo_invert[mpn] ~= targi then
					sw_modlist = sw_modlist..'*'..(0.01*speed*math.abs(targi-switcheroo_invert[mpn]))..' '..(targi)..' invert'
				else
					sw_modlist = sw_modlist..'*1 '..(targi)..' invert'
				end
				table.insert(mods,{beat,len,sw_modlist,'len',pn});
				if mpn == 3 then
					for apn=1,3 do
						switcheroo_flip[apn] = targf;
						switcheroo_invert[apn] = targi;
					end
				else
					switcheroo_flip[mpn] = targf;
					switcheroo_invert[mpn] = targi;
				end
			end
		end

		function mod_quickswaps(beat,len,which,speed,step,pn)
			for i = beat,(beat+len)-(step*2),(step*2) do
				switcheroo_add(i,tostring(which),speed,step,nil)
				switcheroo_add(i+step,'normal',speed,step,nil)
			end
		end

		function bouncy_wiggle(beat,len,step,start,apex,mod,t,ease,abs,pn,inc)
			if not inc then inc = 0 end
			local f = 1 if t == 'end' then shit = len else shit = (beat+len) end
			local ass = 0
			for i = beat,(shit-step),step do
				if abs == true then fuck = (apex+ass) else fuck = (apex+ass)*f end
				mod_bounce(i,step,start,fuck,mod,tostring(ease),false,pn)
				f=-f
				ass = ass + inc
			end
		end

		function SpawnPlayers(beat,lower,upper,which,persist)
			local offset = -0.1
			local w = tostring(which)
			if which == 'despawn' then offset = -offset end
			mod_message(beat+offset,function(self)
				for i = lower,upper,1 do
					local a = _G['P'..i]
					if a then
						if w == 'spawn' then
							a:SetAwake(true)
						elseif w == 'despawn' then
							a:SetAwake(false)
						end
						a:zoom(0)
					end
				end
			end,persist)
			mod_message(beat,function(self)
				for i = lower,upper,1 do
					local a = _G['P'..i]
					if a then
						if w == 'spawn' then
							a:hidden(0)
							a:zoom(1)
						elseif w == 'despawn' then
							a:zoom(0)
							a:hidden(1)
						end
					end
				end
			end,persist)
		end

		function mod_intox(beat,length,amt,speed,period,ease,pn)
			mod_insert(beat,length+1, '*-1 '..speed..' drunkspeed,*-1 '..period..' drunkperiod','len',pn)
			mod_insert(beat+(length+1),0.1, '*-1 no drunkspeed,*-1 no drunkperiod','len',pn)
			mod_ease(beat, length, amt, 0, 'drunk', 'len', _G['out'..tostring(ease)], pn)
		end

		--s/o to BrotherMojo
        function reverseRotation(angleX, angleY, angleZ)
            local sinX = math.sin(angleX);
            local cosX = math.cos(angleX);
            local sinY = math.sin(angleY);
            local cosY = math.cos(angleY);
            local sinZ = math.sin(angleZ);
            local cosZ = math.cos(angleZ);
            return { math.atan2(-cosX*sinY*sinZ-sinX*cosZ,cosX*cosY),
                     math.asin(-cosX*sinY*cosZ+sinX*sinZ),
                     math.atan2(-sinX*sinY*cosZ-cosX*sinZ,cosY*cosZ) }
        end
        
        function rotateAndCounter(xDegrees, yDegrees, zDegrees, player_or_object)
            local DEG_TO_RAD = math.pi / 180;
            local angles = reverseRotation(xDegrees * DEG_TO_RAD, yDegrees * DEG_TO_RAD, zDegrees * DEG_TO_RAD);
            local str = ''
            if type(player_or_object) == 'number' then
            str = '*-1 '..xDegrees..' rotationx, *-1 '..
                        yDegrees..' rotationy, *-1 '..
                        zDegrees..' rotationz, '
            else
                if player_or_object then
                    player_or_object:rotationx(xDegrees)
                    player_or_object:rotationy(yDegrees)
                    player_or_object:rotationz(zDegrees)
                end
            end
            str = str..'*-1 '..(angles[1]*100)..' confusionxoffset, *-1 '..
                        (angles[2]*100)..' confusionyoffset, *-1 '..
                        (angles[3]*100)..' confusionzoffset';
                        
            return str
        end

        function mod_GetCounterRotation(xDegrees, yDegrees, zDegrees)
            local DEG_TO_RAD = math.pi / 180;
            local angles = reverseRotation(xDegrees * DEG_TO_RAD, yDegrees * DEG_TO_RAD, zDegrees * DEG_TO_RAD);
            return {angles[1]*100, angles[2]*100, angles[3]*100}
        end

		function RotationFromAux(xAmt,yAmt,zAmt,aux,pn)
			local cam = aux
			local angs = mod_GetCounterRotation(cam:GetX(),cam:GetY(),cam:GetZ())
			local ax,ay,az = angs[1],angs[2],angs[3]
			if cam then
				cam:xyz(xAmt,yAmt,zAmt)
				mod_do('*-1 '..ax..' confusionxoffset,*-1 '..
				ay..' confusionyoffset,*-1 '..
				az..' confusionoffset,*-1 '..
				xAmt ..' rotationx,*-1 '..
				yAmt ..' rotationy,*-1 '..
				zAmt ..' rotationz',pn)
			end
		end

		function mod_sugar(beat,len,step,pn,stealth)
			local st,c = 0,2
			if not stealth then stealth = {0,0} end
			for i = 0,len,step do
				local s = {'normal','invert','flip'}
				if stealth then st = stealth[1] end
				if c > table.getn(s) or i == len then 
					c = 1 if stealth then st = stealth[2] end
				end
				if stealth then
					mod_insert(beat+i, step, '*9999 '.. st .. ' stealth', 'len', pn)
					mod_insert(beat+len, step, '*9999 no stealth', 'len', pn)
				end
				switcheroo_add(beat+i,s[c],999,step,pn)
				c = c + 1
			end
		end

	end"
/>
</children></ActorFrame>